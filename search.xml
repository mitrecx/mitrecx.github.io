<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[dropwizard migrate 记录]]></title>
    <url>%2F2020%2F03%2F26%2Fdropwizard-migrate-%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1 Dropwizard Migrations参考 官网. 12# 正常添加字段: 先在 xml 中加 changeSet, 再执行下面命令java -jar hello-world.jar db migrate helloworld.yml 2 手动在数据添加如果手动写 sql 做 DDL 操作, 需要在 migrations.xml (和 migrations_for_unittests.xml)中 添加 相应的 DDL 操作. 比如, 在 products 表中 手动加了一个字段 test_column:1ALTER TABLE products ADD COLUMN test_column text ; 需要在 products_table.xml(被 migrations.xml 和 migrations_for_unittests.xml 引用) 中加入:123&lt;changeSet id="add_test_column" author="cx"&gt; &lt;sql&gt;ALTER TABLE products ADD COLUMN test_column text&lt;/sql&gt;&lt;/changeSet&gt; 然后运行:1234567# 注意如果直接运行 java -jar hello-world.jar db migrate helloworld.yml# 会报错: test_column 已经存在# fast-forward changeSet, 只在 databasechangelog 记录, 不会再做 DDLjava -jar hello-world.jar db fast-forward -i add_test_column helloworld.yml# 此时, 再运行 java -jar hello-world.jar db migrate helloworld.yml 就正常了 到数据库查看 databasechangelog :1select * from databasechangelog order by dateexecuted desc limit 10; 3 总结如果是一张很大的表, 执行 db migrate 可能会长时间锁表, 应该考虑手动添加 再 db fast-forward.(待验证) 两个未解决的问题:学习 Liquibase 如何工作的?如何 unit test DB ?(三周内更新)]]></content>
      <tags>
        <tag>dropwizard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记-墨菲定律]]></title>
    <url>%2F2020%2F03%2F01%2F%E5%A2%A8%E8%8F%B2%E5%AE%9A%E5%BE%8B%2F</url>
    <content type="text"><![CDATA[最近读了 &lt;&lt;墨菲定律&gt;&gt; 这本书, 花了点时间提取出了 20% 的精华. 剩下 80% 我觉得有点扯淡, 就不提了. 1 墨菲定律如果你担心某种情况发生, 那么它很有可能发生. 不存在侥幸心理, 我们应该正视错误, 总结错误, 在错误中学习.事实上我们主要从尝试和错误中学习, 而不是从正确中学习. 2 奥卡姆剃刀定律把握关键, 化繁为简. 把复杂的问题简单化, 选择越少越专注.当你面对问题时, 应当思考: “什么是解决这个问题 或 实现目标 的最简单直接的方法?” 3 洛克定律确定目标, 专注行动. 哈佛大学 曾经做过一个跟踪调查, 调查对象是 一群智力,学历,生活环境都差不多的年轻人;发现 90% 的人没有目标, 6% 的人有模糊的目标, 4% 的人有清晰明确的目标;20 年后, 那 4% 的 有明确目标的人 在生活, 工作, 事业上比另外 96% 的人都要成功;不可思议的是, 4% 的人拥有的 财富总和 超过了 96% 的人的财富总和. “成功是 目标的达成, 其它的都是这句话的注解.” –博恩.崔西 我觉得目标 分 短期 和 长期 两种, 长期目标可以宏大,但短期目标一定要 控制在超出自己能力一点点的地方.总结:没有目标 -&gt; 碌碌无为;短期目标太大 -&gt; 总是失败;跳一跳能够得着的短期目标 -&gt; 良性循环 (不断成长). 4 艾森豪威尔法则分清主次, 高效成事. 事有轻重缓急, 有的时候我们会发现一个人很忙, 但是当你问他忙啥时(为啥这么忙?),他却说不出所以然. 可能就是因为 他忙的都是 轻的事, 不重要的事, 琐碎的事. 艾森豪威尔分类法:A: 必须要做的事 ;B: 应该要做的事 ;C: 量力而为的事 ;D: 可委托他人去做的事;E: 应该删除的事 . 可以每天把自己要做的事 按照 上面的分类 划分;同样的道理, 可以把自己 1-5 年的要做的事情列出来, 然后按优先级分类, 比如:A: 最想做的事(必须要做的事) ;B: 应该要做的事 ;C: 做了会更好, 不做也无大碍的事. 到底是什么偷走了你的时间?想明白的话, 拿出纸笔, 按照艾森豪威尔原则 规划一下. 这里有一个苏格拉底的故事:苏格拉底 往罐子里装 鹅卵石, 装满后;往罐子里装 碎石子, 装满后;往罐子里装 沙子, 装满后;往罐子里装 水, 装满.苏格拉底说: 如果你不先将大的鹅卵石放进去, 也许以后再也没有机会放进去了. 做事前一定要把 事情分个等级, 科学安排时间给重要的事, 不要胡子眉毛一把抓. 5 酝酿效应灵感来自偶然, 有时不期而至. 遇到某个难题, 冥思苦想不得其解, 花了几个小时仍一无所获,暂时想忘掉它, 休息一会或酝酿(小憩一下, 喝杯茶, 或者干脆隔一段时间), 可能就茅塞顿开了. 心理学家认为, 人在酝酿中, 存在 潜意识推理 , 存储在记忆力的相关信息在 潜意识里组合, 而在穿插其它的事情的时候突然找到答案. 6 基利定理失败是成功之母. 人一生中有很多机会, 我们要有承受失败的勇气, 一次比一次更好.一个人的人生是否丰富, 不能看他的年龄, 而要看他生命的过程是否多彩. 7 蘑菇定律新人, 想成蝶? 先破茧!!! 蘑菇在阴暗的地方, 没有阳光, 自生自灭, 不被人关注;只有长到足够高的时候, 才开始被人们注意到. 如果想在职场中有所作为, 就要先适应它的游戏规则;待到实力壮大, 羽翼丰满之后, 再通过自己的能力制定新的规则. 8 青蛙法则生于忧患, 死于安乐. 35岁危机是说 许多人到35岁, 一事无成, 在机会面前不敢尝试.时刻充电, 但是也要充足了(不是只有你一个在充电), 因为:“不够优秀什么时候都会被淘汰.” 9 鲁尼恩定律戒骄戒躁, 做笑到最后的大赢家. 别人称赞你的时候, 想想自己的远大计划,相比将来的宏伟蓝图, 现在只是万里长征的第一步. 为自己的工作结果 制定标准, 严格落实到最后一个环节, 不要认为事情快要完成了 就掉以轻心, 毛毛躁躁. 10 链状效应想抱怨就微笑. 抱怨解决不了问题. 谁也不希望别人的 消极情绪 影响到自己的好心情, 所以想对别人抱怨的时候, 就微笑. 11 刻板效应偏见的认知 源于 记忆中的刻板. 题外话: 我觉得, 在某些情况下, 记忆中的刻板 也有好处;Exceptions can be found to any rule. 不在辩论. 不要以偏概全, 扩大视野, 少一点主观性, 多角度思考. 12 古德曼定律没有沉默, 就没有沟通. 这个世界需要说出来的勇气, 更需要听进去的耐心. 13 沉默的螺旋人们在表达自己的观点时, 如果看到这个观点广受欢迎, 这类观点就越发大胆的扩散; 如果发现某一个观点很少有人理会, 即使自己赞同也会保持沉默. 沉默的螺旋告诉我们, 生活的环境, 周围的人都会影响到我们.比如: 周围的人都在努力, 自己也不甘人后; 周围的人都在玩耍, 自己也不愿孤单独处. 沉默螺旋随处可见, 有积极的影响, 也有消极的影响. 总之, 不要让别人的言行左右了自己的前进方向;毕竟, 有主见才有魅力. 14 羊群效应集体里的人们往往会盲目从众, 在集体的运动中丧失独立的判断.羊群效应 也叫 从众心理. 群众的眼睛可能不是雪亮的. 15 犯人船理论制度比人治更有效. 18 世纪, 英国政府 支付费用 委托私人船主 运送囚犯到澳大利亚;运到澳洲时, 4082 个囚犯死了498 个, 死亡率超过 10%;对此, 英政府实施了一个新制度, 政府不再按照走上船的囚犯人数支付费用, 而按照活着到达澳洲的人数支付费用;然后死亡率 降到了 1% 以下. 16 鲶鱼效应让外来的鲇鱼制造紧张的气氛. 挪威人喜食沙丁鱼, 活鱼比死鱼价格高许多;渔民为了能把活得沙丁鱼带回渔港, 通常会在鱼槽中放一条鲇鱼;鲶鱼的存在让沙丁鱼十分紧张, 四处游动;这样一条条活鱼就回到了渔港.如果不放鲇鱼的话, 大部分沙丁鱼会窒息而死. 对企业而言, 将”鲇鱼” 加进来, 会制造一些紧张气氛, 让企业焕发活力.对个人而言, 给自己找一条 “鲇鱼”, 保持适度的压力. 17 参与定律参与是支持的前提. 如果想让别人支持你的决策, 就让他参与决策的讨论. 18 吸引力法则我们在一起很合得来. 如果有人问你: “为什么选择他/她 作为另一半呢? 漂亮? 帅气? 聪明? 有钱? “你给出的答案往往是: “我们在一起很合得来.” 通常情况下, A 喜欢的人, 是那些也喜欢 A 的人. 几乎没有人是完全自信的, 大多数人都需要别人对自己的肯定;这样一来, 那些喜欢我们的人, 通过对我们的肯定, 追求等,便为我们喜欢他们打下了基础. 敞开心扉, 放开思想, 抛弃负面情绪, 然后:“跟着感觉走, 像风一样自由.” 19 酸葡萄甜柠檬定律只要你愿意, 总有理由幸福. &lt;&lt;伊索寓言&gt;&gt; 中有个故事:一只饥饿的狐狸路过 果林时, 看到架子上有许多葡萄;于是就去摘, 可是怎么也够不到;就在失望的时候, 狐狸却笑道: “那些葡萄还没有长熟, 肯定是酸溜溜的.”于是它高兴地走开了. 一句自我安慰, 让狐狸走出沮丧, 变得快乐起来. 酸葡萄式的自我安慰很常见, 如,单身族: “一个人多好, 多自在.”农村人: “城里不好, 人多环境差.”城里人: “农村不好, 交通不便.”… 与 “酸葡萄” 对立的是 “甜柠檬” 心理.甜柠檬心理:人们对得到的东西, 尽管不满意, 也坚持认为是好的. 生活不可能十全十美, 幸福者都懂得适度的运用 “酸葡萄” 和 “甜柠檬”. 20 幸福递减定律当你饿的时候, 给你一块面包, 你吃起来会很香;给你第二块, 可能就没有第一块那么香了;第三块, 第四块… 最后就一点都不香了. 饥饿者得到的面包数量不断增加, 幸福感却减少了. 这便是幸福递减定律.事实上, 由于我们的内心发生了变化, 对幸福失去了敏感. 因为幸福递减的特性, 我们必须要有一颗感恩之心. 21 野马结局不生气是一种修行. 野马结局来源于一个故事:野马受不了吸血蝙蝠的叮咬, 暴怒而亡.但是吸血蝙蝠的叮咬并不足以杀死野马.(有可能是新冠肺炎) 一个生气/生闷气 的人, 生理上会产生一系列的变化, 导致人体器官损伤. 当我们生气的时候可以转移注意力. 最后看一个故事:在古老的西藏, 有一个叫爱地巴的人, 每次生气和人起争执的时候, 就以很快的速度跑回家去, 绕着自己的房子和土地跑三圈, 然后坐在田地边喘气.爱地巴工作非常勤劳努力, 他的房子越来越大, 土地也越来越广, 但不管房地有多大, 只要与人争论生气, 他还是会绕着房子和土地绕三圈, 爱地巴为何每次生气都绕着房子和土地绕三圈? 所有认识他的人, 心理都起疑惑, 但是不管怎么问他, 爱地巴都不愿意说明. 直到有一天, 爱地巴很老, 他的房地又已经太广大, 他生气, 拄着拐杖艰难的绕着土地跟房子, 等他好不容易走三圈, 太阳都下山, 爱地巴独自坐在田边喘气.他的孙子在身边恳求他：”阿公, 你已经年纪大, 这附近地区的人也没有人的土地比你更大, 您不能再像从前, 一生气就绕着土地跑啊！您可不可以告诉我这个秘密, 为什么您一生气就要绕着土地跑上三圈?” 爱地巴禁不起孙子恳求, 终于说出隐藏在心中多年的秘密.他说：”年轻时, 我一和人吵架、争论、生气, 就绕着房地跑三圈, 边跑边想, 我的房子这么小, 土地这么小, 我哪有时间, 哪有资格去跟人家生气, 一想到这里, 气就消了, 于是就把所有时间用来努力工作.“ 孙子问到：”阿公, 你年纪老, 又变成最富有的人, 为什么还要绕着房地跑？”爱地巴笑着说：”我现在还是会生气, 生气时绕着房地走三圈, 边走边想, 我的房子这么大, 土地这么多, 我又何必跟人计较? 一想到这, 气也消了.“]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postgreSQL简单配置]]></title>
    <url>%2F2020%2F02%2F28%2FpostgreSQL%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[卸载 yum 方式安装的 postgreSQL用以下两个命令查看 系统信息 :123lsb_release -auname -a 卸载 postgreSQL :12345678910# yum 删除软件包sudo yum remove postgresql*# 删除相关目录文件：sudo rm -rf /var/lib/pgsqlsudo rm -rf /usr/pgsql*# 删除pg相关用户组/用户sudo userdel -r postgressudo groupdel postgres 源码方式安装 postgreSQLpostgreSQL 官网 介绍的安装方式有多种. 这里简单介绍一下 编译源码 这种安装方式:1, 下载源码(点击下载);2, 解压并进入 postgresql-version 目录, 打开 INSTALL3, 按照 INSTALL 文件的 指示安装:1234567891011121314151617./configuremakesumake installadduser postgresmkdir /usr/local/pgsql/datachown postgres /usr/local/pgsql/datasu - postgres# 初始化数据库/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data# 启动/usr/local/pgsql/bin/pg_ctl -D /usr/local/pgsql/data -l logfile start# 创建数据库 test/usr/local/pgsql/bin/createdb test# 以 postgres role 连接到 test 数据库/usr/local/pgsql/bin/psql test 提示:如果 ./configure 提示 缺少 lib 则安装对应的 lib , 比如:12sudo yum install readline-devel -ysudo yum install zlib-devel.x86_64 -y start 与 stop :123456789# 切到 postgres 用户, 进入 ~/.bashrc , 把 bin 添加到 PATHexport PATH=$PATH:/usr/local/pgsql/bin# startpg_ctl -D /usr/local/pgsql/data/ -l logfile start# statuspg_ctl -D /usr/local/pgsql/data/ -l logfile status# stoppg_ctl -D /usr/local/pgsql/data/ -l logfile stop 远程访问 postgreSQLClient authentication is controlled by a configuration file,which traditionally is named pg_hba.conf and is stored in the database cluster’s data directory.(HBA stands for host-based authentication.)A default pg_hba.conf file is installed when the data directory is initialized by initdb. 修改 以下两个文件 :12345678910# 1, host-based authentication 配置文件:sudo vim /usr/local/pgsql/data/pg_hba.conf# 添加一行host all all 0.0.0.0/0 md5# 2, 全局配置文件:sudo vim /usr/local/pgsql/data/postgresql.conf# 修改一行listen_addresses = '*'# defaults to 'localhost'; use '*' for all 然后重启 postgreSQL . 修改 role 密码terminal 截取片段:123456789[postgres@shumingly ~]$[postgres@shumingly ~]$ psql -h localhost -U postgres testpsql (12.0)Type &quot;help&quot; for help.test=# ALTER USER postgres WITH PASSWORD &apos;国际通用密码&apos;;ALTER ROLEtest=# \q[postgres@shumingly ~]$]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-Exploring]]></title>
    <url>%2F2020%2F02%2F22%2F2020-Exploring%2F</url>
    <content type="text"><![CDATA[这篇 blog 原本名称应该是 “2019-探索”;因为 本文是对 2019 年的总结.但是, 我写这片 blog 时已经是 2020 年的 2 月了;之前一直在忙着工作的事情, 耽搁了总结.不过, 我还是决定以后把总结放在后一年写, 然后用题目 表达后一年的状态. 不出意外的话, 明年的题目应该是, 2021-再出发. 1 总结 2019看了 18年底写的2019年的计划, “革新” 基本上是成功了. 1.1 以下是 2019 的目标及完成得分目标1:开源框架掌握一套(0.4);没有掌握透彻, 仅仅达到简单的工作需要, 出了问题无法快速解决. 目标2:技术氛围好的工作(0.9);9月份从宇信离职来到别样. 目标3:读英文文档的能力(0.3);做了一些尝试, 比如打印文档阅读, 读英文文档能力有所提高, 但是离无障碍阅读还有很大距离. 目标4:提高博客质量(0.2);有时工作中有问题我会看自己的博客, 但能看的只是个位数. 目标5:管理学/心理学书籍阅读(0.6);读了4-5本书, 包括&lt;&lt;瞬变&gt;&gt;, &lt;&lt;情商&gt;&gt;, &lt;&lt;见识&gt;&gt;, &lt;&lt;你只是看起来很努力&gt;&gt;. 有的没完全读完. 总结来看, 英文水平 和 博客质量 两个目标脱了后腿;英文水平 的提高是 至关重要 的, 是我个人目标中 “百年大计”. 1.2 2019 年事件回顾2019年2月初, 过完春节回到江阴农商行工作;2019年2月初, 刚到江阴3天, 就被调到(常州)江南农商行, 在常州期间自学了一些东西, 包括设计模式, Maven, JS等;2019年4月, 回到寿县考驾照科目三, 没过;2019年4月17, 调我 和 桑前进 到上海兴业银行;2019年4月底, 回到寿县考驾照科目三, 通过;2019年9月27, 从宇信离职;宇信很大, 到我离职时, 我已经从边缘的实施(江阴) 到部门重点实施(常州) 再到总部重点研发(上海), 经历了许多考验.这个过程我用了1年零2个月.在 辛伟 领导下的 宇信兴业项目组中, 我度过了1年中最充实的6个月;在工作中, 在个人成长中, 辛伟都给了我很大的帮助, 非常感谢辛伟.还有上海的同事, 还有超奇, 前进, 杨杰, 兴业这段时间很辛苦, 也很幸福… 2019年10月1, 搬离芳华路, 来到唐镇, 感谢大鹏帮我搬家. 2019年10月28, 入职别样, 别样是一个技术氛围很好的公司, 同时也很年轻;和宇信的工作不同, 别样的程序是现成的, 大量的逻辑, 大量的代码;开始的工作是有一点困难的, 因为一个简单的开发任务必须理解清楚之前的逻辑, 才能把自己的功能加进去.从现在来看, 显然我已经度过了开始的那个困难时期;不过, 我知道要想提高知名度, 仅仅按部就班完成工作是远远不够的.在别样, 我才刚刚起步, 还有很长的路要走. 2 探索 2020 年和宇信的不稳定相比, 别样则好多了.既然有了稳定的环境, 下一步就是 探索 了.别样研发部有几个大神级的人物, 他们非常值得我学习. 探索 分为两个方面: 技术 和 心智. 2.1 2020 年 OKR 序号 Objectives and Key Results(目标和主要成果) 1 掌握 Java 并发编程, 阅读所有的 JUC 代码; 2 掌握 23 中设计模式(画UML), 设计原则熟稔于心; 3 英文文档阅读能力, 基本无障碍, 完成以下文档阅读: kafka + zookeeper 文档阅读; dropwizard 文档阅读; Redis 文档阅读; 4 明天早晚各一小时英语(一点,喜马拉雅,或笔记): 为了保证学习质量, 没有不可抗拒的因素, 必须11:50前休息, 7:30前起床, 9月份报考 TOEFL, 目标 90分; 5 读书清单: 浪潮之巅, 事实, 人月神话, NLP思维, 深度思考, 人性的弱点,贫穷的本质; 6 每周两道算法题: 读 算法导论 并做记录; 7 一次长途旅行; 8 每月一次技术分享, 仅限技术. 2.2 一点感触过年的时候父母在催 强强 找对象,这种事情, 一千个读者有一千个哈姆雷特, 因人而异.不过父母也是一片好心, 我可以理解. 2020 年 1 月 20 号(事实上2019年12月就有人感染了), 在武汉爆发的 新型冠状病毒(2019-nCoV/SARS-CoV2), 现在似乎有好转的迹象了;这个病毒和 2003 年的非典(重症急性呼吸综合征（SARS）为一种由SARS冠状病毒（SARS-CoV）引起的急性呼吸道传染病) 都是冠状病毒.SARS 病毒 至今尚无肯定有效抗病毒药物治疗.新冠病毒 目前也没有有效药物, 美国的 Remdesivir（瑞德西韦） 似乎有效,但是 双盲实验 到4月份结果才能出来, 也就是说 4月份才能确定它是否有效. 新冠病毒 延长了年假, 推迟了开学时间, 复工时间, 大部分的商场和餐厅已经一个月没有营业了.武汉封城, 即使非湖北人员, 复工前也要隔离14天.距离放年假已经一个月了(1月24号放假), 本周是我第一周在公司上班, 一楼只有我和姜地两个人.上班在地铁公交上人也寥寥无几.一个病毒就改变了我们的生活. 新冠病毒 据推测是 来自于野生动物-中华菊头蝠,人类对大自然还不够了解, 至少目前是的.]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[shell script: 批量启动服务]]></title>
    <url>%2F2019%2F09%2F27%2Fshell-script-%E6%89%B9%E9%87%8F%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[目标:写一个 shell 脚本, 启动多个 worker 服务.(worker 服务 用于处理 消息中间件 里的消息) 先了解一些基础知识, 然后利用这些基础知识 完成目标. 1 读取命令行参数 变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数. 第一个参数是 $1，第二个参数是 $2 $# 传递给脚本或函数的 参数个数 $* 传递给脚本或函数的 所有参数 $@ 传递给脚本或函数的 所有参数 $? 上个命令的退出状态，或函数的返回值。 $$ 当前Shell进程ID 注意 $* 和 $@ 的区别:123$* 获得到的参数是 数组类型, "$*" 获得的参数是 字符串类型$@ 和 "$@" 获得的参数 都是 数组类型 示例代码 t2.sh :123456789101112131415161718192021echo ---"print each param from \$*"for var in $*do echo "$var"doneecho ---"print each param from \"\$*\""for var in "$*"do echo "$var"doneecho ---"print each param from \$@"for var in $@do echo "$var"doneecho ---"print each param from \"\$@\""for var in "$@"do echo "$var"done ./t2.sh mitre cherry 执行结果:1234567891011---print each param from $*mitrecherry---print each param from &quot;$*&quot;mitre cherry---print each param from $@mitrecherry---print each param from &quot;$@&quot;mitrecherry 2 Shell 基本运算Shell 支持多种运算符，包括：1, 算数运算符2, 关系运算符3, 逻辑运算符4, 字符串运算符(略)5, 文件测试运算符(略) 2.1 算数运算原生 bash 不支持简单的数学运算，但是可以通过其他命令来实现，比如 expr 或 awk. expr 是一款表达式计算工具，使用它能完成表达式的求值操作.123#!/bin/bashval=`expr 2 + 2`echo "两数之和为 : $val" 运行结果:1两数之和为 : 4 注意: 1, 表达式 和 运算符 之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样.2, 完整的 表达式 要被 ` ` 包含. 运算符 说明 举例 + 加 `expr $a + $b` 结果为 30。 - 减 `expr $a - $b` 结果为 -10。 * 乘 `expr $a * $b` 结果为 200。 / 除 `expr $b / $a` 结果为 2。 % 取余 `expr $b % $a` 结果为 0。 2.2 关系运算关系运算符 只支持 数字 ，不支持字符串，除非字符串的值是数字. 假定变量 a 为 10，变量 b 为 20: 运算符 说明 举例 -eq equal [ $a -eq $b ] 返回 false -ne not equal [ $a -ne $b ] 返回 true -gt greater than [ $a -gt $b ] 返回 false -lt less than [ $a -lt $b ] 返回 true -ge greater than or equal [ $a -ge $b ] 返回 false -le less than or equal [ $a -le $b ] 返回 true 2.3 逻辑运算假定变量 a 为 10，变量 b 为 20: 运算符 说明 举例 &amp;&amp; 与 AND [[ $a -lt 123 &amp;&amp; $b -gt 123 ]] 返回 false &#124;&#124; 或 OR [[ $a -lt 123 &#124;&#124; $b -gt 123 ]] 返回 true ! 非 见下例 例子:12345if [[ ! 8 -eq 9 ]] ; then echo "8 not equal 9"else echo "8 equal 9"fi 运行结果:18 not equal 9 3 多服务启动脚本 了解前面的基础知识, 写 一个启动多个服务的脚本 很简单了: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/bin/bashjava_dir="/app/jdk1.8.0_191/bin/java"start_port=4242worker_cnt=1jar_name="worker-0.0.1-SNAPSHOT.jar"usage()&#123; (echo "使用方法: $0 起始端口号 worker个数" echo "起始端口号 必须大于 0" echo "worke 个数必须大于 0 同时小于16" ) 1&gt;&amp;2&#125;# 限制参数输入if [ $# -ne 2 ]; then usage exit 1fi# 判断起始端口号是否 合法if [ $1 -gt 0 ] 2&gt;/dev/null ;then start_port=$1else usage exit 1fi # worker 个数必须是大于0的整数if [[ $2 -gt 0 &amp;&amp; $2 -lt 16 ]] 2&gt;/dev/null ;then worker_cnt=$2else usage exit 1fi # 删除日志文件rm nohup*.outecho "正在启动..."for ((i=0;i&lt;$worker_cnt;i++)); do #echo `expr $start_port + $i` port=`expr $start_port + $i` echo "nohup "$&#123;java_dir&#125;" -Xms1024m -Xmx1024m -jar $&#123;jar_name&#125; --server.port=$&#123;port&#125; &gt; nohup$&#123;port&#125;.out 2&gt;&amp;1 &amp;" nohup "$&#123;java_dir&#125;" -Xms1024m -Xmx1024m -jar $&#123;jar_name&#125; --server.port=$&#123;port&#125; &gt; nohup$&#123;port&#125;.out 2&gt;&amp;1 &amp; sleep 4doneecho "启动完成!" 说明:1&gt;&amp;2 把 标准输出 重定向到 标准错误 .因为 标准输出 和 标准错误 最终都是输出到 终端.所以加或不加 1&gt;&amp;2, 运行结果是一样的 . 2&gt;/dev/null 把 标准错误 重定向到 空设备文件 中. 4 关闭多个进程一次性启动了多个进程, 一个一个的手动 kill, 挺费事的.不如 写一个脚本, 一次性关闭 所有 worker 进程: 123#!/bin/bashps -ef | grep worker-0.0.1-SNAPSHOT | awk '&#123;print $2&#125;' | xargs -I&#123;&#125; kill -9 &#123;&#125; 因为 ps 进程 也会产生一个 pid, kill 的 时候会提示:kill 27846: No such process这是因为 ps 进程 在 执行 kill命令前就 已经 关闭了. References1 shell 命令行参数2 shell 基本运算符3 start.sh]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 安装与配置]]></title>
    <url>%2F2019%2F09%2F26%2FRedis-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1 Redis 简介Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.redis是一个开源 (bsd许可) 的 内存数据结构存储，用作数据库、缓存和消息代理。 Redis is written in ANSI C and works in most POSIX systems like Linux, *BSD, OS X without external dependencies.Redis 用 ANSI C 语言编写, 能够无需任何外部依赖地 运行在大多数 POSIX 系统中, 如, Linux, BSD, OS X. 目前, Redis 官网 提供的最新版本是 5.0.5. 2 阿里云主机 CentOS 安装并配置 Redis2.1 下载与安装:1234wget http://download.redis.io/releases/redis-5.0.5.tar.gztar zxf redis-5.0.5.tar.gzcd redis-5.0.5make 2.2 配置在 解压后的目录 redis-5.0.5 下, 有一个 redis.conf 文件.redis.conf 就是 Redis 服务器的配置文件. 修改 redis.conf 文件, 设置外网可访问:12345678# 关闭保护模式protected-mode no# 不限 IP 访问bind 0.0.0.0# 修改默认端口port 6342# 设置密码 为123requirepass 123 把 redis-5.0.5/src 添加到 PATH 环境变量:123456# 新建一个 sh 脚本vim /etc/profile.d/redis.sh# 在脚本中 添加环境变量export PATH=$PATH:绝对路径/redis-5.0.5/src# 使配置立即生效source /etc/bashrc 2.3 配置 云主机的 安全组如下开放 6342 端口: 2.4 运行 Redis12345# 运行 Redisredis-server redis.conf# 客户端 连接redis-cli -h IP地址 -p 端口号 -a 密码 3 Redis 数据类型Redis 支持五种 基本的 数据类型：1, string (字符串)2, hash (哈希)3, list (列表)4, set (集合)5, zset (sorted set: 有序集合) 3.1 stringstring 类型 是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB.1234127.0.0.1:6342&gt; SET name "Mitre"OK127.0.0.1:6342&gt; GET name"Mitre" 3.2 hashhash 类型 是一个 key(string 类型) 和 value 的映射表，hash 特别适合用于存储对象.123456127.0.0.1:6342&gt; HMSET person name "Mitre" age 24OK127.0.0.1:6342&gt; HGET person name"Mitre"127.0.0.1:6342&gt; HGET person age"24" 3.3 list 双向链表list 类型 是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部(左边)或者尾部 (右边).123456789101112127.0.0.1:6342&gt; LPUSH langs "Java" "C++" "Python"(integer) 3127.0.0.1:6342&gt; LPUSH langs "C#"(integer) 4127.0.0.1:6342&gt; RPUSH langs "C"(integer) 5127.0.0.1:6342&gt; LRANGE langs 0 101) "C#"2) "Python"3) "C++"4) "Java"5) "C" 3.4 setset 类型 是 string 类型的无序集合.集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1).123456789101112127.0.0.1:6342&gt; SADD companies "IBM" "google"(integer) 2127.0.0.1:6342&gt; SADD companies "amazon"(integer) 1127.0.0.1:6342&gt; SMEMBERS companies1) "google"2) "IBM"3) "amazon"# set 插入重复数据时, 会忽略掉本次插入127.0.0.1:6342&gt; SADD companies "amazon"(integer) 0 3.5 zsetzset 和 set 一样也是 string类型 元素的集合, 且不允许重复的成员.不同的是 每个元素 都会关联一个 double类型 的分数.redis正是通过分数来为集合中的成员进行从小到大的排序.zset的成员是唯一的, 但分数 (score) 可以重复.12345678127.0.0.1:6342&gt; ZADD billboard 3 "Mitre" 6 "Cherry"(integer) 2127.0.0.1:6342&gt; ZADD billboard 1 "Owen"(integer) 1127.0.0.1:6342&gt; ZRANGEBYSCORE billboard 0 101) "Owen"2) "Mitre"3) "Cherry"]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ 安装和内置命令]]></title>
    <url>%2F2019%2F09%2F17%2FRabbitMQ-%E5%AE%89%E8%A3%85%E5%92%8C%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. RabbitMQ 背景虽然在同步消息通讯的世界里有很多公开标准 (如 COBAR的 IIOP , 或者是 SOAP 等) .但是在异步消息处理中却不是这样, 只有大企业有一些商业实现 (如微软的 MSMQ , IBM 的 Websphere MQ 等), 在 2006 年的 6 月, Cisco 、Redhat、iMatix 等联合制定了 AMQP (Advanced Message Queue, 高级消息队列协议). RabbitMQ 是一个 用 erlang 语言 编写的 AMQP 的 开源实现 . RabbitMQ 是由 RabbitMQ Technologies Ltd 开发并且提供商业支持.该公司在 2010年4月 被 SpringSource ( VMWare的一个部门 ) 收购.在2013年5月被并入 Pivotal (Spring 框架就是 Pivotal 开发的).其实 VMWare , Pivotal 和 EMC 本质上是一家的. 2. 下载并安装 RabbitMQ目前, RabbitMQ 最新的发布版本是 3.7.17 . 有关发行说明, 参见 changelog .安装方法参见这个 页面 . 不管是 Linux, BSD, UNIX, 还是 Windows, 还是 MacOS 都有对应的 安装指南.最简单的安装方式 是用 PackageCloud Yum Repository 安装.安装步骤如下: 123456789curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bashyum -y install erlangcurl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bashyum -y install rabbitmq-server# 查看 安装包信息yum info erlangyum info rabbitmq-server# 启动 rabbitmqsystemctl start rabbitmq-server 如果 安装主机无法上网, 那么就要采用离线安装了. 简单说明一下, 如何 在 RedHat 6.7 上离线安装 RabbitMQ (工作环境的原因, 我就是这么安装的):1, 下载 erlang-22.0.7-1.el6.x86_64.rpm.2, 下载 socat-1.7.2.3-1.el6.x86_64.rpm), el 表示Red Hat Enterprise Linux, EL6 表示 企业版 Linux 6.x.3, 下载rabbitmq-server-3.7.17-1.el6.noarch.rpm.4, 用 root 用户 执行如下命令:123sudo rpm -ivh erlang-22.0.7-1.el6.x86_64.rpmsudo rpm -ivh socat-1.7.2.3-1.el6.x86_64.rpmsudo rpm -ivh rabbitmq-server-3.7.17-1.el6.noarch.rpm 5, 启动 RabbitMQ:1service rabbitmq-server start 3. RabbitMQ 基本概念Broker: 简单来说就是消息队列服务器实体(代理). Exchange: 消息交换机，它指定消息按什么规则，路由到哪个队列. Queue: 消息队列载体，每个消息都会被投入到一个或多个队列. Binding: 绑定，它的作用就是把exchange和queue按照路由规则绑定起来. Routing Key: 路由关键字，exchange根据这个关键字进行消息投递. vhost: 虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离. channel: 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务. producer: 消息生产者，就是投递消息的程序. consumer: 消息消费者，就是接受消息的程序. 4. RabbitMQ 常用命令4.1 服务启动与关闭123456# 启动service rabbitmq-server start# 关闭service rabbitmq-server stop# 重启service rabbitmq-server restart 4.2 RabbitMQ 提供的 命令行工具RabbitMQ comes with multiple Command Line Tools, Different tools cover different usage scenarios : rabbitmqctl for service management and general operator tasks.rabbitmq-diagnostics for diagnostics and health checking.rabbitmq-plugins for plugin management.rabbitmqadmin for operator tasks over HTTP API. 以上 4 个 命令行工具 都可以用 help 参数 查看使用方法, 例如:1234567# 查看 rabbitmqctl 帮助rabbitmqctl help# 查看 rabbitmqctl 添加用户帮助rabbitmqctl help add_user# 查看 rabbitmq-plugins 帮助rabbitmq-plugins help 静下心来把 帮助文档 读一遍, 同时把 官网说明 读一遍, 基本上所有命令就都能理解了. 简单看下 rabbitmqctl 和 rabbitmq-plugins 命令行工具 提供的的常用命令 . rabbitmqctl 是 RabbitMQ 附带的原生的 CLI 工具(CLI tool). rabbitmqctl 主要提供一些 管理操作: Stopping node Access to node status, effective configuration, health checks Virtual host management User and permission management Policy management Listing queues, connections, channels, exchanges, consumers Cluster membership management 123456789101112# 用户列表rabbitmqctl list_users# 新增rabbitmqctl add_user mitre mitre# 删除rabbitmqctl delete_user mitre# 设置角色rabbitmqctl set_user_tags mitre administrator# 设置用户权限 和 vhost# rabbitmqctl set_permissions [--vhost &lt;vhost&gt;] &lt;username&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;rabbitmqctl set_permissions --vhost / mitre . . . rabbitmq-plugins is a tool that manages plugins: lists, enables and disables them. 1234# 列出所有 插件rabbitmq-plugins list# 启用 web 页面管理插件rabbitmq-plugins enable rabbitmq_management References1 Downloading and Installing RabbitMQ2 Centos7 离线安装RabbitMQ,并配置集群3 RabbitMQ基础知识]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[道阻且长]]></title>
    <url>%2F2019%2F07%2F03%2F%E9%81%93%E9%98%BB%E4%B8%94%E9%95%BF%2F</url>
    <content type="text"><![CDATA[燥热的夏天2018 年 7 月 2 号, 只身一人来到江阴(江阴农商行), 带着迷茫和不安, 第一份工作, 我不知道自己能干什么.一周的时间 掌握了 增删改查 前后端代码(当然, 这依赖于框架的便利).又用一周的时间掌握了 客户端 与 服务端接口的开发(同样, 这依赖于框架和ESB的便利).接下来一直到9月底, 每天加班, 边学边工作, 和克乾两个人 完成了 “物联网动产贷” 项目的大半开发工作.9月底, 项目上线. 项目中用到的框架 是 宇信 产品部开发的 EMP 框架, 框架底层实现基于 SSM (SpringMVC+Spring+MyBatis) web框架. 整体架构:servlet 容器(开发在 Tomcat 中运行, 以 war 包方式 发布在 WebLogic 中运行).druid 连接池? 不记得用的是什么连接池了, 事务控制 是java原生的 java.sql.Connection 控制的.SSM框架, EMP封装后 开发基本上就是配置, 写一写 SQL 语句.Oracle 数据库.构建工具, 好像是 ant.版本控制工具, svn.freemarker 模板引擎, 用于生成 部分 java 类 和 xml 配置.IBM 的 AIX 服务器. 感触:江阴农商行非常棒, 领导 nice, 同事 nice, 测试 nice.web 后端技术方面, 比较落后, 还在使用 Java 5 (Java 最新版本是 Java SE 12). 在江阴农商行 待了 将近 7 个月, 首次接触到 web 框架, 读框架源码, 学习 servlet, Java 多线程 和 反射, Oracle, WebLogic 等等, 这 7 个月加了很多班, 也学到了很多. 贫瘠的春天2019 年 2 月 13 号, 年后上班的第二天, 我被调到了常州(江南农商行).我们部门最大的项目组 在 江南农商行 , 基本上整个部门里能力最强的 项目经理 都在这里了. “信贷集中作业平台” , 这是我做的第二个 web 项目.这个项目一期的工作就是 集中管理 30 多个 业务系统, 工作内容和江阴完全一样, 而且996 工作制. 干了两个月, 一期项目上线了, 我也提离职了, 原因是 “工作中所用的 web 技术太过陈旧”. 感触:只有把时间用在对的地方, 才能创造出美丽的东西.我在江南一直为项目尽心尽力, 其间, 因为加班发了一次烧, 一个人在医院吊水到半夜…人生中最苦逼 的两个月, 已经没有不走的理由了. 4月2019 年 4 月 17 号 下午, 我来到了上海, 直接到 兴业银行 的项目组报到(之前没有辞职成功, 被调到了上海). 这次的项目 是一个 微服务架构 的 “资产托管系统”. 辛总(项目经理) 直接问了我一下技术问题, 包括 Spring Cloud, dubbo, 分布式, 微服务等, 对这一类技术我了解一点, 仅此而已. 于是, 每天 6 点下班后, 回到住所学习(主要是看视频), 学到 夜里1点多, 早上 8:50 起床, 9:30 之前到公司.坚持一个多月以后, 我才把工作中遇到的技术上的问题全部被攻克. 然后, 辛总让我一个人 用 Spring Batch 重构 数据读取模块(从 flat 文件, dbf, xml, excel, log 文件中读取数据,加工处理, 插入数据库表. 同时支持配置化读取, 多文件混合读取), 项目组中没有一个人会用 Spring Batch.我边自学边开发(辛总在 job 内的 step 分区方面给了我很大帮助), 大约用了一个月的时间, 重构开发工作完成. 架构:Spring boot: starter 依赖的支持 减少了太多的配置.Spring Cloud : 注册中心, 网关, uaa(User Account and Authentication).SpringMVC.ORM 框架 MyBatis.Oracle 数据库.构建工具 Maven.版本控制工具 svn.缓存 Redis.Spring Batch 和 RabbitMQ.Nginx.前端: 基于 vue 的 YuFp 前端框架(公司产品部开发). 感触:2019 年 7 月 3 号, 工作已经一年了, 时间过得太快了.道阻且长, 必须要目标明确.]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 定时备份数据库-oracle]]></title>
    <url>%2F2019%2F06%2F27%2FCentOS7-%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93-oracle%2F</url>
    <content type="text"><![CDATA[1 命令行 导入/导出 数据库表导入/导出 oracle 数据库的表里的数据, 需要用到 oracle 数据库的两个命令: imp 和 exp.安装过数据库的机器, 就会有这两个命令. 1.1 exp 导出数据exp 导出 faext用户下的 所有的表(包括表结构和数据), 存储过程, 视图等:1exp faext/password@47.96.111.222:1521/S460 file=/home/oracle/Documents/test.dmp owner=faext 导出参数解释 :exp 用户名/密码@数据库ip:端口/SID file=导出文件名称 owner=数据用户名 仅仅导出某几张表 :1exp faext/password@47.96.111.222:1521/S460 file=/home/oracle/Documents/test.dmp tables=tableName1, tableName2 exp 命令 有许多参数可以选择, 参考 :1exp help=y 1.2 imp 导入数据把 20190627.dmp 文件中的数据 全部(full=y)导入 指定数据库中:1imp system/oracle@localhost:1521/S460 file=/home/oracle/Documents/20190627.dmp full=y 把 20190627.dmp 文件中的 指定表 tableName1 的数据 导入指定数据库中:1imp system/oracle@localhost:1521/S460 file=/home/oracle/Documents/20190627.dmp tables=tableName1 imp 命令 有许多参数可以选择, 参考:1imp help=y 2 Linux 定时任务CentOS 定时任务 是 通过 cron(crond) 系统服务 来控制的. 这个系统服务是默认是 开机启动的.查看 cron(crond) 系统服务 :1service crond status 2.1 定时任务示例配置 crontab 实现 定时执行 指定的脚本:12345678# 打开配置文件: crontab -e#把 以下内容 复制到 配置文件中SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=oracle*/1 * * * * date &gt; /home/oracle/Documents/1.txt 这样就完成了一个简单的 定时任务:每分钟执行一次 date 命令, 把执行结果 写入1.txt 文件. 查看定时任务配置:1crontab -l 查看定时任务 执行 日志:1sudo tail -f /var/log/cron 回看一下 定时任务的 配置文件:123456789# SHELL环境变量SHELL=/bin/bash# PATH环境变量PATH=/sbin:/bin:/usr/sbin:/usr/bin#邮件发送给指定的用户MAILTO=oracle# 每分钟执行一次*/1 * * * * date &gt; /home/oracle/Documents/1.txt crontab 配置中 有一个坑:所有的 用户的环境变量 都会失效 !系统自带的环境变量会失效, 自己配置的环境变量也会失效. 从上面的内容可以看到 配置了 PATH 环境变量, 这样我们才能 各个 bin 中的命令. crontab 文件定时代码格式:1minute hour day month week command minute: 表示分钟，可以是从0到59之间的任何整数。hour: 表示小时，可以是从0到23之间的任何整数。day: 表示日期，可以是从1到31之间的任何整数。month: 表示月份，可以是从1到12之间的任何整数。week: 表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。command: 要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。 星号 (*)：代表所有可能的值，例如: month字段是星号 表示 (在满足其它字段的制约条件后) 每月都执行该任务.逗号 (,)：用逗号隔开的值指定一个列表范围，例如: hour段 “1,4,17” 表示 1点4点17点执行该任务.正斜线 (/)：正斜线指定时间的间隔频率，例如: minute段 “*/2” 表示每(间隔)两分钟执行一次. 2.2 定时备份数据库表shell 脚本如下, (每天)备份 faext 用户的所有数据, 只保留 10天 之内的备份文件:123456789101112131415161718#!/bin/bash. /etc/profile# set environment variable. /home/oracle/.bash_profilebakPath='/home/oracle/Documents/faextDBBak';#currentDate=`date +%Y%m%d`;# remove data 10 days agofind $&#123;bakPath&#125; -mtime +10 -name "*.dmp" -exec rm -rf &#123;&#125; \;# back up remote database tables/u01/app/oracle/product/12.2.0.1/db_1/bin/exp faext/passwd@47.96.111.222:1521/S460 file=$&#123;bakPath&#125;/$&#123;currentDate&#125;.dmp owner=faext &amp;&gt; /dev/null;# chmodchmod 755 $&#123;bakPath&#125;/$&#123;currentDate&#125;.dmp; crontab 文件(crontab -e)配置 如下, 每天 19:00 执行定时任务:123456789101112131415SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=oracle# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed0 19 * * * sh /home/oracle/Documents/faextDBBak/DBBak.sh 注意:一: crontab 默认是没有 环境变量的, 一定要自己配置, 否则定时任务不会成功执行.二: /etc/crontab 是 root 级的定时任务配置文件, 普通用户 用crontab -e 配置.]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-2 装饰者模式]]></title>
    <url>%2F2019%2F05%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式-1 策略模式]]></title>
    <url>%2F2019%2F05%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1 策略模式简介先看一下 策略模式 的定义:策略模式 定义了一个 算法/策略族, 把族内各个 算法/策略 分别封装起来, 让他们之间可以 相互替换 .此模式让 算法的变化 独立于 算法的调用者. 可以简单的理解为: 封装策略族. 策略模式 包含了 三种 OO设计原则 :1, 封装变化.2, 针对接口编程, 不针对实现编程.3, 多用组合(composition) , 少用继承(inheritance). 先看一个 UML 图, 它是介绍 策略模式 的一个简单例子. 例子虽简单, 但足以让读者理解 策略模式.例子来源于 “HeadFirst 设计模式” 这本书. 2 慢慢走近策略模式设计一个模拟鸭子的应用:1, 鸭子的种类有多种.如, 红头鸭, 绿头鸭, 橡皮鸭, 北京烤鸭等.2, 每种鸭子的外部特征(display) 都不一样 .如, 红头鸭 头是红色的, 绿头鸭 头是绿色的, 橡皮鸭 是黄色的玩具鸭…3, 每种鸭子的飞行(fly)行为, 鸣叫(quack)行为 可能一样, 也可能不一样.如, 红头鸭 和 绿头鸭 一次能飞 几百米远, 橡皮鸭 和 北京烤鸭 不会飞. 红头鸭 呱呱叫, 绿头鸭 嘎嘎叫, 橡皮鸭和北京烤鸭不会叫. 2.1 用继承 来完成鸭子应用设计一个 抽象的 鸭子超类(superclass) : 12345678910public abstract Duck&#123; //每种鸭子的外部特征 都不一样 public abstract void display(); public void fly() &#123; System.out.print("能飞很远"); &#125; public void quack() &#123; System.out.print("呱呱叫"); &#125;&#125; 红头鸭 , 绿头鸭, 橡皮鸭 分别 继承 Duck 类:12345public class RedheadDuck extends Duck &#123; public void display()&#123; System.out.print("头是红色的鸭子"); &#125;&#125; 12345678public class GreenheadDuck extends Duck &#123; public void display()&#123; System.out.print("头是绿色的鸭子"); &#125; public void quack()&#123; System.out.print("嘎嘎叫"); &#125;&#125; 1234567891011public class RubberDuck extends Duck &#123; public void display()&#123; System.out.print("黄色的橡皮玩具鸭"); &#125; public void fly() &#123; System.out.print("不会飞"); &#125; public void quack()&#123; System.out.print("不会叫"); &#125;&#125; 三种鸭子(红头鸭 , 绿头鸭, 橡皮鸭 ) 都 实现(重写) 了 Duck 类 的 display 方法. 同时, 每种鸭子按照自身特性决定要不要 重写 fly 方法 和 quack 方法. 利用 继承 带来的 缺点:1, 代码在多个子类中 重复.2, 很难知道鸭子的全部行为. 比如, 以后要在 Duck 中加一个 游泳/潜水方法 swim(), 每个子类都要加, 如果有几十种鸭子, 就比较糟糕了.3, 运行时的行为不能改变. 这种 只利用 继承 完成的 鸭子应用 并不可取.下面 看一下 用 接口 来 完成 鸭子应用. 2.2 利用接口 完成鸭子应用设计一个 抽象的 鸭子超类(superclass) :1234public abstract Duck&#123; //每种鸭子的外部特征 都不一样 public abstract void display();&#125; 设计 一个 飞行接口 Flyable:123public interface Flyable &#123; void fly();&#125; 设计 一个 鸣叫接口 Quackable:123public interface Quackable &#123; void quack();&#125; 有了 Duck类, Flyable接口, Quackable接口, 就可以让 所有的鸭子类都 继承 Duck 类, 实现 Flyable 和 Quackable 接口. 利用 接口 依然存在 缺点:1, 代码在多个子类中 重复.2, 很难知道鸭子的全部行为. 比如, 以后要加一个 游泳/潜水方法 swim(), 可以写一个 Swimable接口, 让所有鸭子实现, 鸭子类多的话 实现起来也比较糟糕.3, Flyable接口, Quackable接口 运行时可以改变. 但是从鸭子对象的角度来看, 运行时的行为 依然不能改变. 可以看出, 单纯地 用 接口 或 用 继承 来 完成 鸭子应用, 都是有很大缺陷的. 3 策略模式设计原则-封装变化:找出应用中 可能需要变化的部分, 把它们独立出来, 不要和那些不需要变化的代码混在一起. 封装变化 的设计原则, 可以这样理解:把 会变化的部分 取出并封装起来, 以便以后可以 改动或扩充此部分, 而不会影响其他不需要变化的部分. 封装变化 , 几乎是每个设计模式背后的 精神所在. 3.1 策略模式-封装变化的部分Duck 类 的 fly() 和 quack() 会随着鸭子的不同 而 不同.但是 有些鸭子的 fly() 或 quack() 是相同的. 如此这般, 我们可以 把鸭子变化的 行为封装起来. 为什么 封装 fly 和 quack, 却不封装 display() ?这里只是为了说明 策略模式 的思想, 如果愿意的话 也可以 封装 display, 毕竟 display 也是 变化的部分.设计模式 是一些构造 面向对象编程的 经验的总结, 利用设计模式 可以 设计出 弹性的,可复用的,易维护的 的系统.如果没有 设计模式 可用, 可以参照 OO设计原则 进行设计. 要注意, 我们利用 设计模式 的目的是 设计出 弹性的,可复用的,易维护的 的系统.如果能达到此目的, 不一定非要 “一毫不差” 地 套用 设计模式.事实上, 工作中的设计 通常会涉及到 多种设计模式混合使用. 设计原则-针对接口编程:针对 接口 编程, 而不是针对 实现 编程. 设计 两个 接口 FlyBehavior 和 QuackBehavior.FlyBehavior 用于 指定鸭子的 飞行行为:123public interface FlyBehavior &#123; void fly();&#125; QuackBehavior 用于 指定鸭子的 鸣叫行为:123public interface QuackBehavior &#123; void quack();&#125; 现在, 不让 Duck 实现 FlyBehavior 和 QuackBehavior, 而是 用 指定的 实现类 实现这两个接口. 这样就可以 复用 实现类的实现. FlyBehavior 和 QuackBehavior 的实现类如下(把它们都写在一起为了方便阅读) :123456789101112131415161718192021public class FlyLongDistance implements FlyBehavior &#123; public void fly() &#123; System.out.println("一次 能飞50米~~~~~"); &#125;&#125;public class FlyNoWay implements FlyBehavior &#123; public void fly() &#123; System.out.println("不会飞~"); &#125;&#125;public class QuackGaGa implements QuackBehavior &#123; public void quack() &#123; System.out.println("嘎.嘎..嘎嘎嘎嘎...."); &#125;&#125;public class QuackMute implements QuackBehavior &#123; public void quack() &#123; System.out.println("不会叫."); &#125;&#125; 3.2 策略模式-把变化的实现 组合起来设计原则- 多用组合, 少用继承:“有一个”(组合) 可能比 “是一个”(继承) 更好. 每一种鸭子 都有 一个 FlyBehavior 和一个 QuackBehavior . 这样好将鸭子的 飞行行为 和 鸣叫行为 交给 FlyBehavior 和 QuackBehavior 处理.而 Duck 要做的就是 把 这些 行为对象 组合 起来. 123456789101112131415161718192021public abstract class Duck &#123; private FlyBehavior flyBehavior; private QuackBehavior quackBehavior; // 鸭子的样子 public abstract void display(); // 鸭子飞 public void fly() &#123; flyBehavior.fly(); &#125; // 鸭子叫 public void quack() &#123; quackBehavior.quack(); &#125; // setter public void setFlyBehavior(FlyBehavior flyBehavior) &#123; this.flyBehavior = flyBehavior; &#125; public void setQuackBehavior(QuackBehavior quackBehavior) &#123; this.quackBehavior = quackBehavior; &#125;&#125; 用 策略模式 编写的 鸭子应用 已经完成了, 再看一遍 开篇的 UML 图: 3.3 测试12345678910111213141516171819202122public static void main(String[] args) &#123; FlyBehavior flyLong = new FlyLongDistance(); FlyBehavior flyNoWay = new FlyNoWay(); QuackBehavior quackGaGa = new QuackGaGa(); QuackBehavior quackMute = new QuackMute(); Duck redheadDuck = new RedheadDuck(flyLong, quackGaGa); Duck rubberDuck = new RubberDuck(flyNoWay, quackMute); System.out.println("红头鸭出场: "); redheadDuck.display(); redheadDuck.fly(); redheadDuck.quack(); System.out.println("\n橡皮鸭出场: "); rubberDuck.display(); rubberDuck.fly(); rubberDuck.quack(); System.out.println("-----给橡皮鸭装一个喇叭------"); rubberDuck.setQuackBehavior(quackGaGa); rubberDuck.quack();&#125; 结果:1234567891011红头鸭出场:红头鸭: 头是红色一次 能飞50米~~~~~嘎.嘎..嘎嘎嘎嘎....橡皮鸭出场:黄色的橡皮鸭不会飞~不会叫.-----给橡皮鸭装一个喇叭------嘎.嘎..嘎嘎嘎嘎.... 4 策略模式应用在 jdk 中的应用:Comparator 接口是一个 比较器, 用于指定 比较规则.工具类 Arrays 提供了一个 自然顺序比较器 NaturalOrder(实现了 Comparator 接口), Arrays 的 sort() 方法 利用 NaturalOrder 实现大小排序.Arrays 的众多 sort() 重载方法中, 有 需要传入 Comparator 参数的 sort() 方法:1public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) 这样我们可以根据 需要, 选用不同的 比较器. 可以看出:Comparator 就是 策略族接口, NaturalOrder 是 Comparator 的 具体实现 (用户可以自行实现更多的 Comparator), Array 的 sort() 方法 根据传入的不同的 Comparator 来在 运行时 改变排序规则. 策略模式的 现实应用场景:不同 会员等级 的打折, 大众会员不打折, 黄金会员打9折, 白金会员打8折… 参考1 深入解析策略模式2 HeadFirst 设计模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三范式]]></title>
    <url>%2F2019%2F05%2F16%2F%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[关系数据库中的关系必须满足一定的要求。数据库的 范式 是数据库设计所需要满足的规范。只有理解数据库的范式，才能设计出高效率、优雅的数据库，否则可能会设计出错误的数据库. 主要有六种范式：第一范式.第二范式.第三范式.BC范式.第四范式.第五范式.满足最低要求的叫第一范式，简称 1NF . 在第一范式基础上进一步满足一些要求的为第二范式，简称 2NF . 其余依此类推. 范式越高:优点: 可以避免数据冗余.缺点: 性能就会越差, 需要联系多个表才能得到所需要数据, 并且操作会 更困难. 权衡利弊, 一般项目会使用 第三范式.数据冗余小, 且 方便管理. 第一范式(1NF)1NF是关系模式应具备的 最起码的条件，如果数据库设计不能满足第一范式，就不称为关系型数据库. 定义：如果 关系模式R 的每个 关系r 的属性都是不可分的数据项，那么就称R是第一范式的模式.例如 (学生信息表)： 学生编号 姓名 性别 联系方式 20080901 张三 男 email:zs@126.com,phone:88886666 20080902 李四 女 email:ls@126.com,phone:66668888 以上的表就不符合，第一范式：联系方式字段可以再分.满足 第一范式(1NF) 的表结构应该如下: 学生编号 姓名 性别 电子邮件 电话 20080901 张三 男 zs@126.com 88886666 20080902 李四 女 ls@126.com 66668888 第二范式（2NF）定义：如果 关系模式R 是 1NF，且每个 非主属性 完全函数依赖于 候选键，那么就称R是第二范式. 例如 (产品流水凭证模板表), 产品代码 和 交易类型 是联合 主键: 产品代码 交易类型 产品名称 凭证模板代码 差额凭证模板代码 p1 666 产品A t1 tt1 p2 777 产品B t2 tt1 p1 888 产品A t1 tt1 通过 产品代码 和 交易类型 可以确定 凭证模板代码, 差额凭证模板代码, 产品名称, 所以 可以把 (产品代码, 交易类型) 作为主键.但是, 产品名称 并不完全 依赖于 (产品代码, 交易类型), 只要 产品代码 就能确定 产品名称, 这种依赖叫 不完全依赖 (或部分依赖). 第二范式 不能有 不完全依赖 . 修改后, 满足第二范式: 产品代码 交易类型 凭证模板代码 差额凭证模板代码 p1 666 t1 tt1 p2 777 t2 tt1 p1 888 t1 tt1 产品代码 产品名称 p1 产品A p2 产品B 第三范式（3NF）定义: 首先要满足第二范式，其次 非主属性 之间不存在函数依赖. 由于满足了第二范式，表示每个 非主属性 都函数依赖于 主键。如果 非主属性 之间存在了 函数依赖，就会存在 传递依赖，这样就不满足第三范式。 例如 (产品流水凭证模板表), 产品代码 和 交易类型 是联合 主键: 产品代码 交易类型 凭证模板代码 差额凭证模板代码 差额凭证模板名称 p1 66 t1 tt1 差额A p2 777 t2 tt1 差额A p1 888 t1 tt1 差额A 差额凭证模板代码 依赖于 主键 (产品代码, 交易类型), 差额凭证模板名称 依赖于 差额凭证模板 代码, 这就存在 传递依赖, 不满足第三范式. 修改 使其满足 第三范式 : 产品代码 交易类型 凭证模板代码 差额凭证模板代码 p1 66 t1 tt1 p2 777 t2 tt1 p1 888 t1 tt1 差额凭证模板代码 差额凭证模板名称 tt1 差额A 参考1: 数据库设计的三大范式]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 动态代理]]></title>
    <url>%2F2019%2F04%2F09%2Fjava-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近看 《HeadFirst 设计模式》 看到 代理模式 ，包括 远程代理，保护代理，虚拟代理 等。其中 保护代理 是使用 Java API的 动态代理 实现的。 此外， Spring AOP 底层也是 动态代理 实现的。于是，借此机会学习一下 Java动态代理。 1 动态代理Java 在 java.lang.reflect 包中有自己的代理支持，利用这个包 可以实现在运行时 动态地创建 一个代理类，实现一个或多个接口，并将方法转发(dispatch)到指定的类。因为实际的代理类是 运行时创建 的， 于是称此技术为：动态代理。 Java 动态代理 类图： 2 Java 动态代理 APIJava 动态代理 API 提供了一个 接口 InvocationHandler 和 一个 类 Proxy 。正是 InvocationHandler 和 Proxy 让我们可以用简单的代码实现 动态代理 。 2.1 InvocationHandler 接口InvocationHandler is the interface implemented by the invocation handler of a proxy instance.Each proxy instance has an associated invocation handler.When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.InvocationHandler 是由 代理对象 的 调用处理器 实现的。每一个 代理对象 都有一个对应的 调用处理器。当一个 代理实例 的方法被调用时， 这个方法调用 会委派调用 调用处理器 的方法。 InvocationHandler 接口 只有一个方法：Object invoke(Object proxy, Method method, Object[] args)Processes a method invocation on a proxy instance and returns the result.动态代理 最重要的就是 要实现 invoke 方法，代理对象 利用 invoke 完成对 被代理对象 中的方法的调用。 2.2 Proxy 类Proxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods.Proxy 提供了 创建动态代理类 和 实例 的 静态方法。Proxy 同时是 所有 动态代理类(由其静态方法创建) 的超类。 Proxy 有一个成员变量，一个构造方法，和四个 静态成员方法：123456789// 成员变量protected InvocationHandler h;// 构造方法protected Proxy(InvocationHandler h);// 静态成员方法public static InvocationHandler getInvocationHandler(Object proxy);public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces);public static boolean isProxyClass(Class&lt;?&gt; cl);public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h); 创建 动态代理对象时 用 newProxyInstance 方法，Java API 对此方法介绍如下：Returns an instance of a proxy class for the specified interfaces that dispatches method invocations to the specified invocation handler.返回指定接口的代理对象，此代理对象 能够把 对代理对象的方法调用 委派让 调用处理器 执行。简而言之，客户调用 代理对象的方法， 代理对象会调用 InvocationHandler 的 invoke 方法， 然后 invoke 方法 调用 被代理对象的对应方法。这样在客户看来，调用代理对象 就像 调用原对象(被代理对象) 一样。 newProxyInstance 方法的三个参数：loader : 一个ClassLoader对象，由此ClassLoader对象来对生成的代理对象进行加载。interfaces : 一个Interface对象的数组，值是被代理对象实现的接口。代理对象会宣称实现了这些接口，这样就能 用代理对象 调用这组接口中的方法了。h : 一个InvocationHandler对象，当动态代理对象在调用方法的时候，会调用此 InvocationHandler 对象 的 invoke 方法。 3 动态代理示例再看一遍 Java动态代理 的类图：Java API 已经提供了 Proxy 类 和 InvocationHandler 接口 ， 因此，只要写一个 Subject 接口， 一个 Subject 的实现类，和 一个 InvocationHandler 的实现类 就行了。 下面是示例的具体代码。 Subject 接口 :1234public interface Subject &#123; String location(); void printLocation(String s);&#125; Subject 的实现类 :123456789101112public class RealSubject implements Subject&#123; @Override public String location() &#123; return "江苏省常州市金坛区江南农商银行"; &#125; @Override public void printLocation(String s) &#123; System.out.println(s+"江南"); &#125;&#125; InvocationHandler 的实现类 :1234567891011121314public class ConcreteInvocationHandler implements InvocationHandler &#123; private Subject subject; public ConcreteInvocationHandler(Subject subject) &#123; this.subject=subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("invoke 方法被调用"); Object o=method.invoke(subject, args); return o; &#125;&#125; 注意对比看类图，InvocationHandler 是实现动态代理的关键！ InvocationHandler 的实现类 有一个 (has-A) RealSubject 被代理对象，invoke 方法 正是调用 此对象的 方法 实现动态代理的。 测试代码：12345678910111213public class DynamicProxyDrive &#123; public static void main(String[] args) throws IllegalArgumentException, ClassNotFoundException &#123; // 原对象(被代理对象) Subject subject = new RealSubject(); InvocationHandler ih = new ConcreteInvocationHandler(subject); // 代理对象 Subject proxySubject = (Subject) Proxy.newProxyInstance(Class.forName("cn.mitre.subject.RealSubject").getClassLoader(), Class.forName("cn.mitre.subject.RealSubject").getInterfaces(), ih); // 代理对象 代理了 原对象，于是可以把 代理对象 当成原对象使用 proxySubject.printLocation("四月"); System.out.println(proxySubject.location()); &#125;&#125; 输出结果：1234invoke 方法被调用四月江南invoke 方法被调用江苏省常州市金坛区江南农商银行 参考1、 HeadFirst 设计模式2、 java的动态代理机制详解]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建工具Maven笔记一: HelloWorld]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7Maven%E7%AC%94%E8%AE%B0%E4%B8%80-HelloWorld%2F</url>
    <content type="text"><![CDATA[1 构建工具构建 ( build ) 是把项目源代码变成项目产品的过程。其中包含编译，测试，打包，部署等工作。 常见的构建工具：Make 是最早的构建工具，Stuart Feldman 于 1977 年在 Bell实验室 创建。 Make 由 Makefile 脚本文件驱动。常用于C++ 项目。 Apache Ant (Another Neat Tool 另一个简洁的工具), Ant 像是Java版本的 Make。 Ant 由 build.xml 构建配置文件驱动。它最早用来构建 Tomcat， 现在已经逐渐被 Maven 和 Gradle 取代了。 Apache Maven 是在 Ant 之后流行的构建工具。Maven 项目的核心是 pom.xml 文件。POM (Project Object Model 项目对象模型) 定义了项目的基本信息。 Gradle 是一个基于Apache Ant和Apache Maven概念的项目自动化构建工具。Gradle 使用基于 Groovy 的特定领域语言(DSL)来声明项目设置，抛弃了基于XML的各种繁琐配置。 2 Window10 安装 MavenApache Maven 下载地址, 点击下载 apache-maven-3.6.0-bin.tar.gz 即可。下载完成后：1、 解压2、 配置环境变量 M2_HOME 指向 解压的 Maven 目录3、 配置环境变量 Path， 添加一项 %M2_HOME%\bin4、 win+R , cmd 打开终端 输入 echo %M2_HOME% , 检查环境变量是否配置好5、 终端输入， mvn -v 查看 Maven 版本。显示版本即可。 3 Maven项目入门程序3.1 编写 pom.xml 文件创建一个文件夹/项目目录 hello-world , 在此文件夹下 创建 pom.xml 文件。pom.xml 文件内容如下：12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.mitre&lt;/groupId&gt; &lt;artifactId&gt;hello-world&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;Maven Hello World Project&lt;/name&gt;&lt;/project&gt; &lt;project&gt; 是 所有 pom.xml 的根元素。modelVersion 指定了当前 POM模型 的版本，对于 Maven3 来说，只能是4.0.0。groupId 定义了项目属于哪个组。 groupId一般是 公司域名倒写.(点)项目名，例如，com.bilibili.myapp。artifactId 定义了当前 Maven项目在 组中唯一的构件id。version 指定了Maven项目当前的版本。name 元素 声明了项目名称，name元素不是必须的，为了方便查看常声明name元素。 groupId, artifactId, version, 这 3 个元素定义了一个项目的基本坐标。在Maven项目中，任何jar、 pom、 war都是基于这 3 个元素区分的。 3.2 编写主代码在 hello-world 文件夹下(与pom.xml同级目录)，创建文件src/main/java/cn/mitre/helloworld/HelloWorld.java 。HelloWorld.java 代码如下：1234567891011package cn.mitre.helloworld;public class HelloWorld&#123; public String sayHello()&#123; return "Hello Maven"; &#125; public static void main(String[] args)&#123; System.out.println(new HelloWorld().sayHello()); &#125;&#125; 注意：java 代码放在 src/main/java/ 目录下 是为了遵循 Maven 的约定，这样无需额外的配置。 打开终端，进入到 项目目录(hello-world)下，执行以下命令进行 编译：1mvn clean compile clean 会清除输出目录 target。compile 会编译项目主代码。 3.3 编写测试代码Maven 项目默认的测试代码 目录是 src/test/java 。和编写主代码一个道理，创建文件src/test/java/cn/mitre/helloworld/HelloWorldTest.java编写测试代码之前，需要在 pom.xml 中配置 单元测试 JUnit 依赖：12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.mitre&lt;/groupId&gt; &lt;artifactId&gt;hello-world&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;Maven Hello World Project&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.7&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; Maven 会根据 groupId, artifactId, version 定位并下载 junit-4.7.jar 。scope 指定了依赖范围，test 表示只对测试代码有效， compile 表示对主代码和测试代码都有效。 有了测试依赖，就可以编写测试代码了：12345678910111213package cn.mitre.helloworld;import static org.junit.Assert.assertEquals;import org.junit.Test;public class HelloWorldTest&#123; @Test public void testSayHello()&#123; HelloWorld helloWorld = new HelloWorld(); String result=helloWorld.sayHello(); assertEquals("Hello Maven", result); //测试 result 是否等于 "Hello Maven" &#125;&#125; JUnit4 要求所有的测试方法以 test 开头， 同时加上 @Test 注解。 测试代码写完后， 打开终端，执行以下命令完成 测试：1mvn clean test Maven 在执行 测试 之前，会自动 编译 主代码和测试代码。 3.4 打包和运行终端执行以下命令 进行 打包：1mvn clean package Maven 在执行 打包 之前， 会自动 编译 和 测试 。打包 命令执行成功后，会在输出目录 target 下 生成一个 名称为 artifact-version.jar 的包。 如果想让其他 Maven 项目直接引用这个 jar 包，还需要执行 安装 命令：1mvn clean install Maven 在执行 安装 之前， 会自动 打包。install 命令执行成功后，可以在本地仓库对应的目录(C:\Users\cx141.m2\repository\cn\mitre\hello-world\1.0-SNAPSHOT)看到 pom 和 jar 文件。 3.5 生成可执行的 jar 文件(可选)在上面的 HelloWorld 类里 有一个 main 方法，默认 打包 生成的 jar 是不可以执行的。为了生成可执行的 jar 包， 需要借助 maven-shade-plugin 插件， 在 pom.xml 文件中 配置该插件：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.mitre&lt;/groupId&gt; &lt;artifactId&gt;hello-world&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;Maven Hello World Project&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.7&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"&gt; &lt;mainClass&gt;cn.mitre.helloworld.HelloWorld&lt;/mainClass&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 配置 mainClass 元素为 cn.mitre.helloworld.HelloWorld ，项目在 打包 时，会把该信息放在 MANIFEST 中。有了 main 方法信息，再执行 mvn clean install 就会在 target 目录下生成两个 jar ， 分别是 hello-world-1.0-SNAPSHOT.jar 和 original-hello-world-1.0-SNAPSHOT.jar 。前者是带 mainClass 信息可运行的 jar， 后者是原生的 jar。打开终端，进入到项目目录，执行 hello-world-1.0-SNAPSHOT.jar ：1java -jar target\hello-world-1.0-SNAPSHOT.jar 执行结果如下：1Hello Maven 参考1、 Maven 实战【许晓斌】]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射机制]]></title>
    <url>%2F2019%2F02%2F13%2FJava-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1 反射概述在程序运行时，对于任意一个类，都能获得这个类的所有的属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性(包括私有的方法和属性)。这种 动态获取的类信息 以及 动态调用对象的方法 的功能 就称为java语言的反射机制。 要想对一个类进行反射，必须先获取该类的 字节码文件(.class)。反射是通过 Class类 中的方法实现的。每一个 类 对应着一个 字节码文件 也就对应着一个 Class类型对象，也就是字节码文件对象。 获取Class对象的三种方式:1、通过类名获取 类名.class2、通过对象获取 对象名.getClass()3、通过全类名获取 Class.forName(全类名) 123456789101112131415161718192021public static void main(String[] args) &#123; // 1-类名.class Class s1Class=Student.class; System.out.println(s1Class.getName()); // 2-对象名.getClass Student s2=new Student(); Class s2Class=s2.getClass(); System.out.println(s2Class.getName()); System.out.println(s1Class==s2Class); // 3-Class.forName try &#123; Class s3Class = Class.forName("domain.Student"); System.out.println(s3Class.getName()); System.out.println(s2Class==s3Class); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 运行结果：12345domain.Studentdomain.Studenttruedomain.Studenttrue 从上面程序结果可以看出，一个类Student 只有一个 类类型Class 对象，不论Class对象是如何创建的，不论Class对象创建多少次。 事实上, 通过 ClassLoader 也能 获取 Class对象:1Class&lt;?&gt; clazz = MitreTest.class.getClassLoader().loadClass(("cn.mitrecx.Hello")); 2 获取构造方法 并调用–newInstanceClass对象 获取 所有 public 构造函数： getConstructors() 获取 所有构造函数(声明的构造函数)： getDeclaredConstructors() 获取 指定的 public 构造函数：12public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) //getConstructor 的参数 要和 某个构造函数的参数一致，才能获取到对应的构造函数 获取 指定的 非public 构造函数：12public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)// 一样的道理，getDeclaredConstructor 的参数 要和 某个构造函数的参数一致 Constructor对象 通过调用 newInstance方法 创建对象。 示例：123456789101112131415161718192021222324252627public class ReflectDemo2 &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; clazz = Class.forName("domain.Student"); System.out.println("===获取所有public构造函数"); Constructor[] constructorArrayPub = clazz.getConstructors(); for (Constructor c : constructorArrayPub) &#123; System.out.println(c); &#125; System.out.println("\n===获取所有的构造方法(声明的构造函数)"); Constructor[] constructorArrayAll = clazz.getDeclaredConstructors(); for (Constructor c : constructorArrayAll) &#123; System.out.println(c); &#125; System.out.println("\n===获取指定的 public构造方法"); Constructor constructor1 = clazz.getConstructor(java.lang.String.class, int.class, char.class); Object obj = constructor1.newInstance("嘉宣", 24, 'M'); System.out.println(obj); System.out.println("\n===获取指定的 private构造方法"); Constructor constructor2 = clazz.getDeclaredConstructor(java.lang.String.class, int.class); constructor2.setAccessible(true);// private方法，调用之前必须设置为可见 Object obj2 = constructor2.newInstance("嘉文", 26); System.out.println(obj2); &#125;&#125; 执行结果：123456789101112131415===获取所有public构造函数public domain.Student(java.lang.String,int,char)public domain.Student()===获取所有的构造方法(声明的构造函数)public domain.Student(java.lang.String,int,char)private domain.Student(java.lang.String,int)protected domain.Student(java.lang.String)public domain.Student()===获取指定的 public构造方法姓名:嘉宣 年龄:24 性别:M===获取指定的 private构造方法姓名:嘉文 年龄:26 性别: 3 获取成员变量 并调用–setClass对象 获取 所有 public 成员变量： getFields() 获取 所有 成员变量： getDeclaredFields() 获取 指定变量名的 成员变量：1public Field getDeclaredField(String name) 例如：1234567891011Constructor c=clazz.getConstructor(String.class,int.class,char.class);Student student=(Student) c.newInstance("cherry",24,'F');System.out.println("\n===指定字段名的 private 字段");Field fieldName=clazz.getDeclaredField("name");System.out.println(fieldName);// 为字段赋值，因为是 private字段，所以要先设置为可访问的fieldName.setAccessible(true);// 直接给对象的 成员变量赋值fieldName.set(student,"xun");System.out.println(student); 结果：123===指定字段名的 private 字段private java.lang.String domain.Student.name姓名:xun 年龄:24 性别:F 获取 指定变量名的 public 成员变量：1public Field getField(String name) 4 获取成员方法并调用–invokeClass对象 获取 所有 public 成员方法(包括继承来的方法)： getMethods(String name) 获取 所有 成员方法(没有来继承的方法)： getDeclaredMethods(String name) 获取 指定的方法名和参数类型的 public 成员方法：12// name 是方法名，其他参数 指定 方法的变量类型public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 例子：123456Constructor constructor=clazz.getConstructor(String.class,int.class,char.class);Student student=(Student)constructor.newInstance("轩辕荣耀",21,'M');Method methodSetName=clazz.getMethod("setName", String.class);/* invoke 调用方法 */methodSetName.invoke(student, "永强");System.out.println(student); 结果：1姓名:永强 年龄:21 性别:M 获取 指定的方法名和参数类型的 成员方法：1public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) invoke private方法之前，必须 setAccessible(true)。 参考1、 Java中反射机制详解2、 Java基础之—反射]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java I/O 学习系列四: RandomAccessFile]]></title>
    <url>%2F2019%2F02%2F11%2FJava-I-O-%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9B%9B-RandomAccessFile%2F</url>
    <content type="text"><![CDATA[1 RandomAccessFile 简介1.1 API docs 对 RandomAccessFile 的描述12java.lang.Object |__java.io.RandomAccessFile Instances of this class support both reading and writing to a random access file.A random access file behaves like a large array of bytes stored in the file system.There is a kind of cursor, or index into the implied array, called the file pointer;input operations read bytes starting at the file pointer and advance the file pointer past the bytes read. If the random access file is created in read/write mode, then output operations are also available;output operations write bytes starting at the file pointer and advance the file pointer past the bytes written.Output operations that write past the current end of the implied array cause the array to be extended.The file pointer can be read by the getFilePointer method and set by the seek method. It is generally true of all the reading routines in this class that if end-of-file is reached before the desired number of bytes has been read, an EOFException (which is a kind of IOException) is thrown.If any byte cannot be read for any reason other than end-of-file, an IOException other than(除了) EOFException is thrown.In particular, an IOException may be thrown if the stream has been closed.RandomAccessFile类 在读取程序中，如果在读取完 所需的字节数 之前到达 文件结尾，将会抛出 EOFException 。除 读到文件结尾 之外的任何原因，导致不能读取到 字节，将会抛出 IOException。 1.2 RandomAccessFile 的作用RandomAccessFile 类 实现了 DataInput 和 DataOutput 接口，所以 RandomAccessFile类 既可以读也可以写。 RandomAccessFile 可以 访问文件 的任意位置，并且支持 读取和写入 操作。 1.3 构造函数12public RandomAccessFile(String name, String mode) throws FileNotFoundExceptionpublic RandomAccessFile(File file, String mode) throws FileNotFoundException mode 参数用于指定访问模式：“r” 只读“rw” 读写“rws” 读写，同时对文件的内容或 元数据(metadata) 的更新 同步写入底层存储设备“rwd” 读写，同时对文件的内容的更新 同步写入底层存储设备 2 RandomAccessFile 用法示例2.1 写入和读取文件writeUTF 方法 使用 modified UTF-8 encoding 以独立于机器的方式把字符串写入文件。 用 writeUTF 方法 把中文字符串写入文件中，直接打开文件看到的是 乱码。使用 指定的write 方法(如，writeUTF，writeInt，writeLong等) 写入，应该使用 对应的read 方法(如，readUTF，readInt，readLong等)读取。 例如：123456789101112131415161718192021222324252627282930public static void main(String[] args) &#123; //写入 write(); try &#123; RandomAccessFile raf=new RandomAccessFile("C:\\Users\\cx141\\Desktop\\credit\\1.txt", "rw"); String s=raf.readUTF(); String s2=raf.readUTF(); int s3=raf.readInt(); System.out.println(s+s2+s3); raf.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;public static void write() &#123; try &#123; RandomAccessFile raf = new RandomAccessFile("C:\\Users\\cx141\\Desktop\\credit\\1.txt", "rw"); raf.writeUTF("hello world."); raf.writeUTF("你好 "); raf.writeInt(123); raf.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 执行结果：1hello world.你好 123 2.2 在文件结尾插入123456789101112public static void main(String[] args) &#123; try &#123; RandomAccessFile raf = new RandomAccessFile("C:\\Users\\cx141\\Desktop\\credit\\2.txt", "rw"); raf.seek(raf.length()); raf.write("\r\n江阴农商银行".getBytes()); raf.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 程序执行后 文件2.txt 内容如下(不 乱码)：123中华人民共和国美利坚合众国江阴农商银行 注：读取文件 可以按行读123456RandomAccessFile raf = new RandomAccessFile("C:\\Users\\cx141\\Desktop\\credit\\2.txt", "rw");String line = raf.readLine();while (line != null) &#123; System.out.println(new String(line.getBytes("ISO-8859-1"), "GBK")); line = raf.readLine();&#125; 2.3 在文件的任意位置插入RandomAccessFile 在 任意位置pos插入 会覆盖pos后面原有的数据。只要把pos后面的内容先保存在一个临时文件中，待插入完成后，再把临时文件中的内容添加到 原文件结尾即可。 例如：12345678910111213141516171819202122232425262728293031public static void main(String[] args) &#123; // 指定一个插入位置 int pos = 14; File temp = new File("C:\\Users\\cx141\\Desktop\\credit\\temp.txt"); try &#123; temp.createNewFile(); RandomAccessFile raf = new RandomAccessFile("C:\\Users\\cx141\\Desktop\\credit\\2.txt", "rw"); FileOutputStream fos = new FileOutputStream(temp); raf.seek(pos); byte[] buffer = new byte[2]; int num = 0; // 把 seek 后的数据全部存储到临时文件中 while (-1 != (num = raf.read(buffer))) &#123; fos.write(buffer, 0, num); &#125; fos.close(); raf.seek(pos); raf.write("今天成立了".getBytes()); FileInputStream fis = new FileInputStream(temp); // 把临时文件内容 添加到原文件结尾 while (-1 != (num = fis.read(buffer))) &#123; raf.write(buffer, 0, num); &#125; fis.close(); raf.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 程序执行后，2.txt 文件内容：123中华人民共和国今天成立了美利坚合众国江阴农商银行]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java I/O 学习系列三: 字符流]]></title>
    <url>%2F2019%2F01%2F24%2FJava-I-O-%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89-%E5%AD%97%E7%AC%A6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[1 为什么需要字符流纯英文环境下，只要 字节流 就能完成一切任务。 在中文环境下，字节流 也能完成大多数 I/O 操作。但是遇到 读取中文文本文件，或 写入中文到文件中 这种操作时，就需要 字符流 了。 注意：复制中文文本文件 字节流 可以做。但是 读取中文文本文件 并 打印到控制台 这种操作 字节流 做不了，因为不知道中文字符占 2个字节(GBK) 还是 3个字节(UTF-8)，所以无法准确获取中文字符。这种情况下，字符流 就能 准确地获取到 中文字符。因为 字符流 是 按字符读取文件的。 2 Reader 和 WriterReader 是一个 抽象类， Writer 也是一个 抽象类 。 2.1 ReaderReader 简介Abstract class for reading character streams.The only methods that a subclass must implement are read(char[], int, int) and close().Most subclasses, however, will override some of the methods defined here in order to provide higher efficiency, additional functionality, or both.Reader 是一个 读取字符流 的抽象类。Reader 的子类 必须实现 read(char[], int, int) 和 close() 方法。然而，大多数子类 为了提高效率或附加功能 会覆盖许多其他的方法。 Fields12// 用于同步流的操作。为提高效率，Reader的子类应该用此字段 而不是 this对象 或 synchronized方法protected Object lock; Methods1234567891011121314151617181920212223242526272829// Closes the stream and releases any system resources associated with it.public abstract void close() throws IOException// Marks the present position in the stream.public void mark(int readAheadLimit) throws IOException// Tells whether this stream supports the mark() operation.public boolean markSupported()// Reads a single character.public int read() throws IOException// Reads characters into an array. 读取多个字符放在 cbuf 数组里public int read(char[] cbuf) throws IOException// Reads characters into a portion of an array.public abstract int read(char[] cbuf, int off,int len) throws IOException// Attempts to read characters into the specified character buffer.public int read(CharBuffer target) throws IOException// Tells whether this stream is ready to be read.public boolean ready() throws IOException// Resets the stream.public void reset() throws IOException// Skips n个 characters.public long skip(long n) throws IOException Reader 的直接子类BufferedReaderCharArrayReaderFilterReaderInputStreamReaderPipedReaderStringReader 2.2 WriterAbstract class for writing to character streams.The only methods that a subclass must implement are write(char[], int, int), flush(), and close().Most subclasses, however, will override some of the methods defined here in order to provide higher efficiency, additional functionality, or both.Writer 是一个写入字符流的 抽象类。Writer 的子类必须要实现(覆盖) write(char[], int, int), flush(), 和 close() 方法。然而，大多数子类 为了提高效率或附加功能 会覆盖许多其他的方法。 Fields12// 用于同步流的操作。 为提高效率，Writer的子类应该用此字段 而不是 this对象 或 synchronized方法protected Object lock; Methods1234567891011121314151617181920212223242526272829// Appends the specified character to this writer.public Writer append(char c) throws IOException// Appends the specified character sequence to this writer.public Writer append(CharSequence csq) throws IOException// Appends a subsequence of the specified character sequence to this writer.public Writer append(CharSequence csq, int start, int end) throws IOException// Closes the stream, flushing it first.public abstract void close() throws IOException// Flushes the stream.public abstract void flush() throws IOException// Writes an array of characters.public void write(char[] cbuf) throws IOException// Writes a portion of an array of characters. 写入字符数组的一部分。public abstract void write(char[] cbuf, int off, int len) throws IOException// Writes a single character.public void write(int c) throws IOException// Writes a string.public void write(String str) throws IOException// Writes a portion of a string. 写入字符串的一部分。public void write(String str, int off, int len) throws IOException Writer 的直接子类BufferedWriterCharArrayWriterFilterWriterOutputStreamWriterPipedWriterPrintWriterStringWriter 3 InputStreamReader 和 OutputStreamWriter继承关系：12345Reader |__InputStreamReaderWriter |__OutputStreamWriter 3.1 InputStreamReaderpublic class InputStreamReader extends Reader InputStreamReader 简介An InputStreamReader is a bridge from byte streams to character streams: It reads bytes and decodes them into characters using a specified charset.The charset that it uses may be specified by name or may be given explicitly, or the platform’s default charset may be accepted.InputStreamReader 是 字节流 到 字符流 的桥梁： InputStreamReader 读取字节 并 使用指定的字符集 解码为字符。InputStreamReader 使用的字符集 可以通过名称指定，也可以显式给定，或者接受平台默认的字符集。 每次调用 InputStreamReader 的 read 方法 可能导致从 底层字节输入流(underlying byte-input stream) 读取一个或多个字节。为了能有效的将字节转为字符，从 基础流中 提前读取的字节数 可能超过 当前读取操作所需的字节数。为了获得最高效率，一般在 BufferedReader 中 包装(wrapping) 一个 InputStreamReader ，例如：1BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); Constructors1234567891011// Creates an InputStreamReader that uses the default charset.InputStreamReader(InputStream in)// Creates an InputStreamReader that uses the given charset.InputStreamReader(InputStream in, Charset cs)// Creates an InputStreamReader that uses the given charset decoder.InputStreamReader(InputStream in, CharsetDecoder dec)// Creates an InputStreamReader that uses the named charset.InputStreamReader(InputStream in, String charsetName) 3.2 OutputStreamWriterpublic class OutputStreamWriter extends Writer OutputStreamWriter 简介An OutputStreamWriter is a bridge from character streams to byte streams: Characters written to it are encoded into bytes using a specified charset.The charset that it uses may be specified by name or may be given explicitly, or the platform’s default charset may be accepted.OutputStreamWriter 是字符流 到 字节流 的桥梁： 使用指定的字符集编码字符 后写入。OutputStreamWriter 使用的字符集 可以通过名称指定，也可以显式给定，或者接受平台默认的字符集。 每次调用 OutputStreamWriter 的 write 方法都会 对待处理的字符调用 编码转换器(encoding converter)。字节被写入 底层输入层流(underlying output stream) 之前被累计放在 缓冲区 中。缓冲区 的大小可以指定，但通常默认的大小足以满足大多数情况。注意，传递给 write 方法的 字符不会被缓冲。 为了获得最高效率，一般在 BufferedWriter 中 包装(wrapping) 一个 OutputStreamWriter ，这样可以避免频繁地调用转换器(converter)，例如：1Writer out = new BufferedWriter(new OutputStreamWriter(System.out)); Constructors1234567891011// Creates an OutputStreamWriter that uses the default character encoding.OutputStreamWriter(OutputStream out)// Creates an OutputStreamWriter that uses the given charset.OutputStreamWriter(OutputStream out, Charset cs)// Creates an OutputStreamWriter that uses the given charset encoder.OutputStreamWriter(OutputStream out, CharsetEncoder enc)// Creates an OutputStreamWriter that uses the named charset.OutputStreamWriter(OutputStream out, String charsetName) 4 FileReader 和 FileWriter继承关系：1234567Reader |__InputStreamReader |__FileReaderWriter |__OutputStreamWriter |__FileWriter 4.1 FileReaderFileReader 简介Convenience class for reading character files.The constructors of this class assume that the default character encoding and the default byte-buffer size are appropriate.To specify these values yourself, construct an InputStreamReader on a FileInputStream.FileReader 是一个 从文件读取字符的 便利类。FileWriter 的构造器 全都假定 默认的字符编码和默认的字节缓冲大小 是 符合要求的( 可接受的 )。如果要自己指定这些值得话，需要在 FileInputStream 上构造 InputStreamReader。 FileReader用于读取字符流。对于读取原始字节流，要使用 FileInputStream。 Constructors和 (字节)文件输入流 FileInputStream 一样，有 3 个构造函数，参数分别是 File、FileDescriptor、String：12345678// Creates a new FileReader, given the File to read from.FileReader(File file)// Creates a new FileReader, given the FileDescriptor to read from.FileReader(FileDescriptor fd)// Creates a new FileReader, given the name of the file to read from.FileReader(String fileName) 4.2 FileWriterFileWriter 简介Convenience class for writing character files.The constructors of this class assume that the default character encoding and the default byte-buffer size are acceptable.To specify these values yourself, construct an OutputStreamWriter on a FileOutputStream.FileWriter 是一个 写入字符到文件的 便利类。FileWriter 的构造器 全都假定 默认的字符编码和默认的字节缓冲大小 是 符合要求的( 可接受的 )。如果要自己指定这些值得话，需要在 FileOutputStream 上构造 OutputStreamWriter。 Constructors和 (字节)文件输出流 FileOutputStream 一样，有 5 个构造函数：1234567891011121314// Constructs a FileWriter object given a File object.FileWriter(File file)// Constructs a FileWriter object given a File object.FileWriter(File file, boolean append)// Constructs a FileWriter object associated with a file descriptor.FileWriter(FileDescriptor fd)// Constructs a FileWriter object given a file name.FileWriter(String fileName)// Constructs a FileWriter object given a file name with a boolean indicating whether or not to append the data written.FileWriter(String fileName, boolean append) 5 处理流：BufferedReader 和 BufferedWriter继承关系：12345Reader |__BufferedReaderWriter |__BufferedWriter 5.1 BufferedReaderBufferedReader 简介Reads text from a character-input stream, buffering characters so as to provide for the efficient reading of characters, arrays, and lines.The buffer size may be specified, or the default size may be used. The default is large enough for most purposes.BufferedReader 从 字符输入流 中读取文本，缓冲字符 以便有效地读取字符、数组和行 。可以指定缓冲区大小，也可以使用默认的缓冲区，在大多数场合默认缓冲区是够用的。 In general, each read request made of a Reader causes a corresponding read request to be made of the underlying character or byte stream.It is therefore advisable to wrap a BufferedReader around any Reader whose read() operations may be costly, such as FileReaders and InputStreamReaders.通常， Reader 的 read 请求 会触发 相应的 底层的字符或字节流(underlying character or byte stream)的 read 请求。因此，建议将 BufferedReader 包装在 read() 操作代价高昂的 Reader 上，例如 FileReader 和 InputStreamreader。例如:1BufferedReader in = new BufferedReader(new FileReader("foo.in")); ConstructorsBufferedReader 的 构造函数 和 BufferedInputStream 类似：12345// Creates a buffering character-input stream that uses a default-sized input buffer.BufferedReader(Reader in)// Creates a buffering character-input stream that uses an input buffer of the specified size.BufferedReader(Reader in, int sz) 部分 Methods12345678// Reads a single character.int read()// Reads characters into a portion of an array.int read(char[] cbuf, int off, int len)// Reads a line of text.String readLine() 5.2 BufferedWriterBufferedWriter 简介Writes text to a character-output stream, buffering characters so as to provide for the efficient writing of single characters, arrays, and strings.The buffer size may be specified, or the default size may be accepted. The default is large enough for most purposes.BufferedWriter 把文本写入到 字符输出流，缓冲字符 以便有效地 写入单个字符、数组、字符串。 A newLine() method is provided, which uses the platform’s own notion of line separator as defined by the system property line.separator.Not all platforms use the newline character ( ‘\n’ ) to terminate lines.Calling this method to terminate each output line is therefore preferred to writing a newline character directly.BufferedWriter 提供了 newLine() 方法，这个方法是 用平台自己的 行分隔符(line separator) 来换行 (注：行分隔符定义在系统属性 line.separator 中)。不是所有的 platform 都支持 ‘\n’ 换行。因此，调用 newLine() 方法换行 比 直接用 写换行符换行 更可取。 In general, a Writer sends its output immediately to the underlying character or byte stream.Unless prompt output is required, it is advisable to wrap a BufferedWriter around any Writer whose write() operations may be costly, such as FileWriters and OutputStreamWriters.通常， Writer 会立即发送它的输出 到 底层字符或字节流(the underlying character or byte stream)。除非需要提示输出，否则 建议 使用 BufferedWriter 包装 write() 操作代价高昂的 Writer 上，例如 FileWriter 和 OutputStreamWriter。例如：1PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("foo.out"))); ConstructorsBufferedWriter 的 构造方法 和 BufferedOutputStream 类似：12345// Creates a buffered character-output stream that uses a default-sized output buffer.BufferedWriter(Writer out)// Creates a new buffered character-output stream that uses an output buffer of the given size.BufferedWriter(Writer out, int sz) 部分 Methods1234567891011// Writes a line separator.void newLine()// Writes a portion of an array of characters.void write(char[] cbuf, int off, int len)// Writes a single character.void write(int c)// Writes a portion of a String.void write(String s, int off, int len) 6 PrintWriter123java.lang.Object |__java.io.Writer |__java.io.PrintWriter PrintWriter 是一种 字符输出流。PrintWriter 的构造函数 可以接收的参数类型：1、 file对象2、 字符串对象3、 字节输出流 OutputStream4、 字符输出流 Writer 示例：12345678910111213public class PrintWriterDemo &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in)); // true表示自动刷新 PrintWriter out = new PrintWriter(new FileWriter("aaaa.txt"), true); String line = null; while ((line = bufr.readLine()) != null) &#123; out.println(line); &#125; &#125;&#125; 7 综合示例待更新… 参考1、 Java Standard Edition 8 API Specification]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java I/O 学习系列二: 字节流]]></title>
    <url>%2F2019%2F01%2F23%2FJava-I-O-%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C-%E5%AD%97%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[I/O流 是 (输入/输出)读取/写入 “文件” 内容的技术。 1 Java I/O 流简介Java 程序 通过 I/O流完成 输入/输出。流是生产和消费信息的抽象。输入流可以是多种不同类型的输入：磁盘文件，键盘，网络；输出流可以是多种不同类型的输出：磁盘文件，控制台，网络。 Java I/O流 的分类：根据 流向 分为 输入流 和 输出流；根据 传输数据单位 分为 字节流 和 字符流；根据 功能 分为 节点流 和 包装流 (见标题4)。 字节流： Java 所有字节流都直接或间接 继承 InputStream类 和 OutputStream类。字符流： Java 所有字符流都直接或间接 继承 Reader类 和 Writer类。 2 InputStream 和 OutputStreamInputStream类 是抽象类， OutputStream类 也是抽象类。 2.1 InputStreamThis abstract class is the superclass of all classes representing an input stream of bytes.这个抽象类是 所有字节输入流的 父类。 InputStream 主要方法：abstract int read(): Reads the next byte of data from the input stream. 返回 下一个字节内容(即本次read读取到的字节内容)，返回-1表示一个字节都没有读到(这意味着已经读到文件尾后)。int read(byte[] b): 等价于 read(byte[] b, 0, b.length)。返回 实际读取到的字节个数，返回-1表示一个字节都没有读到(这意味着已经读到文件尾后)。读取到的内容放在 byte数组中。int read(byte[] b, int off, int len): 从输入流中，从0位置开始 读取 len个字节放入 b数组中(注：从off位置开始放)。返回 实际读取到的字节个数，返回-1表示一个字节都没有读到(这意味着已经读到文件尾后)。void mark(int readlimit): Marks the current position in this input stream.void reset(): Repositions this stream to the position at the time the mark method was last called on this input stream.long skip(long n): Skips over and discards n bytes of data from this input stream.void close(): Closes this input stream and releases any system resources associated with the stream. InputStream 同包下的直接子类：ByteArrayInputStreamFileInputStreamFilterInputStreamObjectInputStreamPipedInputStreamSequenceInputStreamStringBufferInputStream 2.2 OutputStreamThis abstract class is the superclass of all classes representing an output stream of bytes. An output stream accepts output bytes and sends them to some sink.这个抽象类是 所有字节输出流的 父类。输出流 接收输出字节 并发送到某个接收位置。 OutputStream 所有方法：void write(byte[] b): 从 byte数组 取 b.length 个字节 写入输出流。等价于write(byte[] b, 0, b.length)。void write(byte[] b, int off, int len): Writes len bytes from the specified byte array starting at offset off to this output stream. off 是 在数组b 中的任意一个下标，len表示取 len个字节，off和len必须满足关系：len&lt;=b.length-off，否则会数组下标越界异常。abstract void write(int b): 写 一个字节数据(b对应的ASCII字符) 到输出流，通常和 int read() 联合使用。void flush(): Flushes this output stream and forces any buffered output bytes to be written out.void close(): 略。 OutputStream 同包下的直接子类：ByteArrayOutputStreamFileOutputStreamFilterOutputStreamObjectOutputStreamPipedOutputStream 3 节点流: FileInputStream 和 FileOutputStream3.1 FileInputStream简介：A FileInputStream obtains input bytes from a file in a file system. What files are available depends on the host environment.FileInputStream is meant for reading streams of raw bytes such as image data. For reading streams of characters, consider using FileReader.FileInputStream类 用于从文件系统的文件中获取 输入字节流，文件是否可用取决于 主机环境。FileInputStream类 常用于读取文件的(原始)字节，如图片文件，视频文件等。如果读取字符文件(字符流)，应该用FileReader，而不是FileInputStream。 constructorsFileInputStream(File file) throws FileNotFoundException：Creates a FileInputStream by opening a connection to an actual file, the file named by the File object file in the file system. 传入File对象，建立文件输入流。FileInputStream(String name) throws FileNotFoundException：Creates a FileInputStream by opening a connection to an actual file, the file named by the path name in the file system. 不创建File对象，直接传入文件路径。FileInputStream(FileDescriptor fdObj)：Creates a FileInputStream by using the file descriptor fdObj, which represents an existing connection to an actual file in the file system. FileInputStream类 的主要方法 和 InputStream类 的基本相同。 FileInputStream 示例1234567891011121314151617181920212223public static void main(String[] args)&#123; File f=new File("C:/Users/cx141/Documents/test/file1.txt"); int length=10;//(int)f.length(); byte[] b=new byte[length]; int num=0; try &#123; FileInputStream fis=new FileInputStream(f); while((num=fis.read(b))!=-1)&#123; System.out.println("此次读取到的字节个数: "+num); for(int i=0;i&lt;num;i++) System.out.print(b[i]); System.out.println(); String str=new String(b,0,num); System.out.println("此次读取到的内容: "+str); System.out.println("-----"); &#125; fis.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;&#125; file1.txt 文件内容如下：12123456789hello world 程序运行结果：12345678910111213此次读取到的字节个数: 1049505152535455565713此次读取到的内容: 123456789-----此次读取到的字节个数: 101010410110810811132119111114此次读取到的内容:hello wor-----此次读取到的字节个数: 2108100此次读取到的内容: ld----- 注：由输出结果看，file1.txt 文件中 9后面的回车是占两个字节的。 3.2 FileOutputStream简介：A file output stream is an output stream for writing data to a File or to a FileDescriptor. Whether or not a file is available or may be created depends upon the underlying platform. Some platforms, in particular, allow a file to be opened for writing by only one FileOutputStream (or other file-writing object) at a time. In such situations the constructors in this class will fail if the file involved is already open.FileOutputStream is meant for writing streams of raw bytes such as image data. For writing streams of characters, consider using FileWriter.文件输出流 是把数据写入文件的输出流。文件是否可用或文件是否可创建取决于底层平台。尤其在某些平台中，一次只能用一个 FileOutputStream流 进行写入。如果文件已经(用文件输出流)打开，那么再创建此文件的文件输出流会失败。文件输出流 是用于写入(原始)字节到文件的流，常用于写图片，视频等文件。 写入字符的流时应该使用FileWriter 而不是 FileOutputStream。 constructorspublic FileOutputStream(File file) throws FileNotFoundException:Creates a file output stream to write to the file represented by the specified File object. FileOutputStream(File file, boolean append) throws FileNotFoundException:Creates a file output stream to write to the file represented by the specified File object. If the second argument is true, then bytes will be written to the end of the file rather than the beginning. FileOutputStream(String name) throws FileNotFoundException:Creates a file output stream to write to the file with the specified name. FileOutputStream(String name, boolean append) throws FileNotFoundException:Creates a file output stream to write to the file with the specified name. If the second argument is true, then bytes will be written to the end of the file rather than the beginning. FileOutputStream(FileDescriptor fdObj):Creates a file output stream to write to the specified file descriptor, which represents an existing connection to an actual file in the file system. FileOutputStream类 的主要方法 和 OutputStream类 的基本相同。 示例1234567891011121314151617public static void main(String[] args) &#123; try &#123; FileOutputStream fos = new FileOutputStream("C:/Users/cx141/Documents/test/file2.txt"); String str="don't panic."; fos.write(str.getBytes()); fos.write(10);// ASCII对应的字符是 换行符 fos.write(49);// ASCII对应的字符是 1 fos.write(97);// ASCII对应的字符是 a fos.write(10); fos.write("123456789".getBytes(),2,7); //注意：off 和 len 取值 受到byte[] b长度影响 fos.close(); &#125;catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 程序运行结果：123don&apos;t panic.1a3456789 4 处理流: FilterInputStream 和 FilterOutputStream节点流：可以从或向一个特定的地方(节点)读写数据。前面介绍的流 都是节点流。处理流：对一个已存在的流进行封装/装饰，通过对 封装流调用 实现数据读写。 FilterInputStream 和 FilterOutputStream 都是 处理流。 Filter这两个流用到了 设计模式中的 装饰器模式：FilterInputStream 和 FilterOutputStream 都是 装饰器模式 中的 Decorator抽象装饰角色。FilterInputStream 继承 InputStream，同时 FilterInputStream 有一个 InputStream 类型的成员。FilterOutputStream 继承 OutputStream，同时 FilterOutputStream 有一个 OutputStream 类型的成员。 FilterInputStream 和 FilterOutputStream 既然作为抽象的装饰器角色存在，所以他们没有什么实质性的方法。 4.1 FilterInputStreamFilterInputStream 简介A FilterInputStream contains some other input stream, which it uses as its basic source of data, possibly transforming the data along the way or providing additional functionality.The class FilterInputStream itself simply overrides all methods of InputStream with versions that pass all requests to the contained input stream.Subclasses of FilterInputStream may further override some of these methods and may also provide additional methods and fields.FilterInputStream 包含一些其他的输入流，FilterInputStream使用这些输入流作为基本数据源，并为它们提供额外功能。FilterInputStream类 本身只是简单覆盖 InputStream 中的所有方法 (with versions这段不理解啥意思)。FilterInputStream 的子类可能进一步覆盖一些方法，并且可能添加了额外的方法和字段。 FilterInputStream 同包下的直接子类BufferedInputStreamDataInputStreamPushbackInputStreamLineNumberInputStream 4.2 FilterOutputStreamFilterOutputStream 简介This class is the superclass of all classes that filter output streams.These streams sit on top of an already existing output stream (the underlying output stream) which it uses as its basic sink of data, but possibly transforming the data along the way or providing additional functionality.The class FilterOutputStream itself simply overrides all methods of OutputStream with versions that pass all requests to the underlying output stream. Subclasses of FilterOutputStream may further override some of these methods as well as provide additional methods and fields.FilterOutputStream类 是所有过滤输出流的超类。这些 filter output stream 的作用是 包装其他的流 并提供额外的功能。 FilterOutputStream 同包下的直接子类BufferedOutputStreamDataOutputStreamPrintStream 5 处理流: BufferedInputStream 和 BufferedOutputStream继承关系：1234567InputStream |__FilterInputStream |__BufferedInputStreamOutputStream |__FilterOutputStream |__BufferedOutputStream 缓冲输入/输出流 的思想：缓冲输入/输出流 每次 读取/写入 数据时，先把数据放在 缓冲区(内存)中，等缓冲区满了(或 调用flush函数)再进行 实际的读写操作。 缓冲输入/输出流 读写 效率 比其他流高，比如：不带缓冲的输出流，写入文件，每次读几个字节就写几个字节，I/O次数比较多；缓冲输出流，写入文件，可以一次读很多字节，但不向磁盘中写入，只是先放到内存里，等凑够了缓冲区大小的时候一次性写入磁盘，这样可以减少磁盘操作次数，提高写入效率。 5.1 BufferedInputStreamBufferedInputStream 为 另一个输入流添加了 mark 和 reset 的功能。BufferedInputStream 对象创建时，同时会创建一个 内部缓冲区数组(internal buffer array)。当 read 或 skip 流中的字节时，内部缓冲区会被重新填充。mark 操作会标记输入流中的一个位置，reset 操作 会跳转到最近的 mark 的位置。 Fields1234567891011121314151617// 内部缓冲区数组protected byte[] buf;// buf 中存储的字节 总数protected int count;// 缓冲区当前位置(下标)protected int pos;// 上次调用 mark 时 记录的 pos的值protected int markpos;// 不理解这个字段的意思protected int marklimit;// 从 java.io.FilterInputStream 继承的字段protected volatile InputStream in; Constructors12345// 使用默认buf大小, 8192字节(8KB)public BufferedInputStream(InputStream in);// 使用 size 指定的 buf 大小public BufferedInputStream(InputStream in,int size); Methods123456789101112131415161718// 返回 被包装流 的可读取的字节总数 的估计值int available();// 和 InputStream 中的 read 一样：读取下一个字节int read();// 给一个起始位置 off，从字节输入流读取 len个字节 放入b数组中int read(byte[] b, int off, int len);// 查看此流是否支持 markboolean markSupported();// 同 InputStream：标记当前 位置void mark(int readlimit);// 同 InputStreamvoid reset();// 同 InputStreamlong skip(long n);void close(); 5.2 BufferedOutputStreamBufferedOutputStream 包装 底层输出流(underlying output stream) 提供缓冲功能。 Fields12345678// 内部缓冲区数组protected byte[] buf;// The number of valid bytes in the buffer. 缓冲区数组的有效字节数(即，数组实际大小)protected int count;// 继承 java.io.FilterOutputStreamprotected OutputStream out; Constructors1234// 使用 默认 内部缓冲数组大小 8192字节(8KB)public BufferedOutputStream(OutputStream out);// 使用 size 指定 内部缓冲数组大小public BufferedOutputStream(OutputStream out, int size); Methods1234567void flush();// 从 b数组中 取 len 个字节 写入 缓冲输入流void write(byte[] b, int off, int len);// 写指定的字节到 缓冲输出流void write(int b);// 还有一些继承来的方法，略 5.3 缓冲输入/输出流 示例以下四段程序复制的 zip 文件 大小为 1.12GB。 1、 FileInputStream/FileOutputStream 单字节复制：12345678910111213141516171819202122public static void main(String[] args)&#123; long begin=System.currentTimeMillis(); File fileIn=new File("C:\\Users\\cx141\\Downloads\\win64_11gR2_database_1of2.zip"); File fileOut=new File("C:/Users/cx141/Documents/test/1.zip"); try &#123; FileInputStream fis = new FileInputStream(fileIn); FileOutputStream fos = new FileOutputStream(fileOut); int i=0; while((i=fis.read())!=-1)&#123; fos.write(i); &#125; fos.close(); fis.close(); long end=System.currentTimeMillis(); System.out.println("耗时: "+ (end-begin)/1000 +" 秒"); &#125;catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125;//耗时大约 1 个小时 2、 BufferedInputStream/BufferedOutputStream 单字节复制：1234567891011121314151617181920212223242526public static void main(String[] args)&#123; long begin=System.currentTimeMillis(); try&#123; File f1=new File("C:/Users/cx141/Downloads/win64_11gR2_database_1of2.zip"); FileInputStream in = new FileInputStream(f1); BufferedInputStream bin=new BufferedInputStream(in); File f2=new File("C:/Users/cx141/Documents/test","2.zip"); FileOutputStream out = new FileOutputStream(f2); BufferedOutputStream bout=new BufferedOutputStream(out); int b=0; while((b=bin.read())!=-1)&#123; bout.write(b); &#125; bout.flush(); bin.close(); bout.close(); long end=System.currentTimeMillis(); long consume=(end-begin)/1000; System.out.println("耗时："+consume+" 秒"); &#125;catch(FileNotFoundException e)&#123; e.printStackTrace(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;&#125;// 耗时：40 秒 单字节复制时，结果很明显，缓冲流包装文件流复制 比 直接用文件流复制 要快得多。 3、 FileInputStream/FileOutputStream 多字节(2KB)复制：123456789101112131415161718192021222324public static void main(String[] args)&#123; long begin=System.currentTimeMillis(); File fileIn=new File("C:\\Users\\cx141\\Downloads\\win64_11gR2_database_1of2.zip"); File fileOut=new File("C:/Users/cx141/Documents/test/3.zip"); try &#123; FileInputStream fis = new FileInputStream(fileIn); FileOutputStream fos = new FileOutputStream(fileOut); int BUFSIZE=1024*2; byte[] b=new byte[BUFSIZE]; int readLength=0; while((readLength=fis.read(b,0,BUFSIZE))!=-1)&#123; fos.write(b,0,BUFSIZE); &#125; fos.close(); fis.close(); long end=System.currentTimeMillis(); System.out.println("耗时: "+ (end-begin)/1000 +" 秒"); &#125;catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125;// 耗时：6 秒 4、 BufferedInputStream/BufferedOutputStream 多字节(2KB)复制：12345678910111213141516171819202122232425262728public static void main(String[] args)&#123; long begin=System.currentTimeMillis(); File fileIn=new File("C:\\Users\\cx141\\Downloads\\win64_11gR2_database_1of2.zip"); File fileOut=new File("C:/Users/cx141/Documents/test/4.zip"); try &#123; FileInputStream fis=new FileInputStream(fileIn); FileOutputStream fos=new FileOutputStream(fileOut); // 缓冲输入/输出流 BufferedInputStream bis=new BufferedInputStream(fis); BufferedOutputStream bos=new BufferedOutputStream(fos); int BUFSIZE=1024*2; byte[] buf=new byte[BUFSIZE]; int readLength=0; while((readLength=bis.read(buf,0,BUFSIZE))!=-1)&#123; bos.write(buf,0,readLength); &#125; bos.flush(); bis.close(); bos.close(); long end=System.currentTimeMillis(); System.out.println("耗时: "+ (end-begin)/1000 +" 秒"); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125;&#125;//耗时：2 秒 总结与分析：上面程序中，缓冲流均采用 默认的 8KB 大的 缓冲byte数组。不论是单字节还是多字节复制，利用 缓冲流 处理的文件流 都比 普通文件流 要快(因为缓冲到内存，减少了 I/O 次数)。如果文件不大，采用多字节复制，普通文件流操作 和 缓冲流 之间的效率差距并不大！缓冲流只有在大幅减少 I/O 次数时，才可能提高效率。 参考1、 深入理解JAVA I/O系列二：字节流详解2、 Standard Edition 8 API Specification3、 Java IO详解（二)——流的分类4、 JavaIO之FilterInputStream FilterOutputStream5、 Java IO流学习总结三：缓冲流]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java I/O 学习系列一: File类]]></title>
    <url>%2F2019%2F01%2F22%2FJava-I-O-%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80-File%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[抽象路径名(abstract pathname)：Java 为了方便对不同命名规则的路径进行统一的处理，以 Java的抽象路径名代表不同系统的路径名。 File 类 简介：1、一个 File类 的对象，表示磁盘上的一个文件/目录。2、File 提供了 (与平台无关的)方法来对磁盘上的 文件/目录 进行操作。 可见，File类 可以表示文件及操作文件， 但 不能读写文件内容。 1 ConstructorsFile 类的 有 4个 constructors：1234567File(File parent, String child)// 根据 文件或目录 创建File对象File(String pathname)File(String parent, String child)File(URI uri) 注：File 对象 对应的文件/目录 不一定存在。 2 常用 Methodsboolean canRead() 文件/目录 是否可读boolean canWrite()boolean canExecute() boolean exists() 判断 文件/目录 是否存在，存在返回 trueboolean createNewFile() 创建 文件/目录boolean delete() 删除 文件/目录 String getAbsolutePath() 获取抽象路径名(文件/目录)的绝对路径(文件或目录)String getPath() 获取抽象路径名(文件/目录)的路径(文件或目录)String getName() 获取文件/目录名 boolean isDirectory() 是目录返回trueboolean isFile() 是文件返回true long length() 返回文件的大小(字节)File[] listFiles() 返回目录下的所有 文件/目录 boolean mkdir() 创建目录boolean mkdirs() 递归创建多次目录 3 示例12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; File f1=new File("C:\\Users\\cx141\\Documents\\test\\file1.txt"); // 指定路径的文件是否存在，存在 exists 返回true if(f1.exists()) &#123; System.out.println("文件名称: "+f1.getName()); System.out.println("文件大小: "+f1.length()+" 字节"); System.out.println("文件绝对路径: "+f1.getAbsolutePath()); &#125;else &#123; System.out.println("file1.txt 不存在"); try &#123; //createNewFile 创建文件 f1.createNewFile(); System.out.println("file1.txt 文件创建成功"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 删除文件 File f2 =new File("C:/Users/cx141/Documents/test/file1.txt"); f2.delete(); // 创建目录 File f3=new File("C:/Users/cx141/Documents/test/dirc2"); if(f3.exists() &amp;&amp; f3.isDirectory()) &#123; System.out.println("dirc2 目录已存在"); &#125;else &#123; f3.mkdir(); //mkdir创建目录， 另：mkdirs 可以递归创建多层目录 System.out.println("dirc2 目录创建成功"); &#125; // listFiles 列出目录中所有的文件和文件夹 File f4=new File("C:/Users/cx141/Documents/test"); if(f4.isDirectory()) &#123; File fList[]=f4.listFiles(); for(int i=0;i&lt;fList.length;i++) &#123; System.out.println(fList[i]); &#125; &#125;&#125; 在 Windows OS 中，绝对路径写法：C:\Users\cx141\Documents\test\file1.txt ，也可以 C:/Users/cx141/Documents/test/file1.txt 。在 Linux/Unix 中， 绝对路径写法：C:/Users/cx141/Documents/test/file1.txt 。所以，路径可以统一写作：C:/Users/cx141/Documents/test/file1.txt 。 注：在File类中，路径的分隔符是 File.separator 参考1、 JAVA 抽象路径2、 深入理解JAVA I/O系列一：File]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RedHat系的软件包管理]]></title>
    <url>%2F2019%2F01%2F15%2FRedHat%E7%B3%BB%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[耳濡目染，不学以能。 —韩愈 1 Linux 包管理概述Linux 系统按照 包管理系统 可划分为两个派系： RedHat系 和 Debian系。 RedHat 系(RedHat, CentOS, Fedora, Oracle Linux等)：1、 包格式： .rpm2、 包管理工具： rpm，yum，dnf(Fedora在yum之后开发的包管理工具)rpm (RPM Package Manager) 是一个包管理系统。yum (Yellowdog Updater, Modified) 是一个基于 rpm 的 包管理程序。dnf (Dandified YUM) , 最近的 Fedora 版本中，dnf 取代了 yum。dnf 是 yum 的一个现代化的分支，它保留了大部分 yum 的接口。 Debian 系(Debian, Ubuntu等)：1、 包格式： .deb2、 包管理工具： dpkg, apt-cache, apt-get, apt-config, aptAPT (Advanced Package Tool, 高级软件包工具) 是一个 软件接口。dpkg (Debian Package) 是一个底层的包管理工具。apt 是一套处理包的工具集 (包含命令 apt)。apt-cache, apt-get, apt-config 命令 是 apt 命令 的超集 。 2 RPM Package Managerrpm 命令的用法有3大类：查询和校验包，安装更新和删除，杂项。 2.1 QUERYING AND VERIFYING PACKAGES:123rpm &#123;-q|--query&#125; [select-options] [query-options]rpm &#123;-V|--verify&#125; [select-options] [verify-options] select-options, query-options, verify-options, install-options 详细参数参考 man rpm。常用参数：1234567891011# 查询 所有已经安装的软件包rpm -qarpm -q --all# 查询 指定软件包信息rpm -qi yumrpm -q --info yum# 查询软件包相关的文件rpm -ql yumrpm -q --list yum 2.2 INSTALLING, UPGRADING, AND REMOVING PACKAGES:12345678rpm &#123;-i|--install&#125; [install-options] PACKAGE_FILE ...rpm &#123;-U|--upgrade&#125; [install-options] PACKAGE_FILE ...rpm &#123;-F|--freshen&#125; [install-options] PACKAGE_FILE ...rpm &#123;-e|--erase&#125; [--allmatches] [--justdb] [--nodeps] [--noscripts] [--notriggers] [--test] PACKAGE_NAME ... 常用参数：123456789# 安装软件包. -v 表示 verbose 冗长输入，-h 表示 hash 井号进度条rpm -ivh xxxx.rpm# --nodeps 不验证软件包的依赖(no dependencies)# --force 强制安装，即使覆盖其他包的文件也要安装#强制安装rpm -ivh --nodeps xxxx.rpm#强制卸载rpm -e --nodeps --force xxxx.rpm 2.3 MISCELLANEOUS:123rpm &#123;--querytags|--showrc&#125;rpm &#123;--setperms|--setugids&#125; PACKAGE_NAME ... 2.4 软件包的命名如下有 3 个 rpm 软件包：123yum- 3.4.3-161. el7. centos. noarch.rpmyum-metadata-parser- 1.1.4-10. el7. x86_64.rpmyum-plugin-fastestmirror- 1.1.31-50. el7. noarch.rpm rpm 软件包命名规则：软件名-主版本号.次版本号-修订号. 适用的Linux平台. 适用的硬件平台.rpm Linux平台有： centos、el系列(RHEL/centos)。硬件平台有：i386、i686、x86_64、noarch(no architecture, 所有硬件平台通用)。 3 yumrpm 虽然可以安装软件包，但是需要自己安装 依赖包。安装依赖 是很一件繁琐的事(需要一个一个一层一层的下载，再安装)。 通常情况下，安装软件都是用 yum，而不是 rpm。 3.1 yum 简介yum 可以自动 管理 包间的依赖关系。和 Debian系 的Advanced Package Tool (APT) 类似，yum与软件仓库(software repositories)一起工作，这些软件仓库可以在本地访问 也能通过网络连接访问。 3.2 yum 工作原理这里只关注客户端，不考虑服务端。 客户端的配置文件：/etc/yum.conf 和 /etc/yum.repos.d/*.repo。 /etc/yum.conf 包含一个 [main] section，可以通过它设置 全局作用的 yum 选项。 /etc/yum.conf 文件还可以包含一个或多个 [repository] sections，可以通过他们设置 repository-specific options(特定的仓库选项)。但是，推荐的做法是 在/etc/yum.repos.d 目录下 新建 .repo 文件， 把 特定的仓库选项 放在 .repo 文件中。 /etc/yum.conf 文件的 [main] Options 默认设置：12345678910111213141516171819202122[main]# 存储 yum缓存和数据库文件 目录的绝对路径cachedir=/var/cache/yum/$basearch/$releasever# 安装成功后是否保存缓存：0-不保留，1-保留keepcache=0# 显示 调试输出： level 取值0到10，值越大debug输出越详细，0-不输出，2-缺省debuglevel=2# yum 日志文件 的绝对路径logfile=/var/log/yum.log# 确切的architecture ： 0-更新包时不考虑确切的 architecture，1-更新时考虑 exactarch=1# 废弃处理逻辑(obsoletes processing logic): 0-禁用，1-enable( 取决于包的spec file内容)obsoletes=1# GPG signature 检查(一种加密软件套件)： 0-disable，1-enablegpgcheck=1# yum plug-ins globally(yum全局插件): 0-disable, 1-enableplugins=1# installonlypkgs directive 用到的参数installonly_limit=5# 后两个作用不详bugtracker_url=http://bugs.centos.org/set_project.php?project_id=23&amp;ref=http://bugs.centos.org/bug_report_page.php?category=yumdistroverpkg=centos-release 仓库配置文件 /etc/yum.repos.d/*.repo ：1234567891011121314151617# 仓库的ID，可以取任意名字，只要不和其他的ID冲突即可 [Repository_ID]# a human-readable string describing the repository. name=repository_name# 服务端 repodata文件夹 所在目录的URL，客户端安装包时访问的路径 baseurl=repository_url# 镜像服务器的地址列表. 注：baseurl 和 mirrorlist 只能选其一mirrorlist=repository_url_list# 1-Include this repository as a package source(将此仓库作为包源，支持HTTP、FTP、本地库). enabled=&#123;1|0&#125;# 是否进行 gpg签名(GNU Privacy Guard)检测，0-disable，1-enable(默认)。若启用gpg检查，需要告知其key是什么gpgcheck=&#123;1|0&#125; # 如果启用 gpg签名检测，则需要指定gpgkey的路径，次路径可以是远程服务器上的，也可以是本地的.gpgkey=url 3.3 yum 命令 GENERAL OPTIONS3.3.1 安装和删除123yum -y install package-name;yum -y remove package-name; -y 自动确认安装/删除 例如安装 sl：1yum -y install sl; 3.3.2 更新和升级123yum update package-name;yum upgrade package-name; 3.3.3 缓存清除缓存：1yum clean [headers|packages|metadata|dbcache|plugins|expire-cache|all] packages 清除缓存目录下的软件包, 清空的是(/var/cache/yum)下的缓存。headers 清除缓存目录下的 headers。all 清除所有的 yum缓存。 将服务器软件包信息缓存至本地：1yum makecache; 3.3.4 查找和显示12345678# 显示 软件包信息yum info sl# 显示 软件包安装信息yum list sl# 查询 软件包依赖信息yum deplist sl 4 RedHat6.4 重新安装 yumRedHat6.4 原生 yum 需要注册付费才能下载软件，要想不注册，需要重新安装 yum ( CentOS6 版本 )。 1、 卸载 RedHat6.4 原生 yum:1rpm -qa | grep yum | xargs rpm -e --nodeps 2、 从 网易镜像网站 下载如下几个包(wget 下载过程略) 并安装：123456rpm -ivh python-iniparse-0.3.1-2.1.el6.noarch.rpm rpm -ivh python-urlgrabber-3.9.1-11.el6.noarch.rpmrpm -ivh yum-metadata-parser-1.1.2-16.el6.x86_64.rpm# 以下两个包要一起安装rpm -ivh yum-3.2.29-40.el6.centos.noarch.rpm yum-plugin-fastestmirror-1.1.30-14.el6.noarch.rpm 注意：如果安装过程中有报 conflict 问题，用 rpm -Uvh xxx.rpm 升级，或 用 –force强制安装。如果报 xxx needed by 问题，那么需要下载 xxx.rpm 包并安装。 3、 下载 CentOS6-Base-163.repo:12cd /etc/yum.repos.dwget https://mirrors.163.com/.help/CentOS6-Base-163.repo 把 CentOS6-Base-163.repo 文件中的 $releasever 替换 为 6。 不要修改 epel.repo 文件。 4、 清理缓存：123yum clean allyum makecacheyum update 5、 完成，测试以下：1234yum install -y gccyum -y install slyum -y install treeyum -y install htop 参考1 Linux 包管理基础：apt、yum、dnf 和 pkg2 CONFIGURING YUM AND YUM REPOSITORIES3 yum的工作原理以及如何建立yum仓库4 SETTING REPOSITORY OPTIONS5 yum 命令讲解6 yum (software)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 域名解析失败]]></title>
    <url>%2F2019%2F01%2F14%2FLinux-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[1 问题1wget https://mirrors.163.com/centos/7/os/x86_64/Packages/PackageKit-yum-plugin-1.1.10-1.el7.centos.x86_64.rpm 报错如下： 正在解析主机 mirrors.163.com… 失败：域名解析暂时失败。wget: 无法解析主机地址 “mirrors.163.com” 2 问题排查123456789# ping 百度的域名，ping不通ping baidu.com# ping: unknown host baidu.com# ping 百度的 ip，可以 ping通ping 220.181.112.244# PING 220.181.112.244 (220.181.112.244) 56(84) bytes of data.# 64 bytes from 220.181.112.244: icmp_seq=1 ttl=49 time=26.5 ms# 64 bytes from 220.181.112.244: icmp_seq=2 ttl=49 time=26.3 ms 说明是 DNS 解析 有问题！ 修改 /etc/resolv.conf 文件(DNS resolver配置文件) ：1nameserver 114.114.114.114 114DNS 以多个基础电信运营商自用的DNS系统为基础，通过扩展而建成专业的第三方高可靠 DNS服务平台….总之，用 114DNS 做 DNS解析 能解决当下的问题。 结果：1234ping baidu.com# PING baidu.com (220.181.57.216) 56(84) bytes of data.# 64 bytes from 220.181.57.216: icmp_seq=1 ttl=49 time=22.3 ms# 64 bytes from 220.181.57.216: icmp_seq=2 ttl=49 time=22.2 ms 3 附加说明Linux 版本信息：12345uname -a# Linux ahtelecom-rhel6.4 2.6.32-358.el6.x86_64 #1 SMP Tue Jan 29 11:47:41 EST 2013 x86_64 x86_64 x86_64 GNU/Linuxcat /etc/redhat-release# Red Hat Enterprise Linux Server release 6.4 (Santiago) 网络配置信息：1234567891011121314151617181920# 查询网关route -n# Kernel IP routing table# Destination Gateway Genmask Flags Metric Ref Use Iface# 169.254.169.254 10.189.2.1 255.255.255.255 UGH 0 0 0 eth0# 10.189.2.0 0.0.0.0 255.255.255.0 U 1 0 0 eth0# 0.0.0.0 10.189.2.1 0.0.0.0 UG 0 0 0 eth0# 网卡配置文件cat /etc/sysconfig/network-scripts/ifcfg-eth0# DEVICE=eth0# TYPE=Ethernet# ONBOOT=yes# BOOTPROTO=dhcp# NM_CONTROLLED=yes# 服务器所需网络配置信息(information about the desired network configuration on your server)cat /etc/sysconfig/network# NETWORKING=yes# HOSTNAME=ahtelecom-rhel6.4]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redhat6.4忘记root密码]]></title>
    <url>%2F2019%2F01%2F14%2Fredhat6-4%E5%BF%98%E8%AE%B0root%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1 进入 grub 引导程序重启进入 GNU GRUB 界面。 2 用单用户模式登录输入 ‘e’字符，接着的界面会有3个选项出现：root (hd0,0)kernel /vmlinuz-2.6…initrd /initramfs-2.6… 选中 “kernel” 这一行，然后按下”e”键，出现以下页面： 在这行的末尾输入 “ single” (single前面有个空格)，回车。 这时第二项依旧处于选中状态，然后按下 ‘b’ 重启。操作系统启动完成，不需要输入密码，直接登录 root 账户。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 命令 xargs]]></title>
    <url>%2F2019%2F01%2F09%2FLinux-%E5%91%BD%E4%BB%A4-xargs%2F</url>
    <content type="text"><![CDATA[在 Unix 和 类Unix 系统中，xargs 的作用是 把 标准输入(standard input) 转换成 其他命令的 命令行参数(command-line arguments)。 标准输入： 程序运行时从 键盘输入，或者 管道 传入的数据。例如，grep 从 标准输入(管道) 中 获取数据 并查找 root 所在行：1cat /etc/passwd | grep "root" 命令行参数： 此参数(数据) 在输入命令时就确定了。例如， grep 从 命令行参数 /etc/passwd 中获取数据 并查找 root 所在行:1grep "root" /etc/passwd 1 为什么需要 xargs 做转换 ?上面的介绍中，grep 可以从 标准输入 获取数据，也可以从 命令行参数 获取数据。 事实上，所有 Linux 命令 都可以从 命令行参数 获取数据 (如果有命令行参数的话)。只有一部分 命令 能够从 标准输入 中获取数据，grep 和 cat 就在这一部分命令之中。 举个例子， 文件 1.txt 内容如下：1231.txthelloworld 执行以下命令，观察结果 (结果是每条命令下的注释) ：12345678910111213141516171819echo "hello"# hello# cat 从标准输入中获取数据echo "hello" | cat# hello# cat 同时标准输入和命令行参数获取数据，cat 会忽略 标准输入echo "hello" | cat 1.txt# 1.txt# hello# world# cat 同时标准输入和命令行参数获取数据，- 使 cat 不忽略 标准输入echo "hello" | cat 1.txt -# 1.txt# hello# world# hello 同样的，grep 的情况如下： 还有一些命令不能像 grep 和 cat 这样，支持 标准输入。比如 kill , rm , cp , echo 等 命令 就 不支持 标准输入。而往往我们会有下面这种需求：123# 查找进程号，通过管道传给 kill 杀死该进程# 以下命令无法执行，因为 kill 不支持 标准输入ps -ef | grep "weblogic.Server" | awk '&#123;print $2&#125;' | kill -9 这些 不支持标准输入的命令 想要 从标准输入中获取数据，就需要 xargs 命令做转换：12# 以下命令可以正常执行ps -ef | grep "weblogic.Server" | awk '&#123;print $2&#125;' | xargs -I &#123;&#125; kill -9 &#123;&#125; 2 xargs 常用选项-I 选项 (小写的 i)用法：123xargs -I &#123;&#125; commandX &#123;&#125;# 或者xargs -I&#123;&#125; commandX &#123;&#125; {} 表示从 标准输入 传入的数据，也可以换成别的字符， 如 %，a，b，c 等等。 举例，获取 1.txt 文件的最后两行，并以 行内容.txt 为文件名 创建两个文件：1tail -2 1.txt | xargs -I&#123;&#125; touch &#123;&#125;.txt -p 选项p 的含义 是 prompt 。执行命令前会输出 命令，并需要确认才能执行(输入y执行，输入其他字符不执行)。123tail -2 1.txt | xargs -p -I&#123;&#125; touch &#123;&#125;.txt# touch hello.txt ?...n# touch world.txt ?...n -d 选项d 的含义 是 delimiter(分隔符) 。xargs 命令 默认的 分隔符是 空白字符(空格，tab，换行)， 可以用 -d 选项自定义分隔符。 例如：123456789101112echo "aa|bb|cc|dd" | xargs echo# aa|bb|cc|ddecho "aa|bb|cc|dd" | xargs -d"|" echo# aa bb cc dd# -n1 选项的含义是 每个字段作为 一行处理echo "aa|bb|cc|dd" | xargs -d"|" -n1 echo# aa# bb# cc# dd -n 选项用法：123xargs -n数字 commandX# 或者xargs -n 数字 commandX -n1 选项的含义是 每个字段作为 一行处理，-n2 选项的含义是 每2个字段作为 一行处理，-n3 选项的含义是 每3个字段作为 一行处理，… 看一个例子：1234567891011121314151617181920212223242526272829303132333435363738394041cat abc# aa# bb# cc dd# ee ff ggcat abc | xargs echo# aa bb cc dd ee ff ggcat abc | xargs -I&#123;&#125; echo &#123;&#125;# aa# bb# cc dd# ee ff ggcat abc | xargs -n1 echo# aa# bb# cc# dd# ee# ff# ggcat abc | xargs -n2 echo# aa bb# cc dd# ee ff# ggcat abc | xargs -n3 echo# aa bb cc# dd ee ff# gg# -n 选项 和 -I 选项一起用，-n 选项会失效cat abc | xargs -n1 -I&#123;&#125; echo &#123;&#125;# aa# bb# cc dd# ee ff gg 注意： -n 选项 和 -I 选项 一起用，-n 选项会失效。 参考1、 xargs-wiki 2、 xargs命令详解，xargs与管道的区别 3、Linux and Unix xargs command tutorial]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 解析文件并插入 Oracle 数据库]]></title>
    <url>%2F2019%2F01%2F08%2FLinux-%E8%A7%A3%E6%9E%90%E6%96%87%E4%BB%B6%E5%B9%B6%E6%8F%92%E5%85%A5-Oracle-%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[1 场景1 台 阿里的云主机 Ubuntu16.04， 安装 Oracle 数据库 客户端 12c R2。1 台 华为的云主机 CentOS7， 安装 Oracle 数据库 12c R2。 目标： Ubuntu 解析文本文件，并 利用sqlplus 插入 远程Oracle数据库中。 文本文件 batch.dat:12341005|cherry|48|F|181007|jason|48|M|181008|嘉宣|20|F|11008|嘉文|20|F|1 数据库表 students 表结构：123456789SQL&gt; desc students;Name Type Nullable Default Comments-------- ------------ -------- ------- --------STU_ID VARCHAR2(4) Y STU_NAME VARCHAR2(50) Y AGE NUMBER(3) Y SEX CHAR(1) Y GRADE NUMBER(2) Y 2 实现tinsert.sh 文件：1234567891011#!/bin/bash./tparse.sh;sqlplus -S system/123@114.115.165.64:1521/orcl&lt;&lt;EOF@sql2.txtcommit;exitEOFif [[ $? -eq 0 ]]; then echo "successfully!"fi tparse.sh 文件：123456789101112131415161718192021222324252627#!/bin/bashiconv -f gbk -t utf-8 batch.dat &gt; tbatch.dat;count=0;# 在最后一行添加一行空行, 解决最后一行读取不到的问题sed -i '$a\ ' tbatch.dat;# 删除所有空行sed -i '/^\s*$/d' tbatch.dat;while read linedo echo $line; query=`echo $line | awk -F"|" '&#123; printf("'\''%s'\'','\''%s'\'','\''%s'\'','\''%s'\'','\''%s'\''",$1,$2,$3,$4,$5);&#125;'`; statement=`echo "insert into students(stu_id,stu_name,age,sex,grade) values($query);"`; if [[ count -eq 0 ]]; then echo $statement &gt; sql.txt; else echo $statement &gt;&gt; sql.txt; fi count=$((count+1)); #echo $count; #echo $statement;done &lt; tbatch.datcat sql.txt &gt; sql2.txt# 去除Windows中的换行符 ^M# cat -A sql.txt | sed 's/\^M//g' &gt; sql2.txt# sed -i 's/\$//g' sql2.txt 执行：1./tinsert.sh Windows 打开 PLSQL 连接 远程数据库，查询插入结果：]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 处理中文乱码文件]]></title>
    <url>%2F2019%2F01%2F08%2FLinux-%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1 问题描述在 Windows10 系统中创建一个 包含中文的 文本文件 test.txt，把 test.txt 上传(通过 FlashFXP 5 或者 Xftp6 上传)到 Linux (Ubuntu16.04)，vim/cat/nl 打开 test.txt 文件乱码。 2 问题排查Win10 系统编码方式：12chcp# 936 代码页936 表示 gbk 编码。代码页65001 表示UTF-8 编码。 Ubuntu16.04 系统编码方式：12locale# LANG=zh_CN.UTF-8 2.1 解决方式一在 linux 系统中，对文件进行编码转换：12# convert text from one character encoding to another iconv -f gbk -t utf-8 test.txt &gt; target.txt -f from-encoding 表示 原编码格式；-t to-encoding 表示 目的编码格式 target.txt 文件内容 显示中文正常。 2.2 解决方式二(无效)修改 Win10 系统编码方式为 UTF-8：通过注册表编辑器 ( cmd -&gt; regedit ) 修改1HKEY_CURRENT_USER\Console\%SystemRoot%_system32_cmd.exe 的 codepage 数值 为 65001 (十进制) 。重启计算机。然后重新上传文件到 Linux。亲测这个方式 无法解决中文乱码问题。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 数据库乱码问题解决]]></title>
    <url>%2F2019%2F01%2F08%2FOracle-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[1 问题描述下图中，红色 的线表示乱码，绿色 的线表示正常。 3 种方式 插入和查询数据 乱码情况如下：1、 数据库服务器 本地 用 sqlplus 登录，插入中文数据，查询结果 乱码 ！2、 Ubuntu 客户端 用 sqlplus 登录，插入中文数据，查询结果 乱码 ！3、 Windows 客户端 用 PL/SQL 登录，插入中文数据，查询结果 正常。但是用前两种方式查询 此方式插入的中文数据，仍然是乱码。 让我困惑的是，方式 3 正常，而 方式 1 乱码。 2 问题排查2.1 服务端 sqlplus 插入中文乱码服务端 (CentOS) 的 字符集：12locale# LANG=zh_CN.UTF-8 zh 表示中文，CN 表示大陆地区， UTF-8 表示编码方式。 数据库的 字符集：1234567891011--Oracle数据库字符集 (主要)select userenv('language') from dual;--SIMPLIFIED CHINESE_CHINA.UTF8--数据库字符集 (参考)SELECT * FROM NLS_DATABASE_PARAMETERS;--AMERICAN.UTF8--实例字符集 (参考)SELECT * FROM NLS_INSTANCE_PARAMETERS;--AMERICAN 系统环境 和 数据库环境 都是 UTF-8 编码，为什么插入数据库的中文就乱码了呢？ 原因：客户端 (通过localhost连接数据库，CentOS本身是服务端，也是客户端) NLS_LANG 环境变量 没有设置 ！ sqlplus 把 中文发给 Oracle 数据库时，会通过 NLS_LANG 环境变量 告诉数据库 (中文)字符串是以什么编码格式编码的，Oracle数据库有它自己的编码表(多个)，它会根据编码表对编码进行翻译和转码。最后，将转码之后的编码 存放到Oracle数据库中去。 设置一下环境变量，乱码问题解决：1export NLS_LANG='SIMPLIFIED CHINESE_CHINA.UTF8' 此时，通过 Windows PL/SQL 查询 CentOS 本地插入的 中文数据，也是正常的。 2.2 远程客户端 sqlplus 插入中文乱码远程客户端 Ubuntu 系统的编码：12locale# LANG=zh_CN.UTF-8 同样的问题，Ubuntu 也没有 设置 NLS_LANG 环境变量。因此导致了乱码。 设置 NLS_LANG 环境变量 字符集为 UTF-8 ：1export NLS_LANG='SIMPLIFIED CHINESE_CHINA.UTF8' 远程客户端 sqlplus 插入中文乱码 问题解决。此时，通过 Windows PL/SQL 查询 Ubuntu 客户端插入的 中文数据，也是正常的。 3 总结数据库出现乱码时，应该逐一检查下列信息： 服务端数据库字符集：select userenv(‘language’) from dual 客户端操作系统字符集：locale 客户端操作系统 环境变量： NLS_LANG 应该将 三者 的字符集统一。 参考 1、 使用sqlplus执行sql时，有中文有乱码 2、 Oracle数据库中文乱码问题 3、 Oracle 修改字符集—AL32UTF8 转换成UTF8字符集]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 安装 Oracle Database 客户端]]></title>
    <url>%2F2019%2F01%2F07%2FLinux-%E5%AE%89%E8%A3%85-Oracle-Database-%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[Oracle DataBase Client 版本和远程数据库的版本都是 12.2.0.1.0。 1 下载 Instant Client Package (Basic 和 SQL*Plus)下载地址 下载两个压缩包： instantclient-basic-linux.x64-12.2.0.1.0.zip instantclient-sqlplus-linux.x64-12.2.0.1.0.zip 2 解压12unzip instantclient-basic-linux.x64-12.2.0.1.0.zipunzip instantclient-sqlplus-linux.x64-12.2.0.1.0.zip 12sudo mkdir /opt/instantclientmv instantclient_12_2/* /opt/instantclient 3 设置环境变量把以下环境变量加入 ~/.bashrc文件中 (或者 在 /etc/profile.d 目录下新建一个文件)：1234export ORACLE_HOME=/opt/instantclientexport LD_LIBRARY_PATH=/opt/instantclientexport TNS_ADMIN=/opt/instantclientexport PATH=$PATH:/opt/instantclient 4 连接 Oracle 数据库1sqlplus system/123@114.115.165.64:1521/orcl]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 安装 Oracle Database 12c R2]]></title>
    <url>%2F2019%2F01%2F03%2FCentOS7-%E5%AE%89%E8%A3%85-Oracle-Database-12c-R2%2F</url>
    <content type="text"><![CDATA[1 了解 Oracle DatabaseOracle 数据库的版本 [wiki]：1979年夏，Oracle第二版发布。1998年9月，Oracle 8i，该版本开始对 Internet 的支持。2001年6月，Oracle 9i。2003年9月，Oracle 10g，加入了 网格(grid)计算 的功能。2007年7月，Oracle 11g。2013年6月，Oracle发布了 12c Release 1，为 云(cloud)计算 设计。引入 CDB(Container Database,数据库容器)与 PDB(Pluggable Database,可插拔数据库)的新特性。2016年9月，Oracle Database 12c Release 2，本文安装的版本。2018年2月，Oracle Database 18c，Polymorphic(多态的) Table Functions, Active Directory Integration。 2 安装 Oracle Database 12c Release 2前言：在华为买了一个云主机，专门装 Oracle 数据库用的。买来时装的是 Ubuntu16.04，但是 Oracle Database 不直接支持 Ubuntu。于是换成 Oracle Linux 7，OL7安装数据库(Oracle Installation Prerequisites可以自动配置)方便，可是安装图形化界面时 yum 源改了几次都不行。于是换成 RedHat 6，Fedora 26，CoreOS 还是出错。最后 装了 n 次 CentOS 7 ，在 CentOS 7 上装了 n 次 数据库， 建了 n 次 库，终于成功了。 这一过程整整花了10天，难过(ಥ﹏ಥ)。。。。linux包管理工具一直都用apt，这次接触到了rpm ，yum，dnf。还有一些额外收获。 下面进入正题。 2.0 CentOS 7 硬件配置情况配置swap：123dd if=/dev/zero of=/home/swap bs=1024 count=2097152 #bs为单位，count为设置的大小2048*1024mkswap /home/swap #格式化交换文件swapon /home/swap #立即启用交换分区文件, 要停止使用新创建的swap文件,只要执行 swapoff/home/swap命令即可. 为了避免 swap 分区在重启后失效，vim /etc/fstab 添加一行:1/home/swap swap swap defaults 0 0 查看内存分配情况:123456free -m# 结果 total used free shared buff/cache availableMem: 3789 1065 218 963 2504 1422Swap: 2047 8 2039 配置 2G 的 swap 以后的机器： 2.1 下载Oracle Database 12c Release 2 (12.2.0.1.0)下载先下载到本地(Window10)，然后用 Xshell 6 ssh 连接 CentOS7 ，点击 “新建文件传输(Xftp)” 可以把下载好的文件上传到 CentOS7 上。 上传完了，给 CentOS7 安装图形界面：安装X Window System1yum groupinstall "X Window System" 安装图形桌面 GNOME(GNOME Desktop)1yum groupinstall "GNOME Desktop" Chrome 打开 华为云主机控制台 页面，点击 “远程登录” ，登录后验证图形桌面是否安装成功：1init 5 如果出现以下图形桌面表示安装成功： 注：虽然 Oracle 数据库支持 silent 安装(没有图形桌面也能安装)，但考虑到 silent 安装 配置 rsp 文件有些繁琐，不如 先安装图形桌面，然后直接安装 Oracle数据库，比较方便。 2.2 安装 Oracle 数据库安装方法只用三步: 解压安装文件 配置安装必要条件 安装 2.2.1 解压数据库安装文件1unzip linuxx64_12201_database.zip 2.2.2 Oracle Installation Prerequisites如果 Linux 版本是 Oracle Linux 的话，可以自动设置(Automatic Setup)，两行命令就把 安装必要条件 全部设置好了。但是我的 Linux 版本是 CentOS7，只能手动设置(Manual Setup)： 0、 配置hostname (参考 如下两张图，一张是 CentOS7，一张是 redhat6.4)： 1、vim /etc/sysctl.conf 添加下列内容：1234567891011121314fs.file-max = 6815744kernel.sem = 250 32000 100 128kernel.shmmni = 4096kernel.shmall = 1073741824kernel.shmmax = 4398046511104kernel.panic_on_oops = 1net.core.rmem_default = 262144net.core.rmem_max = 4194304net.core.wmem_default = 262144net.core.wmem_max = 1048576net.ipv4.conf.all.rp_filter = 2net.ipv4.conf.default.rp_filter = 2fs.aio-max-nr = 1048576net.ipv4.ip_local_port_range = 9000 65500 运行下列命令改变内核参数：1/sbin/sysctl -p 2、 vim /etc/security/limits.d/oracle-database-server-12cR2-preinstall.conf 添加下列内容：12345678oracle soft nofile 1024oracle hard nofile 65536oracle soft nproc 16384oracle hard nproc 16384oracle soft stack 10240oracle hard stack 32768oracle hard memlock 134217728oracle soft memlock 134217728 上面的内容在 /etc/security/limits.conf 中也添加一遍。 3、安装依赖包：12345678910111213141516171819202122232425262728293031323334353637383940414243yum install binutils -yyum install compat-libcap1 -yyum install compat-libstdc++-33 -yyum install compat-libstdc++-33.i686 -yyum install glibc -yyum install glibc.i686 -yyum install glibc-devel -yyum install glibc-devel.i686 -yyum install ksh -yyum install libaio -yyum install libaio.i686 -yyum install libaio-devel -yyum install libaio-devel.i686 -yyum install libX11 -yyum install libX11.i686 -yyum install libXau -yyum install libXau.i686 -yyum install libXi -yyum install libXi.i686 -yyum install libXtst -yyum install libXtst.i686 -yyum install libgcc -yyum install libgcc.i686 -yyum install libstdc++ -yyum install libstdc++.i686 -yyum install libstdc++-devel -yyum install libstdc++-devel.i686 -yyum install libxcb -yyum install libxcb.i686 -yyum install make -yyum install nfs-utils -yyum install net-tools -yyum install smartmontools -yyum install sysstat -yyum install unixODBC -yyum install unixODBC-devel -yyum install gcc -yyum install gcc-c++ -yyum install libXext -yyum install libXext.i686 -yyum install zlib-devel -yyum install zlib-devel.i686 -y 4、 创建用户组合用户：1234567891011121314groupadd -g 54321 oinstallgroupadd -g 54322 dbagroupadd -g 54323 opergroupadd -g 54324 backupdbagroupadd -g 54325 dgdbagroupadd -g 54326 kmdbagroupadd -g 54327 asmdbagroupadd -g 54328 asmopergroupadd -g 54329 asmadmingroupadd -g 54330 racdba# 创建 oracle 用户useradd -u 54321 -g oinstall -G dba,oper oraclepasswd oracle 5、 vim /etc/selinux/config 修改 SELINUX 标识：1SELINUX=permissive 重启或执行以下命令 (root)：1setenforce Permissive 6、 关闭防火墙 (root)：12systemctl stop firewalldsystemctl disable firewalld 7、 创建安装目录：123mkdir -p /u01/app/oracle/product/12.2.0.1/db_1chown -R oracle:oinstall /u01chmod -R 775 /u01 8、 创建环境变量文件 setEnv.sh :1mkdir /home/oracle/scripts 123456789101112131415161718cat &gt; /home/oracle/scripts/setEnv.sh &lt;&lt;EOF# Oracle Settingsexport TMP=/tmpexport TMPDIR=\$TMPexport ORACLE_HOSTNAME=ol7-122.localdomainexport ORACLE_UNQNAME=cdb1export ORACLE_BASE=/u01/app/oracleexport ORACLE_HOME=\$ORACLE_BASE/product/12.2.0.1/db_1# export ORACLE_SID=cdb1export ORACLE_SID=orclexport PATH=/usr/sbin:/usr/local/bin:\$PATHexport PATH=\$ORACLE_HOME/bin:\$PATHexport LD_LIBRARY_PATH=\$ORACLE_HOME/lib:/lib:/usr/libexport CLASSPATH=\$ORACLE_HOME/jlib:\$ORACLE_HOME/rdbms/jlibEOF /home/oracle/.bash_profile 引用 setEnv.sh 文件：1echo ". /home/oracle/scripts/setEnv.sh" &gt;&gt; /home/oracle/.bash_profile 9、 Create a “start_all.sh” and “stop_all.sh” script that can be called from a startup/shutdown service.12345678910111213141516171819202122232425cat &gt; /home/oracle/scripts/start_all.sh &lt;&lt;EOF#!/bin/bash. /home/oracle/scripts/setEnv.shexport ORAENV_ASK=NO. oraenvexport ORAENV_ASK=YESdbstart \$ORACLE_HOMEEOFcat &gt; /home/oracle/scripts/stop_all.sh &lt;&lt;EOF#!/bin/bash. /home/oracle/scripts/setEnv.shexport ORAENV_ASK=NO. oraenvexport ORAENV_ASK=YESdbshut \$ORACLE_HOMEEOFchown -R oracle.oinstall /home/oracle/scriptschmod u+x /home/oracle/scripts/*.sh 2.2.3 安装打开 Chrome 浏览器，打开 华为云主机控制台，登录 oracle 用户，打开图形桌面：1init 5 进入 解压后的 database 目录，执行：1./runInstaller 接下来会出现一个 Oracle 安装窗口，建议每次点击next之前，阅读清楚选项的意义。 安装完成后，检查一下环境变量 $ORACLE_SID：12345#多数环境变量在 /home/oracle/scripts/setEnv.sh 文件中设置env | grep -i oracle# /etc/oratab中的 sid 一定要和 $ORACLE_SID 一致vim /etc/oratab 3 建库终端执行(需要图形桌面环境)：1dbca 弹出 Database Configuration Assistant 窗口，默认next 创建数据库。 4 登录4.1 登录配置listener.ora 和 tnsnames.ora 配置 的 实例名(或服务名) 应该和 $ORACLE_SID 一致。 配置 listener.ora [ listener.ora文件介绍 ]:1234vim /u01/app/oracle/product/12.2.0.1/db_1/network/admin/listener.ora#或者vim $ORACLE_HOME/network/admin/listener.ora 内容如下：12345678910111213141516LISTENER = (DESCRIPTION_LIST = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = mitre)(PORT = 1521)) ) )ADR_BASE_LISTENER = /u01/app/oracleSID_LIST_LISTENER = (SID_LIST = (SID_DESC = (GLOBAL_DBNAME = orcl) (SID_NAME = orcl) ) ) 配置 tnsnames.ora [ tnsnames.ora文件介绍 ]:1vim $ORACLE_HOME/network/admin/tnsnames.ora 内容如下：123456789ORCL = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = mitre)(PORT = 1521)) ) (CONNECT_DATA = (SERVICE_NAME = orcl) ) ) 查看 数据库的 监听器 状态：1234lsnrctl statuslsnrctl start #打开监听器lsnrctl stop #关闭 4.2 启动数据库 与 sqlplus 登录方法启动数据库：12345678910# 打开 sqlplussqlplus / as sysdba## 打开成功会 弹出 SQL&gt; 提示符# 启动数据库startup# 用户登录# conn 用户名/密码conn system/123 在数据库启动的情况下，可以直接在 shell 终端进行 用户登录 ： sqlplus 用户名/密码@ip:port/SID 1sqlplus system/123@localhost:1521/orcl 4.3 利用 PL/SQL 远程登录Chrome 打开 华为云主机控制台，添加 安全组-入规则 ，添加 1521 端口。安装 Oracle client 和 PL/SQL。登录结果： 参考1、 阿里云 CentOS7.4，静默安装Oracle11g2的教程 2、 CentOS7安装图形界面 3、 Oracle Database 12c Release 2 (12.2) Installation On Oracle Linux 7]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-革新]]></title>
    <url>%2F2018%2F12%2F31%2F2018-%E9%9D%A9%E6%96%B0%2F</url>
    <content type="text"><![CDATA[回顾回顾 2018 年的计划, Java, 关系型数据库, 工作, 博客, 英语, 算是基本完成计划. 2017 年的挫折, 在 2018 年初 还没有完全散去. 2018 年 3,4,5 月份 主要在做 毕业设计和毕业论文(RoboCup 3D: 动态规划实现最优决策, 消息解析-投票机制实现统一决策).5 月份 答辩获得 91 分, 拿到了优秀毕业生, 优秀毕业论文, 但是对找工作没有丝毫帮助… 4 月份奔波在校招中, 最终拿到两个 offer, 决定入职一份 Java Web 开发的工作. 5 月底拍了毕业照.然后和 忠青, double-K, 纤纤, 方雅 一起去爬了天柱山. 顺道 去了 忠青的高中–桐城高中, 勉成国器 的校训让人印象深刻. 6 月初报了驾校, 考过科目一和科目二. 科目三 7 月 4号考, 因为 7 月 3号要入职, 所以没有考科目三. 7 月 3 号在江阴入职, 到现在已经 5 个月了.工作之余, 一直在学习 Web 框架(Servlet, Spring MVC), 同时学习一些业务相关的知识. 9 月份, 去了 杭州 参加了 云栖大会, 看 阿里人 介绍了 自研的 RocketMQ, 和一些 容器化, 虚拟化技术. 十一 国庆节 放假, 去了上海一趟. 和上海的朋友相比, 我还是菜鸟. 总结2018 年一直很顺利, 一切都在向好的方向发展. 引用一句 哈佛 校训:Nobody can casually succeed, it comes from the thorough self-control and the will.谁也不能随随便便成功，它来自 彻底的自我管理 和 毅力。 2019 年计划1, 开源框架掌握一套:MevenSpring CloudSpring BootMYSQL–MyBatis消息中间件Redisgit, svnJenkins 2, 换一份工作, 技术氛围一定要好. 3, 英语: 实现基本无障碍阅读 英文技术文档. 4, 博客: 提高 博客 质量.(知识体系化, 内容深度, 可读性 等方面) 5, 管理学/心理学/文学 书籍阅读超过 2 本]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux防火墙操作]]></title>
    <url>%2F2018%2F12%2F25%2FUbuntu%E9%98%B2%E7%81%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[1 防火墙简介防火墙是位于 内部网 和 外部网(一般指公网) 之间的屏障，它按照系统管理员预先定义好的 规则 来控制数据包的进出。其作用是防止非法用户的进入。 防火墙的特性：1、内部网络和外部网络之间的所有网络数据流都必须经过防火墙2、只有符合安全策略的数据流才能通过防火墙3、应用层防火墙具备更细致的防护能力 2 UFW – UbuntuUFW (Uncomplicated Firewall，简单的防火墙) is a program for managing a netfilter firewall designed to be easy to use.It uses a command-line interface consisting of a small number of simple commands(由少量简单命令组成的命令行接口), and uses iptables for configuration. 2.1 ufw manulNAME ufw - program for managing a netfilter firewallDESCRIPTION This program is for managing a Linux firewall and aims to provide an easy to use interface for the user. 2.2 ufw 常用操作1、ufw [–dry-run] enable|disable|reload 打开|关闭|重启 防火墙–dry-run 试运行，显示结果并不执行 2、ufw [–dry-run] status [verbose|numbered] 查看状态 3、ufw supports connection rate limiting, which is useful for protecting against brute-force login attacks.When a limit rule is used, ufw will normally allow the connection but will deny connections if an IP address attempts to initiate 6 or more connections within 30 seconds.Typical usage is:ufw limit ssh/tcp如果同一个IP地址在30秒之内进行了6次及6次以上的连接，ufw将阻止 (deny) 该连接 更多操作参考:1man ufw 3 iptables – redhat查询防火墙状态:1service iptables status 12345678#停止防火墙:service iptables stop#启动防火墙:service iptables start#重启防火墙:service iptables restart 防火墙配置文件 /etc/sysconfig/iptables 。 CentOS 7 防火墙CentOS 7.0默认使用的是firewall作为防火墙 查看防火墙状态1firewall-cmd --state 停止firewall1systemctl stop firewalld.service 禁止firewall开机启动1systemctl disable firewalld.service]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle merger 语句]]></title>
    <url>%2F2018%2F12%2F11%2FOracle-merger-%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[Oracle 对 merge 语句的介绍：Use the MERGE statement to select rows from one or more sources for update or insertion into a table or view.You can specify conditions to determine whether to update or insert into the target table or view.This statement is a convenient way to combine multiple operations. 例如，数据库有两张表 new 和 old，现在把 new 里的数据合并(插入)到 old 里。如果是 old 表中 已存在的记录就 update，如果不存在就 insert 。 当我们有 insertOrUpdate 这种需求的时候，使用 merge 会很容易。 看一个例子：1234--客户表select * from test_cus1;--客户历史表select * from cus_his ; 结果： 把 test_cus1 表中的数据 插入 cus_his 表中:如果 cus_his 已经有此用户记录(根据 cus_id 确定唯一客户)，则更新 cus_his 表中此用户信息；如果 cus_his 没有此用户，则插入 cus_his 表中。 12345678910merge into cus_his his using test_cus1 t on( his.cus_id = t.cus_id) when matched then update set his.cus_age=t.cus_age, his.cus_name=t.cus_name when not matched then insert (his.cus_id,his.cus_name,his.cus_age) values(t.cus_id,t.cus_name,t.cus_age); 结果：结果分析：cus_his 中已经存在的 “蚂蚁大哥”(cus_id=1001) 被 更新，cus_his 中不存在的(cus_id=1002,1003,1004) 3 条用户记录 被插入 cus_his。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript笔记4-jQuery 和 AJAX]]></title>
    <url>%2F2018%2F11%2F29%2FJavaScript%E7%AC%94%E8%AE%B04-jQuery%E5%92%8CAJAX%2F</url>
    <content type="text"><![CDATA[1 jQuery 和 AJAX接着 上一节( JavaScript笔记3-AJAX )的例子 目录结构如下： 其他文件不变，增加 demojquery.jsp ，此文件实现的功能和 demo2.jsp 相同。( demojquery.jsp 只是用 jQuery 完成 demo2.jsp 的功能。) demojquery.jsp 内容 如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;%@page pageEncoding="utf-8" contentType="text/html; charset=utf-8"%&gt;&lt;html&gt;&lt;head&gt; &lt;script type="text/javascript" src="jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // $()页面加载完毕后执行 $(function()&#123; $("#szid").click(function()&#123; var url=encodeURI("http://localhost:8080/ajax01/demo1.do"); $.ajax(&#123; url:url, type:"POST", success:function(result)&#123; // result就是服务器返回的内容 等价于 xhr.responseText $("#msg").html(result); &#125; &#125;); &#125;) &#125;) // 检查用户名是否可用 function checkName()&#123; var username=$("#username").val(); //console.log(username); $("#name_msg").html("检查中.....");// var url=encodeURI("http://localhost:8080/ajax01/check.do?name="+username); var url=encodeURI("http://localhost:8080/ajax01/check.do"); $.ajax(&#123; type:"POST", url:url, data:&#123;"name":username&#125;, success:function(result)&#123; $("#name_msg").html(result); &#125; &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body style="font-size: 30px;"&gt; &lt;a href="#" id="szid"&gt;查看上证指数&lt;/a&gt; &lt;span id="msg"&gt;&lt;/span&gt; &lt;hr /&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;股市新闻&lt;/td&gt; &lt;td&gt;时间&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;新一代股神mitre&lt;/td&gt; &lt;td&gt;2018-11-22&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;大海你真美&lt;/td&gt; &lt;td&gt;2018-11-21&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type="text" id="username" onblur="checkName();" /&gt; &lt;span id="name_msg"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 常用的 ajax 配置参数：12345678910$.ajax(&#123; url: 请求地址, type: 请求类型(POST|GET), data: 提交的数据, async: 同步或异步(true)处理, dataType: 预期服务器返回的数据类型, success: 成功回调函数, error: 失败回调函数, beforeSend: 请求发送前回调函数&#125;); 2 servlet 返回 JSON实现 网页列表显示 功能。 NoteListServlet2.java ，这个 servlet 返回的字符串是 由 JSONArray 类型 toString 得到的。NoteListServlet2 返回的本质是一个 JSON数组。 (NoteListServlet.java 仅做参考，内容和NoteListServlet2.java基本一样。 它返回的字符串是 由 JSONObject 类型 toString 得到的。NoteListServlet 返回的本质是一个 JSON对象。) 12345678910111213141516171819202122232425262728293031323334353637package cn.mitrecx.servlet;public class NoteListServlet2 extends HttpServlet &#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=utf-8"); //将笔记以 JSON 格式输出 /* * 返回 一个 json 对象 * json: &#123;id:"01",name:"JavaScript学习笔记"&#125; */ Note note = new Note(); note.setId("01"); note.setName("JavaScript学习笔记"); JSONObject jsonObject=JSONObject.fromObject(note); String jsonObjectString=jsonObject.toString(); //System.out.println(jsonObjectString); PrintWriter out=response.getWriter(); /* * 返回 json 数组 * [&#123;"id":"01","name":"JavaScript学习笔记"&#125;,&#123;"id":"02","name":"JSON作为返回数据类型"&#125;] */ Note note2=new Note(); note2.setId("02"); note2.setName("JSON作为返回数据类型"); List&lt;Note&gt; list=new ArrayList&lt;Note&gt;(); list.add(note); list.add(note2); JSONArray jsonArray=JSONArray.fromObject(list); String jsonArrayString=jsonArray.toString(); //out.println(jsonObjectString); //NoteListServlet 返回 out.println(jsonArrayString); //NoteListServlet2 返回 out.flush(); out.close(); &#125;&#125; web.xml12345678910111213141516&lt;servlet&gt; &lt;servlet-name&gt;ajax-json&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.mitrecx.servlet.NoteListServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ajax-json&lt;/servlet-name&gt; &lt;url-pattern&gt;/ajax.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet&gt; &lt;servlet-name&gt;ajax-json2&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.mitrecx.servlet.NoteListServlet2&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ajax-json2&lt;/servlet-name&gt; &lt;url-pattern&gt;/ajax2.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; demo.html ，这才是重点。重点是 AJAX请求返回的数据的处理。JSON 和 JSON数组 ，dataType 都是 JSON。但是JSON对象要按对象处理，数组要按数组处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8" &gt; &lt;script src="jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; $("#noteListBtn").click(function()&#123; $("#noteList").empty(); $.ajax(&#123; type: "post", url: "http://localhost:8080/ajax-json/ajax.do", dataType: "json", success: function(result)&#123; // Object.keys(result).length 获取JSON对象的长度 console.log(Object.keys(result).length); var id=result.id; var name=result.name; // 拼成 dom对象 var dom_li="&lt;li&gt;"+name+"&lt;/li&gt;"; var $li=$(dom_li);//转为jQuery对象 //$li.data("id",id); $("#noteList").append($li); &#125; &#125;); &#125;); &#125;) &lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; $("#noteListBtn2").click(function()&#123; $("#noteList2").empty(); $.ajax(&#123; type: "post", url: "http://localhost:8080/ajax-json/ajax2.do", dataType: "json", success: function(result)&#123; // 获取数组(json数组)的长度 result.length console.log(result.length); //result 就是 服务器返回的json 串 for(var i=0; i&lt;result.length; ++i)&#123; console.log(i); var id=result[i].id; var name=result[i].name; // 拼成 dom对象 var dom_li="&lt;li&gt;"+name+"&lt;/li&gt;"; var $li=$(dom_li);//转为jQuery对象 //$li.data("id",id); $("#noteList2").append($li); &#125; &#125; &#125;); &#125;); &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id="noteListBtn" type="button" value="显示 NoteList"/&gt; &lt;hr/&gt; &lt;ul id="noteList"&gt; &lt;/ul&gt;&lt;br/&gt; &lt;input id="noteListBtn2" type="button" value="显示 NoteList对象数组"/&gt; &lt;ul id="noteList2"&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 结果： 3 SpringMVC 返回 JSON开发步骤：1、 DispatchServlet2、 HandlerMapping3、 Controller (处理完返回一些数据)4、 调用 spring 自带包jackson 将 Controller 返回结果转成 json 输出 Controller:12345678910111213141516171819202122232425262728package cn.mitrecx.controller;import java.util.ArrayList;import java.util.List;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import cn.mitrecx.domain.Note;@Controllerpublic class NoteListController &#123; @RequestMapping("/springjson.do") @ResponseBody //使 返回结果 转为 json. 有此标记就不会走ViewResolver了 public List&lt;Note&gt; execute() &#123; List&lt;Note&gt; list=new ArrayList&lt;Note&gt;(); Note note1=new Note("01","SpringMVC 返回json"); list.add(note1); Note note2=new Note("02","ajax是一种前端技术"); list.add(note2); return list;//直接return，由Jackson 自动转成json &#125; @RequestMapping("/springjson2.do") @ResponseBody public Note show() &#123; Note note=new Note("22","json是一种数据格式"); //domain类，List，Map都能转 JSON return note; &#125;&#125; domain类:123456789101112131415161718192021222324package cn.mitrecx.domain;import java.io.Serializable;public class Note implements Serializable&#123; private String id; private String name; public Note() &#123; &#125; public Note(String id,String name) &#123; this.id=id; this.name=name; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; web.xml123456789101112&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; applicationContext:123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:util="http://www.springframework.org/schema/util" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd"&gt; &lt;!-- HandlerMapping --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- controller --&gt; &lt;context:component-scan base-package="cn.mitrecx.controller"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; demo.xml 和 上一例一样，只要改一下URL。 结果： ajax 学习 完！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle-学习6-存储过程]]></title>
    <url>%2F2018%2F11%2F27%2FOracle%E5%AD%A6%E4%B9%A06-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1 Oracle存储过程语法1234567CREATE [OR REPLACE] PROCEDURE 存储过程名[(参数[IN|OUT|IN OUT] 数据类型...)]&#123;AS|IS&#125;[变量声明块]BEGIN可执行部分;[EXCEPTION错误处理部分]END [过程名]; 其中：可选 关键字OR REPLACE 表示如果存储过程已经存在，则用新的存储过程覆盖，通常用于存储过程的重建。 参数 部分用于定义多个参数(如果没有参数，就可以省略)。参数有三种形式：IN、OUT 和 IN OUT。IN 按值传递，它 不允许 在存储过程中被重新赋值，IN 参数被赋值会报错！ 如果没有指明参数的形式，则默认为IN。参数的数据类型 只指明类型名即可，不需要指定宽度。指定参数宽度会报错！ 参数的宽度由外部调用者决定。 关键字 AS 也可以写成 IS，在此定义 局部变量。可以理解为pl/sql的 declare关键字，用于声明变量。 注：部分例子没有实际用处，只是为了说明存储过程的使用。 1.1 利用存储过程循环插入示例：插入100条数据到test_cus表中12345678910111213141516create or replace procedure loop_insertas cus_code varchar2(10);begin for i in 1..100 loop cus_code := '1'||lpad(i,3,0); insert into test_cus(cus_id,cus_name,cus_age) values(cus_code,'存储过程',100); end loop; commit;end;--执行begin loop_insert();end; 结果：1234561001 存储过程 1001002 存储过程 1001003 存储过程 1001004 存储过程 1001005 存储过程 100... 注：“ := “ 表示 赋值语句“ = “ 判断是否相等“ :variableName “ 表示 变量绑定 关于 for 循环 1.2 存储过程参数以下存储过程可以正常执行：123456789101112131415create or replace procedure sp_test5( --不能指定参数的宽度 para1 in out varchar2)asbeginpara1 :='1234567890';end;--调用declare p1 varchar2(10):='a';begin sp_test5(p1);end; 如果把 p1 定义改为 varchar(1) :1declare p1 varchar2(10):='a'; 则会报错：字符串缓冲区太小 以下存储过程 能正常运行。但如果去掉注释，则会报错，原因是 不能给 IN 参数赋值。1234567891011121314151617181920212223create or replace procedure sp_test4( para1 varchar2, para2 out varchar2, para3 in out varchar2)as v_name varchar2(20);begin --para1 := 'aaa'; --para2 := 'bbb'; v_name :=' Oracle'; para3 := '你好'; dbms_output.put_line('输出:'||para3||v_name);end sp_test4;--调用declare p1 varchar2(20) := 'hello1';p2 varchar2(20) := 'hello2';p3 varchar2(20) := 'hello3';begin sp_test4(p1,p2,p3);end; 结果： 再看一个例子：1234567891011121314151617181920212223242526272829303132create table test_user( user_id int, user_Name varchar2(100), user_Passwd varchar2(100), user_Age int)insert into test_user values(1,'jack','xxx',23);insert into test_user values(2,'rose','xxx',21);insert into test_user values(3,'kiki','xxx',33);insert into test_user values(4,'cherry','xxx',24);commit;--存储过程：用于更改用户年龄create or replace procedure sp_update_age( uname in varchar2, age in int)asbegin update test_user set user_age=age where user_name=uname; commit;end sp_update_age;--调用begin sp_update_age('jack',100);end; 结果：12341 jack xxx 1002 rose xxx 213 kiki xxx 334 cherry xxx 24 2 控制语句2.1 if else利用 if else 实现求一个数的绝对值：12345678910111213141516171819202122232425create or replace procedure sp_test2(x in out number)isbegin if x&lt;0 then begin x:= 0-x; end; elsif x&gt;0 then --注意 elsif begin x:= x; end; else begin x:= 0; end; end if;end sp_test2;--调用 sp_test2declare num number;begin num:= -106; sp_test2(num); dbms_output.put_line( 'num = ' || num );end; 结果：1num = 106 2.2 for for 循环示例：123456789101112131415declarex number := 100;begin for i in 1..5 loop if mod(i,2)=0 then dbms_output.put_line('i: '||i||' is even.'); else dbms_output.put_line('i: '||i||' is odd.'); end if; x := x+1; dbms_output.put_line('x: '||x); dbms_output.put_line(''); end loop; commit;end; 结果：1234567891011121314i: 1 is odd.x: 101i: 2 is even.x: 102i: 3 is odd.x: 103i: 4 is even.x: 104i: 5 is odd.x: 105 2.3 whilewhile 示例：12345678910111213141516create or replace procedure sp_test3( i in out number)asbegin while i&lt;=100 loop begin i:=i+10; end; end loop;end sp_test3;--调用 sp_test3declare t3 number := 2;begin sp_test3(t3); dbms_output.put_line(t3);end; 结果：1102]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle-学习5-序列]]></title>
    <url>%2F2018%2F11%2F26%2FOracle%E5%AD%A6%E4%B9%A05-%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[创建序列 sequence1234567891011CREATE SEQUENCE 序列名 [INCREMENT BY n] [START WITH n] [&#123;MAXVALUE/ MINVALUE n| NOMAXVALUE&#125;] [&#123;CYCLE|NOCYCLE&#125;] [&#123;CACHE n| NOCACHE&#125;]; 1、Increment by n ， 步长为n默认为 1 2、Stat with n ， 开始值为n默认为 1 3、Maxvalue n ， 最大值Minvalue n ， 最小值NOMAXVALUE ， 无最值(最大：10的27次方，最小：-10的26次方)默认 无最值 4、CYCLE 循环，递增或递减过最值时，回到起始值循环NOCYCLE 非循环，递增或递减过最值时，报错。默认 非循环 5、CACHE n 缓冲， 定义存放序列的内存块的大小。默认为 20 访问序列访问序列的下一个值：1select 序列名.nextVal from dual; 访问序列当前值：1select 序列名.currVal from dual; 注：新创建的 序列， 只能 在nextVal一次之后，才能使用currVal。 修改序列Oracle 无法直接修改序列的 起始值改变序列的初始值 只能通过 先删除序列 再重建序列来实现 修改序列的步长为 1000 ：12alter sequence 序列名increment by 1000; 最值，循环，缓冲 都能被修改。值得注意的是，循环 和 缓冲 必须满足下面不等式：1cache &lt; CEIL(maxValue-minValue)/ABS(increment) 如果想要把序列的当前值 +1000，可以先修改步长为1000，再nextVal，再把步长改为原值。 删除序列1drop sequence 序列名; 删除之后，序列将不能被引用。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle-学习4-高级查询]]></title>
    <url>%2F2018%2F11%2F25%2FOracle%E5%AD%A6%E4%B9%A04-%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[Oracle 高级查询： 子查询(不做说明) 分页查询 decode 函数 排序函数 高级分组 集合 1 分页查询 分页查询的思想：”勤拿少取” 分页查询步骤：1、 排序(非必要)2、 编号3、 取范围 例如，对 emp表 进行分页查询。emp表 有如下记录： 1.1 排序按照 入职日期 排序： 123select * from emp order by hire_date 1.2 编号123456--先排序，再编号select rownum rn,e.* from ( select * from emp order by hire_date) e 错误做法：1234--排序与编号同时进行select rownum rn,emp.* from emp order by hire_date 错误做法的结果：由上图可见，rownum 不能和 order by 写在一个查询语句中。 1.3 取范围假设当前是第 n 页， 一页的条数为 pageSize， 则页数的范围：start: ( n-1 ) * pageSize + 1end: pageSize * n 12345678910111213141516--pageSize 取 6select * from ( select rownum rn,e.* from( select * from emp order by hire_date) e) where rn between 1 and 6;select * from ( select rownum rn,e.* from( select * from emp order by hire_date) e) where rn between 7 and 12; 2 decode 函数 DECODE函数 的作用和 java 中的 switch-case 一样。 计算员工的奖金：如果部门号为 01，奖金为 [薪水*2]。如果部门号为 02，奖金为 [薪水*10]。其他部门，奖金额等于薪水值。12345select emp.*,decode(department_no, '01',salary*2, '02',salary*10, salary) bonusfrom emp; Oracle 还提供了 case-when-then-else-end 语句，功能和 DECODE 类似：1234567891011121314151617select emp.*, case department_no when '01' then salary*2 when '02' then salary*10 else salary end bonusfrom emp;--select app.*, case when app.channel_type='01' then '网上银行' when app.channel_type='02' then '手机银行' else '其他渠道' end 渠道from loan_app_info app DECODE 与CASE WHEN 的比较: DECODE 只有Oracle 才有，其它数据库不支持。CASE WHEN的用法， Oracle、SQL Server、 MySQL 都支持。 DECODE 只能用做相等判断，但是可以配合sign函数进行大于，小于，等于的判断。CASE when可用于 =，&gt;=，&lt;，&lt;=，&lt;&gt;，is null，is not null 等的判断。 DECODE 使用其来比较简洁，CASE 虽然复杂但更为灵活。 在decode中，null和null是相等的。在case when中，只能用is null来判断。 3 排序函数 3.1 普通排序对 emp表 按工资排序：12345select e.*, rownum as 序号 from (select * from emp where salary is not null order by salary desc) e; 3.2 组内排序row_number() over() 函数， 对 emp表按 部门编号 分组，再组内排序：1234--row_number 生成组内 唯一且连续的编号select emp.*, row_number() over(partition by department_no order by salary desc) rkfrom empwhere salary is not null; 123456789--rank over,s 组内不连续且不唯一的编号select emp.*, rank() over(partition by department_no order by salary desc) rkfrom empwhere salary is not null;--dense_rank over, 组内连续但不唯一的编号select emp.*, dense_rank() over(partition by department_no order by salary desc) rkfrom empwhere salary is not null; 4 高级分组方法 高级分组方法：rollup,grouuping sets(重点), cube 建立一张营业额表：1234567create table SALES_TAB( year_id NUMBER not null, month_id NUMBER not null, day_id NUMBER not null, sales_value NUMBER(10,2) not null) 插入 1000 条数据，数据是每天的营业额(每天可能有多笔营业收入): 4.1 group by 分组group by 是最基础，也是最重要的分组方法。计算每天的营业额：1234select year_id,month_id,day_id,sum(sales_value) from sales_tab group by year_id, month_id,day_id order by year_id,month_id,day_id; 4.2 group by rollup 分组按 年月日 分组，再按 年月 分组，再按 年 分组，总的一组。(一共4个分组) ：1234select year_id,month_id,day_id,sum(sales_value) from sales_tab group by rollup( year_id, month_id,day_id) order by year_id,month_id,day_id; 输出结果片段：注意：rollup 内部的字段顺序决定了 分组结果。例如 rollup(1,2,3), 分组结果：123， 12， 1，总表一组 4.3 group by grouping sets 分组grouping sets 很灵活，分组结果可以自己指定。按 年月日 分组，再按 年 分组：1234567select year_id,month_id,day_id,sum(sales_value)from sales_tabgroup by grouping sets(( year_id, month_id，day_id), (year_id) )order by year_id,month_id,day_id; 4.4 group by cube 分组cube(年,月,日) 分成如下 8 种组合：年月日，年月，年，年日，月日，月，日，总。1234select year_id,month_id,day_id,sum(sales_value) from sales_tab group by cube( year_id, month_id,day_id) order by year_id,month_id,day_id; 5 集合 集合运算符：union/union all 并集intersect 交集minus 差集 union求并集，公共部分只 包含一次 union all求集并，公共部分 包含二次 intersect求交集，只有公共部分 minus求差集，例如集合A减集合B]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle-学习3-关联查询]]></title>
    <url>%2F2018%2F11%2F24%2FOracle%E5%AD%A6%E4%B9%A03-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[Oracle数据库 是关系型数据库。表与表之间可以存在关系(连接条件)。 Oracle数据库的关联查询有两种：内连接(等值连接、自然连接) 和 外连接(左外，右外，全外)。 先建立两张表如下：支用申请信息表12345678910111213create table loan_app_info(app_no varchar2(25) not null,channel_type varchar2(2),loan_no varchar2(30));comment on table loan_app_infois '支用申请信息表';comment on column loan_app_info.app_nois '申请流水号';comment on column loan_app_info.channel_typeis '渠道类型';comment on column loan_app_info.loan_nois '网贷生成出账号'; 网贷借据表1234567891011121314151617181920212223create table acc_loan(bill_no varchar(30) not null,contract_no varchar2(30),prd_name varchar(30),prd_type varchar(6),cus_id varchar2(18),cus_name varchar2(100));comment on table acc_loanis '网贷借据表';comment on column acc_loan.bill_nois '借据编号';comment on column acc_loan.contract_nois '合同编号';comment on column acc_loan.prd_nameis '产品名称';comment on column acc_loan.prd_typeis '产品类型';comment on column acc_loan.cus_idis '客户号';comment on column acc_loan.cus_nameis '客户名称'; 两张表存在 关联关系：loan_app_info.loan_no 与 acc_loan.bill_no (这两个字段来源相同)。 插入如下数据： loan_app_info有 9 条记录，acc_loan有 8 条记录。两张表里能关联上的记录有 6 条。 两表的 笛卡尔积 会有 72(9*8) 条记录:123--笛卡尔积select *from loan_app_info,acc_loan ; 注：笛卡尔积 通常是对数据查询危害极大的操作。 1 内连接内连接有两种： 等值连接 和 自然连接。 1.1 等值连接12345--内连接-等值连接1select *from loan_app_info app, acc_loan accwhere app.loan_no = acc.bill_no;--结果：6条记录 1234--内连接-等值连接2select *from loan_app_info app inner join acc_loan acc on(app.loan_no=acc.bill_no);--结果：6条记录 “inner” 和 “()”均可以省略。 1.2 自然连接自然连接 会自动寻找两张表中 列名相同 的列 做 等值连接。自然连接的条件：两张表 有且只有一列列名相同才能用自然连接。 如果不满足上述条件，自然连接的结果是笛卡尔积。 1234--内连接-自然连接select *from loan_app_info natural join acc_loan;--因为列名不同，结果是笛卡尔积 我的建议： 不要使用自然连接，因为不够灵活。 2 外连接外连接包括：左外连接，右外连接，全外连接。 2.1 左外连接以左边的表为主，即左边的表要全包含，右边表没有的记录可以补null。1234--外连接-左外连接select *from loan_app_info app left outer join acc_loan acc on(app.loan_no=acc.bill_no);--结果：9条数据(不是6条)。左边表loan_app_info的数据全包含 “outer” 和 “()”均可以省略。 结果： 2.2 右外连接以右为主，左不全补null。1234--外连接-右外连接select *from loan_app_info app right outer join acc_loan acc on(app.loan_no=acc.bill_no);--结果：8条数据，右边表数据全包含 “outer” 和 “()”均可以省略。 2.3 全外连接两边表的数据都要全包含。1234--外连接-全外连接select *from loan_app_info app full outer join acc_loan acc on(app.loan_no=acc.bill_no);--结果：11条数据(6+ 9-6 + 8-6 =11) “outer” 和 “()”均可以省略。 3 自连接自连接 一般用于 一张表内的 字段间 存在关联关系。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[systemctl 和 service]]></title>
    <url>%2F2018%2F11%2F23%2Fsystemctl%E5%92%8Cservice%2F</url>
    <content type="text"><![CDATA[内核启动第一个用户空间进程是由 init (/sbin/init)开始的。它主要负责 启动和终止系统中的基础服务进程。 linux系统中主要的 init版本 有如下:System V init: 传统的init,大多数的linux发行版都会兼容。Systemd: 新的init,很多linux发行版都已经或者计划转向Systemd。 查看 1 号进程：/sbin/init 是 /lib/systemd/systemd 的链接文件。系统的 1 号进程的确是 systemd，只不过在 ubuntu 系统中被起了个别名叫 /sbin/init。注：0号进程-&gt;1号内核进程-&gt;1号用户进程（init进程）-&gt;getty进程-&gt;shell进程。 1 service 命令service - run a System V init script service是一个命令，服务配置文件存放目录/etc/init.d/。service是去 /etc/init.d 目录下执行相关脚本程序。 service 的用法 service 操作：1service SCRIPT COMMAND [OPTIONS] SCRIPT 即是 /etc/init.d 目录下的文件。COMMAND 包含：start, stop, restart, reload, status.例如：12#通过ssh.service，输出服务类型 unit 的基本信息service ssh status 结果：1、第一行是对 unit 的描述。 2、Loaded 描述操作系统启动时会不会启动这个服务：enabled： 表示开机时启动。disabled： 表示开机时不启动。static：这个 unit 不可以自己启动，不过可能会被其它的 enabled 的服务来唤醒。mask：这个 unit 无论如何都无法被启动！因为已经被强制注销。可通过 systemctl unmask 改回原来的状态。 3、 active 的状态：active (running)： 表示服务正在运行中。inactive (dead)： 表示服务当前没有运行。active (exited)：仅执行一次就正常结束的服务，目前并没有任何程序在系统中执行。举例来说，开机或者是挂载时才会进行一次的 quotaon 功能，就是这种模式。Quotaon 不需要一直执行，只在执行一次之后，就交给文件系统去自行处理。通常用 bash shell 写的小型服务，大多是属于这种类型。active (waiting)：正在执行当中，不过还再等待其他的事件才能继续处理。举例来说，打印的相关服务就是这种状态。 service 查看所有 服务 状态：1service --status-all 其中 “+” 代表服务正在运行， “-“ 代表服务处于关闭状态，”?” 代表根本没有状态。 2 systemctl 命令systemctl - Control the systemd system and service manager ubuntu自从15.04版本以后都使用了systemd。 systemctl 用法：1systemctl [OPTIONS...] COMMAND [NAME...] COMMAND 包含：start, stop, restart, reload, status.NAME 是 服务名。 例：123456789101112131415161718# 查看 ssh服务的状态systemctl status ssh#打开服务systemctl start ssh#关闭服务systemctl stop ssh#重启服务systemctl restart ssh#不中断正常功能下重新加载服务systemctl reload ssh#设置服务的开机自启动systemctl enable ssh#关闭服务的开机自启动systemctl disable ssh#查看活跃的单元systemctl list-units 查看默认的 target：1systemctl get-default systemd 也提供了几个简单的指令用来切换操作模式:1234systemctl poweroff # 系统关机 systemctl reboot # 重新开机 systemctl suspend # 进入暂停模式 systemctl hibernate # 进入休眠模式 suspend：暂停模式会将系统的状态保存到内存中，然后关闭掉大部分的系统硬件，当然，并没有实际关机。当用户按下唤醒机器的按钮，系统数据会从内存中回复，然后重新驱动被大部分关闭的硬件，所以唤醒系统的速度比较快。hibernate：休眠模式则是将系统状态保存到硬盘当中，保存完毕后，将计算机关机。当用户尝试唤醒系统时，系统会开始正常运行，然后将保存在硬盘中的系统状态恢复回来。因为数据需要从硬盘读取，因此唤醒的速度比较慢 检查 unit 之间的依赖性:12systemctl list-dependencies [unit] [--reverse] #--reverse 会反向追踪是谁在使用这个 unit 例如：1systemctl list-dependencies default.target 当前运行在 graphical.target 下，它由一个长长的依赖列表(上图并未展示所有的项目)，其中最重要的依赖项目为 multi-user.target。可以使用 –reverse 选项查看 multi-user.target unit 被谁使用。 总结:systemctl 提供了管理 systemd 和系统服务的众多命令。systemd 是某些linux发行版用来代替系统启动 init 和 service 的一个新的系统工具，同时兼容init。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript笔记3-AJAX]]></title>
    <url>%2F2018%2F11%2F20%2FJavaScript%E7%AC%94%E8%AE%B03-AJAX%2F</url>
    <content type="text"><![CDATA[AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 xml 和 json ：1234&lt;person&gt; &lt;name&gt;mitre&lt;/mitre&gt; &lt;age&gt;24&lt;/age&gt;&lt;/person&gt; 1&#123;"name":"mitre", "age":"24"&#125; AJAX 通过 XMLHttpRequest 对象发请求： 普通交互模式（特点：全页面刷新 + 请求与响应同步处理(一个请求发送必须等到对应的相应回来才能再发下一个请求)）： 浏览器发请求 Tomcat服务器 处理请求返回响应结果给浏览器 浏览器显示结果 AJAX交互模式（特点：局部刷新 + 请求与响应异步处理）： 浏览器发请求 XMLHttpRequest 发请求 Tomcat服务器 处理请求返回响应结果给浏览器 XMLHttpRequest 接收响应 浏览器显示结果 AJAX 局部刷新，异步处理 提高了程序交互效率。 AJAX 技术： 基于 JS 发请求和响应处理。 以 XMLHttpRequest对象 为核心。 涉及 HTML，CSS 页面渲染技术。 涉及 XML，JSON 等数据交互格式。 1 普通交互模式web.xml123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1"&gt; &lt;display-name&gt;ajax01&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.mitrecx.DemoServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; DemoServlet.java12345678910111213package cn.mitrecx;public class DemoServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=utf-8"); PrintWriter out = response.getWriter(); out.println("上证指数:2645.43"); out.flush(); out.close(); &#125;&#125; demo1.jsp12345678910111213141516171819202122232425&lt;%@page pageEncoding="utf-8" contentType="text/html; charset=utf-8" %&gt;&lt;html&gt; &lt;body&gt; &lt;a href="demo1.do" &gt;查看上证指数&lt;/a&gt; &lt;hr/&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;股市新闻&lt;/td&gt; &lt;td&gt;时间&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;新一代股神mitre&lt;/td&gt; &lt;td&gt;2018-11-22&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;股市肿么了&lt;/td&gt; &lt;td&gt;2018-11-21&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;大海你真美&lt;/td&gt; &lt;td&gt;2018-11-21&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 结果： 2 AJAX交互模式web.xml 和 DemoServlet.java 与普通交互模式相同。 jsp文件做以区分，命名为 demo2.jsp，内容入下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;%@page pageEncoding="utf-8" contentType="text/html; charset=utf-8"%&gt;&lt;html&gt;&lt;head&gt;&lt;script type="text/javascript"&gt; //创建 XMLHttpRequest对象 function getXhr() &#123; var xhr if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else &#123;//老版IE xhr = new ActiveXObject("Microsoft.XMLHTTP"); &#125; //alert(xhr); return xhr; &#125; function sendRequest() &#123; var xhr = getXhr();//获取XMLHttpRequest对象 xhr.open("get", "demo1.do");//创建一个HTTP请求 //注册一个回调函数 xhr.onreadystatechange = function() &#123; //readyState==4 表示请求处理完毕 if (xhr.readyState == 4) &#123; //获取服务器返回的信息 var msg = xhr.responseText; //将消息放到span中显示 document.getElementById("msg").innerHTML = msg; &#125; &#125;; xhr.send(null);//发送HTTP请求 &#125;&lt;/script&gt;&lt;/head&gt;&lt;body style="font-size: 30px;"&gt; &lt;a href="#" onclick="sendRequest();"&gt;查看上证指数&lt;/a&gt; &lt;span id="msg"&gt;&lt;/span&gt; &lt;hr /&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;股市新闻&lt;/td&gt; &lt;td&gt;时间&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;新一代股神mitre&lt;/td&gt; &lt;td&gt;2018-11-22&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;股市肿么了&lt;/td&gt; &lt;td&gt;2018-11-21&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;大海你真美&lt;/td&gt; &lt;td&gt;2018-11-21&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 结果： 3 XMLHttpRequest 对象XMLHttpRequest 对象目前还没有完全标准化。 XMLHttpRequest 对象提供了基于 HTTP协议 的交互方法。包括发送 POST 和 HEAD 请求和普通的 GET 请求。XMLHttpRequest 可以同步或异步地返回 Web服务器 的响应，并能够以文本或 DOM文档 的形式返回内容。 XMLHttpRequest 并不限于和 XML 文档一起使用：它可以接收任何形式的文本文档。 3.1 属性1 readyStatereadyState 表示 HTTP 请求的状态。当一个 XMLHttpRequest 初次创建时，readyState = 0 ；接收到完整的 HTTP 响应时，这个值增加到 4。每次这个属性的值增加的时候，都会 触发 onreadystatechange 事件句柄。 2 responseTextresponseText属性的值 是到目前为止 客户端接收到的响应体（不包括头部）。 readyState &lt; 3 ，responseText属性值 是一个空字符串。readyState = 3 ，responseText属性值 是目前已经接收的响应部分。readyState = 4 ，responseText属性值 是完整的响应体。 3 responseXML功能和 responseText 类似。对请求的响应，解析为 XML 并作为 Document 对象返回。 4 status由服务器返回的 HTTP 状态码。如 200 表示成功，404 表示 “Not Found” 错误。当 readyState 小于 3 的时候读取这一属性会导致一个异常。 3.2 事件句柄onreadystatechange每次 readyState属性 改变的时候调用的事件句柄函数。当 readyState 为 3 时，它也可能调用多次。 3.3 方法1 open()1234open(method, url, async, username, password)// method 参数是用于请求的 HTTP 方法。值包括 GET、POST 和 HEAD//async 参数指示请求是否异步执行，默认不填或 true 请求为异步。 false为同步。//username 和 password 参数是可选的，为 url 所需的授权提供认证资格。 初始化 HTTP 请求参数。例如 URL 和 请求方法，但是并不发送请求。 open() 会把 readyState 设置为 1。 2 send()1send(body) 发送 HTTP 请求。如果 readyState 不是 1，send() 抛出一个异常。否则，它发送一个 HTTP 请求(POST 或 PUT、GET等)。该请求由以下几部分组成： 调用 open() 时指定的 HTTP 方法、URL 以及认证资格（如果有的话）。 调用 setRequestHeader() 时指定的请求头部（如果有的话）。 传递给这个方法的 body 参数。 一旦请求发布了，send() 会把 readyState 设置为 2，并触发 onreadystatechange 事件句柄。 POST请求 的请求参数 需要放在 send() 中发送:1234// post请求 http://localhost:8080/ajax01/check.do?name=cherryxhr.open("POST","/ajax01/check.do");// setRequestHeader 和 事件句柄 处理略xhr.send("name="+"cherry"); 而 GET 请求的请求参数放在 open中：1234//get请求 http://localhost:8080/ajax01/check.do?name=cherryxhr.open("GET","/ajax01/check.do?name="+"cherry");// 事件句柄 处理略xhr.send(null); 3 setRequestHeader()POST请求 必须给 HTTP协议 设置请求头参数(不设置服务端将取不到请求参数)。1xhr.setRequestHeader("content-type","application/x-www-form-urlencoded"); 4 abort()取消当前响应，关闭连接并且结束任何未决的网络活动。 abort() 会把 readyState属性值 置为 0 ，并且取消所有未决的网络活动。如果请求用了太长时间，而且响应不再必要的时候，可以调用 abort()。 4 附例 在上例基础上， 修改demo2.jsp 实现 “检查用户名是否可用” 功能 。(查看本例的 jQuery实现)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;%@page pageEncoding="utf-8" contentType="text/html; charset=utf-8"%&gt;&lt;html&gt;&lt;head&gt; &lt;script type="text/javascript"&gt; //创建 XMLHttpRequest对象 function getXhr() &#123; var xhr if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else &#123;//老版IE xhr = new ActiveXObject("Microsoft.XMLHTTP"); &#125; //alert(xhr); return xhr; &#125; function sendRequest() &#123; var xhr = getXhr();//获取XMLHttpRequest对象 xhr.open("get", "demo1.do");//创建一个HTTP请求 //注册一个回调函数 xhr.onreadystatechange = function() &#123; //readyState==4 表示请求处理完毕 if (xhr.readyState == 4) &#123; //获取服务器返回的信息 var msg = xhr.responseText; //将消息放到span中显示 document.getElementById("msg").innerHTML = msg; &#125; &#125;; xhr.send(null);//发送HTTP请求 &#125; &lt;/script&gt; &lt;script type="text/javascript"&gt; //检查用户名是否可用 function checkName()&#123; var name=document.getElementById("username").value; var xhr=getXhr(); /* get请求 */ //xhr.open("GET","/ajax01/check.do?name="+name); //xhr.send(null); /* post请求 */ xhr.open("POST","/ajax01/check.do"); // POST请求必须给HTTP协议设置请求头参数(不设置服务端将取不到请求参数) xhr.setRequestHeader("content-type","application/x-www-form-urlencoded"); //注册回调函数 xhr.onreadystatechange=function()&#123; //如果请求处理完毕且响应正常 if(xhr.readyState==4 &amp;&amp; xhr.status==200)&#123; var msg=xhr.responseText; document.getElementById("name_msg").innerHTML=msg; &#125; &#125; xhr.send("name="+name); document.getElementById("name_msg").innerHTML="正在检测.."; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body style="font-size: 30px;"&gt; &lt;a href="#" onclick="sendRequest();"&gt;查看上证指数&lt;/a&gt; &lt;span id="msg"&gt;&lt;/span&gt; &lt;hr /&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;股市新闻&lt;/td&gt; &lt;td&gt;时间&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;新一代股神mitre&lt;/td&gt; &lt;td&gt;2018-11-22&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;股市肿么了&lt;/td&gt; &lt;td&gt;2018-11-21&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;大海你真美&lt;/td&gt; &lt;td&gt;2018-11-21&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type="text" id="username" onblur="checkName();"/&gt; &lt;span id="name_msg"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; CheckServlet.java12345678910111213141516171819202122232425package cn.mitrecx;public class CheckServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; request.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=utf-8"); PrintWriter out=response.getWriter(); String name=request.getParameter("name"); System.out.println(name); //检查 用户名 是否可用 if("mitre".equals(name)) &#123; out.println("用户名已被占用"); &#125;else &#123; out.println("用户名可用"); &#125; out.flush(); out.close(); &#125;&#125; web.xml12345678&lt;servlet&gt; &lt;servlet-name&gt;checkServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.mitrecx.CheckServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;checkServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/check.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 先测试 servlet : 程序运行结果：]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript笔记2-jQuery]]></title>
    <url>%2F2018%2F11%2F19%2FJavaScript%E7%AC%94%E8%AE%B02-JQuery%2F</url>
    <content type="text"><![CDATA[在上一节说到，web developers 必修的三门语言： HTML CSS JavaScript 学习 jQuery 必须对上面 3 门语言有一定的了解。 为什么要学习 jQuery： jQuery 是一个优秀的、轻量级的 JS 库。极大的简化了 JS 编程。 jQuery 封装了 JS、 CSS、 DOM， 提供了一致的简洁的 API。 使用户更方便的处理 HTML、 Events， 实现动画效果。 方便地为网站提供 AJAX 交互。 jQuery 的使用步骤： 引入 jQuery 库。 使用 选择器 定位要操作的节点。 调用 jQuery 方法 进行操作。 jQuery 语法： $(selector).action()美元符号定义 jQuery选择器（selector）”查询” HTML 元素action() 执行对元素的操作 1 jQuery 对象DOM对象： 用传统的方法(javascript)获得的对象。jQuery对象： 通过 jQuery选择器 获得的对象 是 jQuery对象，如$(“.class1”), $(“#id1”)。 12345 //DOM对象var domObj = document.getElementById("id"); //jQuery对象;var $obj = $("#id"); jQuery对象 是jQuery独有的。如果一个对象是jQuery对象，那么就可以使用jQuery里的方法，例:12//获取id为foo的元素内的html代码，html()是jQuery特有的方法$("#foo").html(); 以上代码等价于：12// innerHTML 是 DOM对象 的方法document.getElementById("foo").innerHTML; 注：在jQuery对象中无法使用DOM对象的任何方法。当然，DOM对象也无法使用jQuery对象的任何方法。 重点： jQuery对象 的本质是 DOM对象 数组 jQuery对象和DOM对象的互相转换： jquery提供了两种方法将一个jquery对象转换成一个dom对象，即 [index] 和 get(index)。 1234// 通过id选择器 获取 jquery对象var $cr=$("#cr");// jQuery 对象 转化为 DOM对象var domObj = $cr[0]; //也可写成 var domObj=$cr.get(0); dom对象转换成jquery对象： 只需要用$()把dom对象包装起来，就可以获得一个jquery对象。方法为 $(dom对象)。 1234//dom对象var domObj=document.getElementById("cr");// DOM对象 转换成 jquery对象var $cr = $(domObj); 平时用到的jquery对象都是通过$()函数制造出来的，$()函数就是一个jQuery对象的制造工厂。 建议:如果获取的对象是 jQuery对象，那么在变量前面加上$ , 这样方便容易识别出哪些是jQuery对象。例如: var $variable = jQuery对象;如果获取的是dom对象，则定义如下: var variable = dom对象; 2. jQuery 选择器jQuery选择器 和 CSS选择器 类似，但是比 CSS选择器 更丰富。 CSS选择器：选择元素，施加样式。jQuery选择器：选择元素，施加方法。 1 基本选择器1234$("#id") //id选择器, 根据属性id名 定位元素$("div") //元素选择器， 根据 标签名 定位元素$(".classname") //类选择器 ，根据 属性class名 定位元素$(".classname,.classname1,#id1") //组合选择器，定位一组选择器所对应的 所有元素 2 层次选择器1234567$("select1 select2") //在 select1元素下， 选中所有满足 select2 的 子孙元素$("select1 &gt; select2")//在 select1元素下， 选中所有满足 select2 的 子元素 (只是子元素，不是子孙元素)$("#id .classname ") //后代元素选择器$("#id &gt; .classname ") //子元素选择器$("#id + .classname ") //紧邻下一个元素选择器（下一个兄弟）$("#id ~ .classname ") //兄弟元素选择器（所有兄弟） 3 过滤选择器(重点)3.1 基本过滤选择器 ( 用于表格和列表，可以在一组同样的元素中，选第一个，最后一个，奇数位等等 )123456789$("li:first") //第一个li$("li:last") //最后一个li$("li:even") //挑选下标为偶数的li$("li:odd") //挑选下标为奇数的li$("li:eq(4)") //下标等于 4 的li(第五个 li 元素)$("li:gt(2)") //下标大于 2 的li$("li:lt(2)") //下标小于 2 的li$("li:not(#runoob)") //挑选除 id="runoob" 以外的所有li 3.2 内容过滤选择器12345$("div:contains('Runob')") // 包含 Runob文本的元素$("td:empty") //不包含子元素或者文本的空元素$("div:has(selector)") //含有选择器所匹配的元素$("td:parent") //含有子元素或者文本的元素 3.3 可见性过滤选择器12$("li:hidden") //匹配所有不可见元素，或type为hidden的元素$("li:visible") //匹配所有可见元素 3.4 属性过滤选择器 (根据属性 定位元素)12345678$("div[id]") //所有含有 id 属性 的 div 元素$("div[id='123']") // id属性值为123的div 元素$("div[id!='123']") // id属性值不等于123的div 元素$("div[id^='qq']") // id属性值以qq开头的div 元素$("div[id$='zz']") // id属性值以zz结尾的div 元素$("div[id*='bb']") // id属性值包含bb的div 元素$("input[id][name$='man']") //多属性选过滤，同时满足两个属性的条件的元素 3.5 状态过滤选择器1234$("input:enabled") // 匹配可用的 input$("input:disabled") // 匹配不可用的 input$("input:checked") // 匹配选中的 input$("option:selected") // 匹配选中的 option 4 表单选择器123456789$(":input") //匹配所有 input, textarea, select 和 button 元素$(":text") //所有的单行文本框，$(":text") 等价于$("[type=text]")，推荐使用$("input:text")效率更高，下同$(":password") //所有密码框$(":radio") //所有单选按钮$(":checkbox") //所有复选框$(":submit") //所有提交按钮$(":reset") //所有重置按钮$(":button") //所有button按钮$(":file") //所有文件域 3 jQuery 属性和方法属性：$jqObj.length 包含 jQuery 对象中元素的数目 jQuery对象的 方法 可以分为 4类： 事件方法 效果方法 HTML/CSS 方法 遍历节点 3.1 事件方法123456789101112blur() // 添加/触发失去焦点事件change() // 添加/触发 change 事件click() // 添加/触发 click 事件dblclick() // 添加/触发 double click 事件mousedown() // 添加/触发 mousedown 事件mouseup() // 添加/触发 mouseup 事件mouseleave() // 添加/触发 mouseleave 事件mousemove() // 添加/触发 mousemove 事件mouseout() // 添加/触发 mouseout 事件mouseover() // 添加/触发 mouseover 事件 3.2 效果方法用于创建动画效果的 jQuery 方法。略。 3.3 HTML/CSS 方法读写节点的 HTML 内容：12345// 读$jqObj.html();// 写$jqObj.html("&lt;span&gt; hello &lt;/span&gt;"); 读写节点的文本内容：12345// 读$jqOjb.text();// 写$jqObj.text("hello"); 读写 表单或按钮等 value 属性 值：12345// 读$jqObj.val();// 写$jqObj.val("hello"); 读写节点的 属性值 ：12345// 读$jqObj.attr("属性名");// 写$jqObj.attr("属性名","新的属性值"); 增删节点： 创建 DOM 节点： $(“节点内容”) 创建的节点 会存在 内存里。 但是页面上看不到，只有把 节点 追加到已经存在的某个节点下， 页面上才能看到。 12345678910111213141516171819202122232425// 创建一个 DOM 节点var pNode = $("&lt;i&gt; hello &lt;/i&gt;");// 插入 DOM 节点// 在 p元素之前插入 DOM节点 (pNode 作为 p 的上一个兄弟节点)$("p").before(pNode);//结果：//&lt;i&gt; hello &lt;/i&gt;//&lt;p&gt;xxx&lt;/p&gt;// pNode 作为 p 的 下一个兄弟节点$("p").after(pNode);// pNode 做为 p 的第一个子节点$("p").prepend(pNode);//结果：//&lt;p&gt;&lt;i&gt; hello &lt;/i&gt;xxx&lt;/p&gt;// pNode 作为 p 的最后一个子节点$("p").append(pNode);// 删除节点$("p").remove();// 清空节点： 节点还在，内容清空$("p").empty(); 3.4 遍历节点略。 4 示例把 input 元素（type 属性值 为 “password”）的 type 属性值改为 “text”。 jQuery 实现：12345678910111213141516171819&lt;html&gt;&lt;head&gt; &lt;script src="jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function doclick()&#123; $("#password1").attr("type","text"); alert($("#password1").val()); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input type="password" id="password1" value="123456" /&gt; &lt;input type="button" id="button1" onclick="doclick();" value="Show default value" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 也可以写成如下形式：1234567891011121314151617181920&lt;html&gt;&lt;head&gt; &lt;script src="jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(document).ready(function()&#123; $("#button1").click(function()&#123; $("#password1").attr("type","text"); alert($("#password1").val()); &#125;)&#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input type="password" id="password1" value="123456" /&gt; &lt;input type="button" id="button1" value="Show default value" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; ready() 方法： 在文档加载后激活函数。当 DOM（文档对象模型） 已经加载，会发生 ready 事件。ready()方法 有三种语法：123456//语法 1$(document).ready(function)//语法 2$().ready(function)//语法 3$(function) 注： 语法 3 和 DOM对象转jQuery对象的语法一样 ！！！ JS 实现：123456789101112131415161718&lt;html&gt;&lt;head&gt; &lt;script type="text/javascript"&gt; function doClick () &#123; document.getElementById("password1").type="text"; alert(document.getElementById("password1").value); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input type="password" id="password1" value="123456" /&gt; &lt;input type="button" id="button1" onclick="doClick();" value="Show default value" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 参考 DOM对象和JQuery对象的区别 菜鸟教程: jQuery 选择器 附 上图是在 Chrome 浏览器 的 console 控制台测试的结果。 通过 jQuery 的 id 选择器选择的结果 可以调用 DOM对象的value属性， 但不可以调用 jQuery对象的 val() 方法 。 jQuery 选择器返回的结果 为什么 不是 jQuery 对象？]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript笔记1-JS基础]]></title>
    <url>%2F2018%2F11%2F15%2FJavaScript%E7%AC%94%E8%AE%B0-1%2F</url>
    <content type="text"><![CDATA[0 前言为什么要学习 JavaScript ？ 引用于w3schools : JavaScript is one of the 3 languages all web developers must learn: HTML to define the content of web pages CSS to specify the layout of web pages JavaScript to program the behavior of web pages JavaScript 是一种轻量级的脚本语言，由浏览器执行。 与 JS 相关的技术： HTML DOM 定义了访问和操作 HTML 文档的标准方法。 jQuery库 极大地简化了 JavaScript 编程。 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 JSON ：JavaScript 对象表示法（JavaScript Object Notation）。 JS 代码可以写在 HTML 中，也可以写在 js 文件中：1、 HTML 中的 JavaScript:HTML 中的 JS脚本 必须位于 &lt;script&gt; 与 &lt;/script&gt; 标签之间。JS脚本 可被放置在 HTML 页面的 &lt;body&gt;元素 和 &lt;head&gt;元素 中。 JavaScript 是所有现代浏览器以及 HTML5 中的 默认脚本语言。 在 &lt;script&gt; 标签中使用 type=”text/javascript” 不是必要的。 2、 外部的 JavaScript:外部 JavaScript 文件的文件扩展名是 .js。引用外部 JS 文件，需要在 &lt;script&gt; 标签的 “src” 属性中设置该 .js 文件：123456&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src="myScript.js"&gt;&lt;/script&gt; &lt;/head&gt;&lt;/html&gt; 我对 JavaScript 的理解 ： 学习简单： UE + Chrome + W3School 即可学习开发 面向对象，回调函数 有点 Java 的影子 ，其 控制语句 和 运算符 与Java的语法几乎一致 在 JS 中，变量没有类型，统一用 var 声明。但变量所引用的数据是有类型的 JS 函数是 由事件驱动的 或者当它被调用时执行的 可重复使用的代码块。 在 JS 中，一切皆对象。 1 JavaScript 内置对象 String Number Array 数组 Math Date 时间 RegExp 正则表达式 Function Boolean (不做说明) 注：typeof(varName) 可以查看变量的 数据类型。在浏览器中打开控制台( F12 ) ，可以方便的进行测试或学习。 1.1 String 对象 定义一个变量，引用的数据类型为 String 类型：1var str="hello world."; String 的属性：length属性，str.length 获取字符串长度。 String 的函数： 子串， str.substring(startIndex, [endIndex]) 和java一样 “含头不含尾” 获取子串下标， str.indexOf(findStr, [startIndex]), str.lastIndexOf(findStr, [inverseStartIndex]) 找到返回索引，找不到返回 -1 获取对应下标的字符，str.charAt(index) 替换 replace， str.replace(findStr, newStr) , 参考例子 字符串切割， str.split(findStr, [limit]) 。limit 取负 和足够大一样。 但 limit 不够大，会忽略后面的段。 大小写 toUpperCase(), toLowerCase() 1.2 Number 对象 引用的数据类型是 Number 类型：1234var num=5;var num2=num/2; // num2 结果为 2.5// javaScript 中 数字类型 包含了 "整型" 和 "浮点型" var n=0.5; JavaScript 中，Number 对象 包括 整数和小数。 1.3 Array 对象 创建 数组对象：1var a1 = [1, 2, 3]; 也可以 new 数组对象：1234var a2 = new Array();//new 时 指定长度var a3 = new Array(10); 在 JS 中，数组的长度是可变的。 因此，指定数组长度是没有意义的。 为数组赋值：12345// 1. 直接 指定下标赋值a1.[0]=100;// 2. push 赋值，总是在数组的 最后 添加元素a1.push(4); 数组元素 排序：12// 按字符 顺序排： 100 &lt; 2 &lt; 3 &lt; 4a1.sort(); 如果想要按 数字大小 排序，需要 自定义排序方法 ：123456fuction compare(i,j)&#123; return i-j;&#125;// 按照 数字大小排序： 2 &lt; 3 &lt; 4 &lt; 100a1.sort(compare); 数组中的数组：1234var aa = [ [1, 2, 3], [6, 7, 8] ];// 数组中 还是 数组， 各个数组 的类型可以不一致var var aa=[[1,2,3],["hello","world"],["你好"]]; 1.4 Math 对象 无需创建， 直接使用 Math 对象的 属性和方法。 比如： 属性：Math.PI 圆周率 , Math.E 自然对数 等。 方法： Math.round(x) 四舍五入 Math. abs(x) 绝对值，absolute value Math.pow(x,n) x 的 n 次方， power Math.sqrt(x) 平方根， square root Math.random() 返回 0 ~ 1 之间的一个随机数 Math.max(…value) 返回最大值 三角函数等等。 1.5 Date 对象 创建 Date 对象：12345// d1 的值为 当前系统时间var d1 = new Date(); // 指定 d2 的值var d2 = new Date("2017-3-20 11:23"); 获取 毫秒 数：1d1.getTime(); 读写 时间分量：1234567891011//年d1.getFullYear();// 月d1.getMonth();// 日d1.getDate();// 星期几d1.getDay();// 等等...//写， set 对应的分量 Date 转 字符串：12345678d1.toString();// "Sat Nov 17 2018 19:07:53 GMT+0800 (China Standard Time)"d1.toLocaleString();// "11/17/2018, 7:07:53 PM"d1.toLocaleDateString();// "11/17/2018" 1.6 RegExp 正则表达式 对象 创建 RegExp 对象：1234var re = /pattern/[flags] ;// 或者var re = new RegExp("pattern", ["flags"]); flags 标识有两个: g, 全局模式 i, 忽略大小写 RegExp 对象有一个 test() 方法，用于 测试字符串 是否匹配 正则表达式。如果匹配，返回true。 否则 false。1re.test(str); 注：RegExp 还有一个 exec() 方法，这个方法不返回 boolean 类型，而是 返回匹配到的字符串。 举两个例子： 匹配字符串，包含且仅包含 [3, 6] 位数字：123456var re = /^\d&#123;3,6&#125;$/;re.test("123"); //truere.test("12"); //falsere.test("12a"); //false 匹配字符串，是否包含 3 位 数字：123456var re2=/\d&#123;3&#125;/;re2.test("mitre123"); //truere2.test("mitre1234"); //true 包含3位数字re2.test("mitre12"); //false String 和 RegExp :举个例子：1234567891011121314var str="JavaScript 和 Java 语法有点类似, 但是 JavaScript 不是 Java";var re=/Java/g;str.match(re); //返回匹配到的字符串的 数组// (4) ["Java", "Java", "Java", "Java"]str.replace("Java","java"); //不用正则， 只改变第一个// "javaScript 和 Java 语法有点类似, 但是 JavaScript 不是 Java"str.replace(re,"java");// "javaScript 和 java 语法有点类似, 但是 javaScript 不是 java"str.search(re); //返回匹配到的第一个 下标， 如果没有匹配到返回 -1// 0 登录案例：JS 验证用户名和密码是否符合要求。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;html&gt; &lt;head&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="style.css"&gt; &lt;script&gt; //校验用户名 function checkName () &#123; //获取账号文本框 var input=document.getElementById("name"); //获取账号提示span var span=document.getElementById("nameMsg"); //获取文本框的值 var name = input.value; var re = /^\w&#123;3,20&#125;$/; //若不匹配，把span样式改一下 if(!re.test(name))&#123; //className 等价于元素的 class属性 span.className="errorMsg"; return false; &#125;else&#123; span.className=""; //匹配上需要移除错误样式 return true; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- onsubmit 是表单提交事件，点击提交时触发。提交表单前先调用 onsubmit 中的方法，只有方法返回 true 才提交表单--&gt; &lt;form action="mitrecx.cn" onsubmit="return checkName()&amp;&amp;checkPassword();"&gt; &lt;h1&gt;登录&lt;/h1&gt; &lt;p&gt; 账号：&lt;input id="name" type="text" onblur="checkName();"/&gt; &lt;span id="nameMsg"&gt;3-20 位 字母、数字、下划线&lt;/span&gt; &lt;/p&gt; &lt;p&gt; 密码：&lt;input type="password" onblur="checkPassword();" /&gt; &lt;span&gt;6-20 位 字母、数字、下划线&lt;/span&gt; &lt;/p&gt; &lt;div&gt; &lt;input type="submit" value="登录"/&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; style.css 文件：123456789101112131415161718192021222324252627form&#123; width: 500px; margin: 150px auto; border: 1px solid #00ff00;&#125;form h1&#123; text-align:center; margin: 0; padding: 5px; border: 1px solid #ccc;&#125;form p&#123; margin: 0; padding: 20px; border: 1px solid #ccc;&#125;form div&#123; text-align:center; margin: 0; padding:10px; border: 1px solid #ccc;&#125;.errorMsg&#123; border: 1px solid red; color:red;&#125; 结果： 1.7 Function 对象 在 JS 中，函数就是 Function 对象。函数名就是 指向 Function 对象的引用。 JS 函数定义：1234function functionName([参数])&#123; 函数体; [return 返回值;]&#125; 函数的返回值： 默认返回 undefined 可以使用 return 返回具体的值 函数的参数： JS 函数没有重载。调用时 只要函数名相同，无论传入多少个参数，调用的都是同一个函数。 没有收到 实参 的参数值都是 undefined 类型。 所有的参数都传递给 JS内部的 arguments数组 对象。function 函数定义时，不论有没有参数，arguments数组 都是存在的。 arguments 数组： arguments 是一种特殊的对象，在函数中，表示函数的 参数数组 。 在函数中，可以使用 arguments 访问所有的参数：arguments.length : 函数 实参 个数arguments[i] : 第 i 个参数 有了 arguments ， 在 JS 函数中声明与不声明 形参 都可以。这使得 JS 的函数定义变得很灵活。一般情况下，最好用到几个参数，就声明几个参数，这样符合编程习惯。 例如，定义一个 sum() 函数，求所有参数的和：1234567function sum()&#123; var sum=0; for(var i=0;i&lt;arguments.length;++i)&#123; sum+=arguments[i]; &#125; return sum;&#125; F12，在浏览器控制台测试结果：1234sum(1,2);3sum(1,2,3,4,5);15 使用 Function 创建函数 (几乎没人这样写)：12var add=new Function("x","y","return(x+y)");//效果等价于 var add(x,y)&#123;return x+y;&#125; 结果：12add(1,2);3 alert(add)，把用 new Function 创建的函数打印出来，结果：这个函数名是 anonymous (匿名的)。 匿名函数创建匿名函数：1234var func = function(arg1, ... , argn)&#123; func_body; return returnValue;&#125; 匿名函数应用：12345678var a=[ 8, 7, 1, 2, 10, 33, 5];a.sort();//结果：(7) [1, 10, 2, 33, 5, 7, 8]//使用匿名函数a.sort( function(a,b)&#123;return a-b;&#125; );//结果：(7) [1, 2, 5, 7, 8, 10, 33] 全局函数所谓全局函数，就是不用创建对象，拿来就能用的函数。 JS常用的全局函数：1234567891011121314parseInt(str);parseFloat(str);//是数字类型 返回 falseisNaN(variable);//把 str 当做 JS表达式 或 JS代码 执行eval(str);// 把字符串编码为 URIencodeURI(URIstring)// 返回 URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换decodeURI() //解码某个编码的 URI。 2 外部对象外部对象就是 浏览器对象模型 ( Browser Object Model, BOM )。 BOM 是 浏览器提供的一套 API。它使 JS 有了操作浏览器窗口的能力。 文档对象模型 ( Document Object Model, DOM ) 定义了访问和操作文档的方法，它属于 BOM，但是 DOM 的内容占据 BOM 的半壁江山。DOM 就是上图的 document。 2.1 浏览器对象模型 BOMwindow 对象的方法和属性 都可以省略 window. 前缀。比如，window.alert(str) 可以 写成 alert(str) 。 window对象的方法： 1、 对话框：12345//提示对话框， 无返回alert("hello world");//确认对话框， 确认返回true，取消返回falseconfirm("你确认吗? "); 2、 定时器：定时器通常用于定时刷新页面。 一次性定时器： setTimeout(functionName,time)周期性定时器： setInterval(functionName, time) 周期性定时器：12345678// 每隔 time 时间 触发执行 functionName函数/代码setInterval(functionName, time);// time 的单位是毫秒// 返回 已经启动的定时器对象// 停止已经启动的定时器对象clearInterval(tID);// tID 是启动的定时器对象 举个栗子，每隔 3 秒 弹出提示对话框：12345678910var tid=setInterval("alert('hello');",3000);//或者setInterval(fun,3000);function fun()&#123; alert("hello"); &#125;//或者setInterval(function ()&#123; alert("hello");&#125;, 3000); 2.2 history 对象history 对象 记录了一个窗口访问过的 URL history 的 属性 和 方法： length属性，记录中 URL 的数量 back() ， 等同于点击 后退 按钮 forward() ，等同于点击 前进 按钮 go(n) ，n为正前进 n 次， n 为负后退 n 次 2.3 location 对象location 对象 包含了当前 URL 的相关信息 location 通常用于 获取和改变当前浏览的 URL location 的 属性 和 方法： href 属性： 若给 href 属性赋值，则会改变当前浏览的 URL。 若不赋值则 返回当前窗口正在浏览的地址。 reload() 方法： 重新加载当前地址。 2.4 screen 和 navigatorscreen 对象包含有关客户端显示屏幕的信息。 Screen 对象属性： availHeight 返回显示屏幕的高度 (除 Windows 任务栏之外)。 availWidth 返回显示屏幕的宽度 (除 Windows 任务栏之外)。 navigator 对象包含有关浏览器的信息。 navigator 对象 属性： userAgent 返回由客户机发送服务器的 user-agent 头部的值。 2.5 DOMDOM 提供了如下操作： 查找节点 读取节点信息 修改节点信息 创建新节点 删除节点 节点信息：nodeName 节点名称，nodeType 节点类型。 节点的内容：innerHTML，innerText。 节点的属性：getAttribute()setAttribute()removeAttribute() 节点的样式：className， 类选择器 封装的类型 style12345678910111213//&lt;p id="t1"&gt; hello world.&lt;/p&gt;vat t = document.getElementById("t1");//改变字体颜色 和 大小t.style.color = "red";t.style.fontSize = "30px";// &lt;a href="xxx.jsp" title="this is a link" id="a1" &gt; xxx &lt;/a&gt;var a1 = document.getElementById("a1");//获取 a 元素的 href 属性 值var href = a1.getAttribute("href");&#125; 3 自定义对象自定义对象 是一种有属性和方法封装而成的 数据类型。 调用对象属性： 对象名.属性名调用对象方法： 对象名.方法名 创建 自定义对象 有三种方法： 1、 直接创建12345678910111213// 直接 new 一个 Objectvar teacher = new Object();// 自定义属性teacher.name = "陶行知";teacher.age = "50";// 自定义方法teacher.work = function()&#123; alert("我教 JavaScript");&#125;// 调用对象alert("姓名: "+ teacher.name +" 年龄： "+teacher.age);teacher.work(); 2、 使用构造器创建1234567891011// 写一个构造器方法function Student(name,age)&#123; this.name=name; this.age=age; this.work=function()&#123; alert("我学 Java"); &#125;&#125;// 创建对象var s=new Student("小艾",20); 3、 使用 JSON(JavaScript Object Notation, JS对象标记) 创建123456789101112// 创建一个 programmer对象var programmer=&#123; "name":"mitre", "age":24; "work":function()&#123; alert("我写 Java "); &#125;&#125;// 可以直接调用 programmer 对象alert(programmer.name+" "+programmer.age);programmer.work();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java字符串]]></title>
    <url>%2F2018%2F11%2F13%2Fjava%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[java 的 String 类中的所有方法的用法 都在 JavaSE 8 API 的 docs 中做了详细的说明。 这里挑出几个常用的方法介绍，以巩固之所学。 先看一例： 标准期限：两位年，两位月，两位日(取零)。表示 整月数 。其中月 逢12进1 。例如：00 01 00 表示 1 个月。00 11 00 表示 11 个月。再加一个月 就是 01 00 00，表示 12 个月，即 1 年。 把任意指定的一个 标准期限 转为 整月数：1234567891011121314151617181920212223242526public class TestString &#123; public static int nstd2std(String stdTerm) &#123; if (stdTerm == null || stdTerm.length() != 6) &#123; System.out.println("标准期限必须6位"); &#125; else &#123; String yearBit = stdTerm.substring(0, 2); int month_y = Integer.parseInt(yearBit) * 12; String monthBit = stdTerm.substring(2, 4); int month_m = Integer.parseInt(monthBit); int totleMonth = month_y + month_m; return totleMonth; &#125; return 0; &#125; public static void main(String[] args) &#123; while (true) &#123; System.out.print("输入: "); Scanner scan = new Scanner(System.in); String stdTerm = scan.nextLine(); int term = nstd2std(stdTerm); System.out.println(term); &#125; &#125;&#125; 结果： 字符串的下标 从左开始，从零开始: 1 java String类的常用方法1.1 子串 substring123456/** * * @param beginIndex - the beginning index, inclusive * @param endIndex - the ending index, exclusive. */public String substring(int beginIndex,int endIndex) java 获取子串方法是 含头不含尾 的： substring的重载方法：123public String substring(int beginIndex)//等价于public String substring(int beginIndex, str.length()) 1.2 索引 index正向取子串的索引：1234public int indexOf(String subStr, int fromIndex)////public int indexOf(String subStr) //等价于： public int indexOf(String subStr, 0) 在左边设置一个 查找起始索引。返回值 &gt;= 起始索引fromIndex 。 反向 取子串的索引：1public int lastIndexOf(String subStr, int fromIndex) 从右往左查找，在 “右边” 设置一个 查找起始索引，因为是 从右往左 查找，所以一定有：返回值 &lt;= 查找起始索引fromIndex 。 123public int lastIndexOf(String subStr)//等价于public int lastIndexOf(String subStr, str.length() ) 1.3 替换 replace替换返回的结果是替换后的字符串。原字符串不会被修改 。 12345678/** *Parameters: target - The sequence of char values to be replaced replacement - The replacement sequence of char values *Returns: The resulting string *Throws: NullPointerException - if target or replacement is null. */public String replace(CharSequence target, CharSequence replacement) 使用正则表达式的 replaceAll 方法：1234567891011/*** @param regex* the regular expression to which this string is to be matched* @param replacement* the string to be substituted for each match* @throws PatternSyntaxException* if the regular expression's syntax is invalid** @see java.util.regex.Pattern*/public String replaceAll(String regex, String replacement) 1.4 切割 split1public String[] split(String regex, int limit) 按照正则表达式 regex 来切割。limit 限制 切割的次数 。 limit 为正， 限制切割次数为（limit-1）次。 limit 为负， 不限制切割次数 ( 和 limit为正且足够大的效果一样 ) 。 limit 为零， 不限制切割次数，但 忽略 切割后尾部的所有空字符串。 比如：字符串 “boo:and:foo” 123public String[] split(String regex)//等价于public String[] split(String regex, 0) 1.5 其他1、contains 方法：1public boolean contains(CharSequence s) 字符串 包含 子串s 返回true， 否则 false。 2、matches 方法 ( 完全匹配才会返回 true )：1boolean matches(String regex) 3、大小写：123String toLowerCase();String toUpperCase(); 4、trim ：1String trim() 参考1、 java Class String]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis框架简介]]></title>
    <url>%2F2018%2F11%2F08%2FMyBatis%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[1 MyBatis 简介什么是 MyBatis ？MyBatis 是一款优秀的 持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和 映射 原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 2 使用 MyBatis 开发流程使用 MyBatis 框架操作数据库的步骤简图： 上图中涉及到两个xml文件，一个是 (全局)配置文件，一个是 映射文件。 全局配置文件(configuration XML) 内容，参考 MyBatis 官网提供的模板：1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="org/mybatis/example/BlogMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 映射文件(Mapper XML) 示例，参考 MyBatis 官网提供的模板：123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="org.mybatis.example.BlogMapper"&gt; &lt;select id="selectBlog" resultType="Blog"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 另外，获取 SqlSession 参考如下代码片段：12345String resource = "sqlMapConfig.xml";InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);SqlSession sSession = sqlSessionFactory.openSession(); SqlSessionFactoryBuilder这个类可以被实例化、使用和抛弃。一旦创建了 SqlSessionFactory，就不再需要它了。 SqlSessionFactorySqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除和重建。 SqlSession每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的。所以它的最佳的作用域是请求或方法作用域。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。如果你正在使用一种 web 框架，要考虑把 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到一个 HTTP 请求，就应该打开一个 SqlSession，返回一个响应，就关闭 SqlSession。下面的示例就是一个确保 SqlSession 关闭的 标准模式：123456SqlSession session = sqlSessionFactory.openSession();try &#123; // do work&#125; finally &#123; session.close();&#125; 小结：MyBatis 的真正强大在于它的映射语句。拿它跟具有相同功能的 JDBC 代码进行对比，省掉了 表字段和实体类属性之间赋值 的代码。MyBatis 就是针对 SQL 构建的，并且比普通的方法做的更好。 3 MyBatis 增删改查示例根据数据库表的结构建立实体类 Emp.java ：1234567891011package cn.mitrecx.domain;import java.math.BigDecimal;public class Emp &#123; //属性名 与 字段名 一致 private Integer id; private String name; private Integer age; private BigDecimal salary; //get set方法略&#125; 映射文件(Mapper XML) EmpMapper.xml ：12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="empSql"&gt; &lt;select id="findEmp" resultType="cn.mitrecx.domain.Emp"&gt; select * from emp &lt;/select&gt; &lt;select id="findEmpByName" parameterType="java.lang.String" resultType="cn.mitrecx.domain.Emp"&gt; select * from emp where name like #&#123;name&#125; &lt;/select&gt; &lt;select id="findEmpById" parameterType="int" resultType="cn.mitrecx.domain.Emp"&gt; select * from emp where id=#&#123;id&#125; &lt;/select&gt; &lt;insert id="saveEmpByEmp" parameterType="cn.mitrecx.domain.Emp"&gt; insert into emp(name,age,salary) values(#&#123;name&#125;,#&#123;age&#125;,#&#123;salary&#125;) &lt;/insert&gt; &lt;insert id="saveEmpByMap" parameterType="java.util.Map"&gt; insert into emp(name,age,salary) values(#&#123;xm&#125;,#&#123;nl&#125;,#&#123;xs&#125;) &lt;/insert&gt; &lt;delete id="deleteEmpByName" parameterType="java.lang.String"&gt; delete from emp where name=#&#123;name&#125; &lt;/delete&gt; &lt;update id="updateEmpById" parameterType="java.util.Map" &gt; update emp set salary=#&#123;salary&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; MyBatis全局配置文件 SqlMapConfig.xml ：123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="environment"&gt; &lt;environment id="environment"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://cherry.mitrecx.cn:3306/DBmitre?useUnicode=true&amp;amp;characterEncoding=utf8"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456Seven"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载SQL定义文件 --&gt; &lt;mappers&gt; &lt;mapper resource="cn/mitrecx/domain/EmpMapper.xml" &gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 测试类 ：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package cn.mitrecx.test;import java.io.IOException;import java.io.InputStream;import java.math.BigDecimal;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import cn.mitrecx.domain.Emp;public class TestEmp &#123; public static void main(String[] args) throws IOException &#123;// //加载主配置文件SqlMapConfig// Reader reader=Resources.getResourceAsReader("sqlMapConfig.xml");// SqlSessionFactory ssf=new SqlSessionFactoryBuilder().build(reader);// SqlSession sSession=ssf.openSession(); String resource = "sqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sSession = sqlSessionFactory.openSession(); System.out.println("MyBatis show"); //List&lt;Emp&gt; list=sSession.selectList("findEmp"); List&lt;Emp&gt; list=sSession.selectList("findEmpByName", "%e%"); for(Emp e:list) &#123; System.out.println(e.getName()+" "+e.getSalary()); &#125; System.out.println("-------单行查询测试---------"); Emp e1=sSession.selectOne("findEmpById",10); System.out.println(e1.getId()+" "+e1.getName()+" "+e1.getSalary()); System.out.println("-------插入测试---------"); Emp e2=new Emp(); e2.setName("coco"); e2.setAge(11); e2.setSalary(new BigDecimal("8848")); sSession.insert("saveEmpByEmp", e2); sSession.commit();//自动提交默认是关闭的。增删改必须要提交 Map&lt;String,String&gt; map=new HashMap&lt;String,String&gt;(); map.put("xm", "kiki"); map.put("nl", "23"); map.put("xs", "12345"); sSession.insert("saveEmpByMap",map); sSession.commit(); System.out.println("-------删除测试---------"); sSession.delete("deleteEmpByName", "coco"); sSession.commit(); System.out.println("-------修改测试---------"); Map&lt;String,String&gt; map2=new HashMap&lt;String,String&gt;(); map2.put("id", "10"); map2.put("salary","111112"); sSession.delete("updateEmpById", map2); sSession.commit(); //释放session sSession.close(); &#125;&#125; 结果： 4 动态 SQL if choose (when, otherwise) trim (where, set) foreach 动态 SQL 通常要做的事情是根据条件包含 where 子句的一部分。比如：12345678&lt;select id="findActiveBlogWithTitleLike" resultType="Blog"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test="title != null"&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; MyBatis官网对动态SQL做了详细的说明，参考这里。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle-学习2-字符串操作和时间操作]]></title>
    <url>%2F2018%2F11%2F07%2FOracle%E5%AD%A6%E4%B9%A02-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%92%8C%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1 Oracle 字符串类型字符串类型的数据可依 编码方式 分成 数据库字符集 (CHAR/VARCHAR2/CLOB/LONG)和 国际字符集(以 N 开头) (NCHAR/NVARCHAR2/NCLOB)两种。数据库中的字符串数据都通过字符集将字符转换为二进制，才存储到数据块中。通过不同的编码集转换，即便是相同的字符，也可能会转换成不同的二进制编码。这也是产生乱码的原因。数据库的编码格式一般是在创建数据库时指定的。也可以在数据库建立之后修改其编码。12--字符集查询select userenv('language') from dual; 字符串类型 依据 存储方式 分为 固定长度类型（CHAR/NCHAR) 和 可变长度类型（VARCHAR2/NVARCHAR2)两种. 固定长度 ：是指虽然输入的字段值小于该字段的限制长度，但是实际存储数据时，会先自动 在右端补足空格 后，才将字段值的内容存储到数据块中。(浪费空间，但是存储效率较可变长度类型要好)例：char的长度是固定的，比如，定义了char(20),即使插入abc，不足二十个字节，数据库也会在abc后面自动加上17个空格，以补足二十个字节。 可变长度：当输入的字段值小于该字段的限制长度时，直接将字段值的内容存储到数据块中，而不会补上空格。(节省数据块空间) Oracle 字符串类型： char(size) / nchar(size) ：定长，字节/字符。最长2000字节。 varchar(size) / varchar2(size) ：不定长（变长），字节。最长4000字节。 nvarchar(size) / nvarchar2(size) ：不定长，字符 long 和 clob ：不定长。long 2GB，clob 4 GB。 2 Oracle 字符串处理函数 concat 和 ||，拼接字符串 length upper，lower，和 initcap(各个单词首字母大写) substr trim，ltrim，rtrim instr lpad，rpad 介绍一下 4,5,6,7 ： substr 选取子串的起始位置是 1，不是 0。（但是，写0的效果和1相同，都会从起始位置选取）1234--substr('xxx',start,size)select substr('hello world',1,4) from dual ;--结果： 'hell' trim 只对 两端 有效，去除两端空白，或者去除两端某一个指定字符。1234567891011--去除 两端 空白select trim(' mitre cx ') from dual;--去除 左端 空白select ltrim(' mitre cx ') from dual;--去除 右端 空白select rtrim(' mitre cx ') from dual;--去除 两端 字符eselect trim('e' from 'eeemitre eeecxee') from dual; instr (index string的缩写) 字符查找函数，查找到指定字符串，返回指定子串的下标(注意从1开始)，未找到返回0。 格式一：instr(源字符串, 目标字符串)格式二： instr(源字符串, 目标字符串[, 起始位置[, 匹配序号]]) 1234567select instr('helloworld','wo') from dual;--返回结果：'6' --即“w”开始出现的位置select instr('helloworld','o',1,2) from dual;--结果：'7'--从起始位置 1 开始查找，找第 2 个 ‘o’ 出现的位置 lpad 在 字符串的左边补位。rpad 在 字符串的右边补位。1234567select lpad('world',13,'000 ') from dual; --结果：'000 000 world'--在 'world' 的左边补位 '000 ', 补满 13位select lpad('world',3,'000 ') from dual;--结果：'wor'--总位数少于原始字符串位数，则保留左侧(rpad也是保留左侧) 3 时间类型 date获取当前系统时间：12select sysdate from dual;--结果：'2018/11/22 9:28:20' 3.1 时间和字符串时间转字符串 to_char(timestamp, timeFormat)：YYYY 年MM 月份 (01-12)DD 一个月里的日子(01-31)D 一周里的日子(1-7；SUN=1)day 星期几 HH 一天的小时数 (01-12)HH12 一天的小时数 (01-12)HH24 一天的小时数 (00-23)MI 分钟 (00-59)SS 秒 (00-59)更多格式. 例：1234567select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss , day') from dual;--结果：'2018-11-22 10:13:04 , 星期四'-- 本月的天数SELECT to_char(last_day(SYSDATE),'dd') days FROM dual;--结果：'30'--注：last_day(time):返回指定日期所在月份的最后一天 字符串转时间 to_date(charType, timeFormat):12select to_date('2018-11-22','yyyy-mm-dd') from dual;--结果：'2018/11/22' 3.2 时间的操作在介绍时间操作前，先了解 3 个函数： round(num [,decimal_scale]) 函数: 四舍五入。 floor(num) 函数 : 地板，取小于等于数值 num 的最大整数。 ceil(num) 函数 ：天花板，取大于等于数值 num 的最小整数。 示例：12345678select round(123.456,2) from dual; -- '123.46'select round(123.456) from dual; -- '123'select floor(123.456) from dual; -- '123'select ceil(123.456) from dual; -- '124'select floor(-1.2) from dual; -- '-2'select ceil(-1.2) from dual; -- '-1' 计算时间差：时间相减1234--两个日期间的天数select sysdate - to_date('2018-10-23','yyyy-mm-dd') from dual; -- '30.4204282407407'select floor(sysdate - to_date('2018-10-23','yyyy-mm-dd')) from dual; -- '30' 12--求某天是星期几select to_char(to_date('2018-11-22','yyyy-mm-dd'), 'day') from dual; -- '星期四' trunc 函数 –截取函数truncate, 截短，删节。 trunc函数有两种形式： trunc(number [,decimal_scale]) ，截取数字 , decimal_scale 保留小数点后面的位数。忽略它则截去所有的小数部分。若 decimal_scale 为负，则向整数位截取补零。 trunc(datestamp [,time_scale]) ，截取时间 , timeFormat 截取时间保留的位数。忽略默认截取到日。截取的结果是日期：年/月/日。 trunc 函数 示例：1234567891011121314151617select trunc(123.456,2)from dual; -- '123.45'select trunc(123.456,1)from dual; -- '123.4'select trunc(123.456)from dual; -- '123'--decimal_scale为负，向整数位截取补零select trunc(123.456,-1)from dual; -- '120'select trunc(123.456,-2)from dual; -- '100'--截取时间--默认截取，等价于 trunc(sysdate, 'dd')select trunc(sysdate) from dual; --结果：'2018/11/22'--返回当年第一天select trunc(sysdate,'YYYY')from dual; --结果：'2018/1/1'--返回当月第一天select trunc(sysdate,'MM')from dual; --结果：'2018/11/1'--返回当前星期的第一天(星期天)select trunc(sysdate,'D')from dual; --结果：'2018/11/18' Oracle其他 有关时间的方法： --在系统时间基础上延迟5月 select add_months(sysdate,-5) from dual t; --结果：'2018/6/22 11:09:36' --下个星期一的日期 select next_day(SYSDATE,2) from dual --结果：'2018/11/26 11:11:50' -- 1 2 3 4 5 6 7 --日 一 二 三 四 五 六 --减1月 select sysdate, add_months(sysdate,-1) from dual; --减 1星期 select sysdate, to_char(sysdate-7,'yyyy-mm-dd HH24:MI:SS') from dual; --加 1天 select sysdate, to_char(sysdate+1,'yyyy-mm-dd HH24:MI:SS') from dual; --减1小时 select sysdate, to_char(sysdate-1/24,'yyyy-mm-dd HH24:MI:SS') from dual; --减1分钟 select sysdate, to_char(sysdate-1/24/60,'yyyy-mm-dd HH24:MI:SS') from dual; --减1秒 select sysdate, to_char(sysdate-1/24/60/60,'yyyy-mm-dd HH24:MI:SS') from dual;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle-学习1-SQL语言基础]]></title>
    <url>%2F2018%2F11%2F06%2FOracle%E5%AD%A6%E4%B9%A01-SQL%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[先建两张表：部门表，员工表。123456789101112131415create table DEPARTMENT( department_no VARCHAR2(10) not null, department_name VARCHAR2(100))-- 添加主键约束alter table departmentadd constraint pk_dept_no primary key(department_no);comment on table departmentis '部门表';comment on column department.department_nois '部门编号';comment on column department.department_nameis '部门名称'; 12345678910111213141516171819202122232425262728create table EMP( emp_id VARCHAR2(4) not null, emp_name VARCHAR2(100), hire_date VARCHAR2(10), department_no VARCHAR2(10))--修改字段 emp_id名称为 emp_noalter table emprename column emp_id to emp_no;--添加 外键约束（普通外键约束）alter table EMP add constraint FK_DEPT_NO foreign key (department_no) references department (department_no);--删除约束条件alter table empdrop constraint fk_dept_no;--重新添加 外键约束（级联外键约束） alter table EMP add constraint FK_DEPT_NO foreign key (department_no) references department (department_no) on delete cascade;comment on table empis '员工表'; 两种形式的外键约束：1、普通外键约束（如果存在A表引用B表主键，则无法删除B表中被引用记录）2、级联外键约束（可以删除B表中被引用的记录，但是同时会把对应的A表中的记录也删除） 创建结果：1234select ut.table_name "表名", utc.comments, uo.created "表创建时间", uo.last_ddl_time "表修改时间"from user_tables ut left join user_tab_comments utc on(utc.TABLE_NAME=ut.table_name)left join user_objects uo on(ut.table_name=uo.object_name)order by uo.last_ddl_time desc; 1 where 子句在 Oracle ， where子句中 不能用 “=NULL” ，只能用 “is NULL” 或 “is NOT NULL”。但是，更新表时，set子句 可以用 “=null”，例如：123update empset salary=nullwhere salary = 0.00; 空值函数 NAV 和 NVL2 ：nvl(str, replace_with) , 若 str 为空，则取 replace_with 的值。否则不变。nvl2(str, str2, replace_with), 若 str 为空，则取 replace_with 的值。否则取 str2 的值。 为了方便测试，给 emp表 添加一个 salary 字段：12alter table emp add salary number(10,2); 1select * from emp; 结果： 测试：若工资为空，则置为0，否则置为 10000。12select nvl2(salary,10000,0) from emp; 结果：12341000010000100000 where 子句中的 比较运算符 ： &gt; 大于， &gt;= 大于等于 &lt; 小于， &lt;= 小于等于 = 等于， &lt;&gt; 不等于 查看在 2018年1月1日 之前 入职的员工：12select * from emp where to_date(hire_date,'yyyy-mm-dd') &lt; to_date('2018-1-1','yyyy-mm-dd'); where 子句中的 逻辑运算符 ： not ，如果原条件为真，则得到假。如果原条件为假，结果为真。 and ，如果左右两个条件都为真，则得到的值就为真。 or ， 只要左右两个条件有一个为真，则得到的值就为真。 注意： and 的优先级高于 or。 Oracle 运算符的优先级(由高到低)： 算术运算符(即‘+’,‘-’，‘*’,‘/’) 连接运算符（即‘||’） 比较运算符（即‘&gt;’，‘&gt;=’，‘&lt;’，‘&lt;=’，‘&lt;&gt;’） Is [not] null,[not] like,[not] in [not] between-and 逻辑运算符: not 逻辑运算符: and 逻辑运算符: or where 子句中的 模糊查询 ： like ， like 匹配有 两个通配符：一个是 “-“ 用于 “标识单个字符，只能是一个字符”。一个是 “%“ 用于 “标识 0 到多个字符”。 例：查找员工名字含有 字符e 的员工12select * from emp where emp_name like '%e%'; 查找 01 和 02 号部门中的所有员工123456select * from emp where emp.department_no in ('01','02');--等价于select * from emp where emp.department_no = '01' or emp.department_no='02'; &gt;any 演示：123--工资 大于8000 的员select * from emp where salary &gt;all (4000,5000,8000); ALL 和 ANY : &gt;ALL ，大于最大 &lt;ALL ，小于最小 &gt;ANY ，大于最小 &lt;ANY ，小于最大 2 排序查表 emp，按照 工资降序 排列：1234select * from emp where salary is not null order by salary desc; 结果： 查表 emp，按照 工资降序 同时 入职日期从早到晚(从小到大) 排列：1234select * from emp where salary is not null order by salary desc, hire_date; 结果： 注意： order by 必须出现在 select 中的最后一句。 order by 的排序条件是多列时，左边的排序优先级 高于 右边。 3 聚合函数(分组函数)聚合函数也叫分组函数。 3.1 聚合函数(分组函数)聚合函数(分组函数)的特点：1、 多行数据参与运算返回一行结果。2、 主要用于统计。 五个聚合函数：1、 最值， MAX 和 MIN。可以统计任何数据类型， 包括数字，字符，日期。2、 平均值， AVG。聚合函数会忽略空值，注意！3、 求和，SUM 。4、 统计记录条数，count。一般用 count(1) 或 count(*)。 示例：查询员工最晚(最大)入职日期123select max(hire_date) from emp;--结果：'2018-7-3' 查询员工平均工资123select avg(nvl(salary,0)) from emp;--结果：'11040' 查询员工个数123select count(1) from emp;--结果：'10' 注意：聚合函数不能直接写在 where子句中。 3.2 分组查看每个部门的薪水总和：按部门 分组，在对组内数据使用 聚合函数(分组函数) ，计算之后每组返回一条数据。 1234select department_no,sum(salary) sum_salary from emp group by department_no order by sum_salary desc; 注意： 若 group by 中出现多列，那么会按照这几列的 组合值相同的数据 看做一组。 分组分出的小组有多少，结果集就有多少条。 只有在 group by 子句中出现的字段，才能 直接 写在 select 子句中。 分组 常常和 分组函数 一起使用：1234--根据部门分组，计算每个部门的最高/低工资，平均工资，工资总和select max(salary),min(salary),avg(salary),sum(salary) from emp group by department_no; having 为 group by 添加过滤条件：12345678910111213select department_no, count(*) from emp group by department_no;--结果：-- 01 4-- 02 6select department_no, count(*) from emp group by department_nohaving count(*)&gt;4;--结果：-- 02 6 4 提高查询效率查询语句的执行顺序： from 子句。从右往左。 where 子句。从右往左。将能过滤掉最大数量记录的条件写在 where 子句的最右边。 group by。从左往右。最好在 group by 之前使用 where 将不需要的记录在 group by 之前过滤掉。 having。消耗资源，尽量避免使用。 select。 尽量不要使用 星号(*)。 order by。从左往右排序。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle问题引发的思考]]></title>
    <url>%2F2018%2F11%2F05%2FOracle%E9%97%AE%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[问题描述：如下图，有两张表 emp 和 emp_history，现在想把 emp 中的数据拷贝到 emp_history 中，同时添加一个日期字段。两张表的主键都是id，所以只拷贝id不同的。 只拷贝，不考虑主键的话：12insert into emp_historyselect e.*,to_char(sysdate,'yyyy-mm-dd') from emp e; 如何判断 emp 中的数据在 emp_history 中是否存在？(id相同的数据)我首先想到的是 when then , 然后想用一个存储过程实现，如果存在就不插入，不存在就插入。但是当我无法实现的时候，我才想到了 exists 。事实上，用 exists 可以很容易实现查找出重复 id 的数据：1234select e.*,to_char(sysdate,'yyyy-mm-dd')from emp ewhere not exists ( select 1 from emp_history eh where eh.id=e.id); 问题解决：12345insert into emp_historyselect e.*,to_char(sysdate,'yyyy-mm-dd')from emp ewhere not exists ( select 1 from emp_history eh where eh.id=e.id ); 思考：Oracle 你真的熟稔于心了哇？]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java正则表达式-预查]]></title>
    <url>%2F2018%2F11%2F02%2Fjava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E9%A2%84%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[应用场景：解析报文(xml文件)，去除字段的空白字符(空白字段，字段首尾空白)。 思想：利用正则表达式的 预查 定位到各个字段，并匹配到字段的空白字符，替换之。 实现如下：12345678910111213141516171819public static void main(String[] args) &#123; StringBuilder builder=new StringBuilder(); builder.append("&lt;name type='string'&gt;cx &lt;/name&gt;\n"); builder.append("&lt;age&gt; &lt;/age&gt;\n"); builder.append("&lt;hight&gt; 1.72 &lt;/hight&gt;\n"); builder.append("&lt;weight&gt; 56&lt;/weight&gt;\n"); builder.append("&lt;sex&gt; m a n &lt;/sex&gt;"); System.out.println(builder.toString()); System.out.println("=====去除空串字段的空白字符======"); String s=builder.toString().replaceAll("(?&lt;=&gt;)\\s+(?=&lt;)", ""); System.out.println(s); System.out.println("=====去除所有字段的 首尾空白字符======"); //除去空白字段，和首标签后的空白字符 String s1=builder.toString().replaceAll("(?&lt;=&gt;)\\s+(?=(\\w|&lt;))", ""); System.out.println(s1); //除去尾标签前的空白字符 s1=s1.replaceAll("(?&lt;=\\w)\\s+(?=&lt;)", ""); System.out.println(s1);&#125; 结果： 分析：正向预查 strRE(?=regex)，查出前面的strRE，regex只做参考不做匹配。反向预查 (?&lt;=regex)strRE，查出后面的strRE，regex只做参考不做匹配。 1. 正向预查利用正则表达式正向预查匹配出 后面带数字Windows，如下：Windows 1.03 and Windows 2.0 fisrt Released in 1985 and 1987 respectively.Windows 95 and Windows 98 are the successor.Then Windows 2000 and Windows Xp appeared.Windows Vista is the Latest version of the family. 正则表达式：Windows (?=[\d.]+\b)\d 表示匹配一个数字 结果：后面带有数字的 Windows 被匹配出来(只匹配Windows，不含数字)，不带数字Windows的不匹配。 可以这样理解匹配过程： 先进行普通匹配：Windows ([\d.]+\b) 然后从匹配结果中将 子模式 内的文本([\d.]+\b)排除掉 2. 反向预查匹配出 “CNY:” 后面的金额：CNY: 128.04USD: 22.5USD: 23.5HKD: 1533.5CNY: 23.78 正则表达式：(?&lt;= CNY: )\d+.\d+ 可以这样理解上面的匹配过程： 先进行普通匹配：(CNY: )\d+.\d+ 然后从匹配文本中将 子模式 内的文本(CNY: )排除掉。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java运算符instanceof]]></title>
    <url>%2F2018%2F11%2F02%2Fjava%E8%BF%90%E7%AE%97%E7%AC%A6instanceof%2F</url>
    <content type="text"><![CDATA[关键字 instanceof 用于 判断一个对象是否是 某一指定类型1if (objectReference instanceof type) 例如：123456public static void main(String[] a) &#123; String s = "Hello"; if (s instanceof java.lang.String) &#123; System.out.println("is a String"); &#125;&#125; 结果：1is a String 下面看一个常用的 instanceof 示例： 123456789101112131415161718192021public class Person &#123; //属性略 public void printInterest() &#123; System.out.println(interest); &#125;&#125;public class Student extends Person &#123; //属性略 public void printScore() &#123; System.out.println(score); &#125;&#125;public class Teacher extends Person&#123; //属性略 public void printTeache() &#123; System.out.println(teache); &#125;&#125; 12345678910111213141516public static void main(String[] args) &#123; Person person=new Student("cx",24,new BigDecimal("172"),"show","12345",100); //Person person=new Teacher("lyy",34,new BigDecimal("165"),"teache","00001","math"); if(person instanceof Student) &#123; System.out.print("分数："); ((Student) person).printScore(); &#125;else &#123; System.out.println("the person is not a student "); &#125; if(person instanceof Teacher) &#123; System.out.println("教学："); ((Teacher) person).printTeache(); &#125;else &#123; System.out.println("this person is not a teacher"); &#125; &#125; 结果： 12分数：100this person is not a teacher 分析：在此例中，我们知道，person 只能调用 Person 类的方法，不能调用 Student 类的方法。 person 要调用其子类 Student 的方法的话，必须强转为 Student 类型。 如果 person 是 Student 实例化来的，那么强转为 Student 没问题。如果 person 是 Teacher 实例化来的，那么强转为 Student 会报错。 所以，父类对象/引用 强转为 子类类型 时，应当用instanceof 判断是否可以强制转换。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java时间处理]]></title>
    <url>%2F2018%2F11%2F01%2Fjava%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[0 前言过去世界各地原本各自订定当地时间，但随着交通和电讯的发达，各地交流日益频繁，不同的地方时间，造成许多困扰。于是，在1884年的国际会议上制定了全球性的标准时，明定以英国伦敦 格林威治 这个地方为 零度经线 的起点，并以地球由西向东每24小时自转一周360°，订定每隔经度15°，时差1小时。 三个时间标准：1、 格林威治标准时间 GMT (Greenwich Mean Time):全球都以格林威治的时间作为标准来设定时间。2、 世界协调时间UTC (Coordinated Universal Time):UTC的本质强调的是比GMT更为精确的世界时间标准。3、 CST时间:CST却同时可以代表如下 4 个不同的时区: Central Standard Time (USA) UT-6:00 Central Standard Time (Australia) UT+9:30 China Standard Time UT+8:00 北京时间 Cuba Standard Time UT-4:00 古巴 注：时间比较一般说更早，更晚。以1970 年 1 月 1 日 00:00:00 GMT 到目前的毫秒数作为参考的话，可以说 早 一点的时间 小，晚 一点的时间 大。比如，2018&gt;1995 1 java.util.Date 类说到 java 时间，大家都知道 Date 类型。Date 有许多方法都已经不建议使用了(deprecated)，但是 Date 依然是一个最基本的时间类。 1.1 Date 常用的方法Date 常用的方法有以下三个： 1、获取当前系统时间123Date date=new Date();System.out.println(date);// 结果： Thu Nov 01 10:58:58 CST 2018 2、 获取时间date 与 1970 年 1 月 1 日 00:00:00 GMT 差的毫秒值12//long getTime()long timeMs=date.getTime(); 直接获取当前系统时间 与 1970 年 1 月 1 日 00:00:00 GMT 差的毫秒值：12345long begin1=System.currentTimeMillis();//等价写法，begin1 == begin2Date date=new Date();long begin2=date.getTime(); 3、 两个时间比较大小12//int compareTo(Date anotherDate)date1.compareTo(date2) 结果：date1 比 date2 小(早)，则返回 -1date1 比 date2 大(晚)，则返回 1相等，返回0 1.2 Date 和 String 相互转换java.text.SimpleDateFormat 格式化时间12//SimpleDateFormat(String pattern)SimpleDateFormat format=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); SimpleDateFormat 时间格式(pattern)的含义 :yyyy 四位年。MM 月。dd 天。HH 24小时制时，hh是12小时制时。mm 分。ss 秒。SSS 毫秒 1.2.1 format 将Date转为String123456Date date = new Date();System.out.println("date: "+date);//时间格式SimpleDateFormat format=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");String sdate=format.format(date);System.out.println(sdate); 结果：12date: Thu Nov 01 14:52:47 CST 20182018-11-01 14:52:47 1.2.2 parse 将String转为Date在上一小节中，format 把 Date 转为 String 没有问题。 parse 把 String 转为 Date 时，如果 String 不符合 SimpleDateFormat 的格式，将会抛出 ParseException 异常。所以字符串转Date需要try-catch。 1234567String s="2018-11-11 9:9:9:123";try &#123; Date date2=format.parse(s); System.out.println("date2: "+date2);&#125; catch (ParseException e) &#123; e.printStackTrace();&#125; 结果：1date2: Sun Nov 11 09:09:09 CST 2018 2 时间的计算抽象类(abstract class) Calendar 提供了丰富的计算时间的方法。 2.1 初识Calendar一个例子，通过 GregorianCalendar 对象的 getTime 方法获取当前系统时间：123456789SimpleDateFormat format=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");//GregorianCalendar 继承自 Calendar，实现了所有抽象方法Calendar calendar=new GregorianCalendar();//Calendar calendar=Calendar.getInstance();//获取Date. (Calendar的getTime返回 Date类型， Date的getTime返回 long类型)Date date=calendar.getTime();System.out.println(format.format(date)); 结果：12018-11-01 15:23:48 2.2 Calendar 计算时间2.2.1 天数加减计算：1void add(int field, int amount) field 是日期字段类型， amount 表示时间的偏移总量。 field 可用的名称如下，进行时间的运算离不开这些 field ：12345678910111213141516171819private static final String[] FIELD_NAME = &#123; "ERA", "YEAR", // &lt;------年 "MONTH", // &lt;----月 "WEEK_OF_YEAR", "WEEK_OF_MONTH", "DAY_OF_MONTH", // &lt;-- 月中日( (几月)几号 ) "DAY_OF_YEAR", // &lt;-- 年中日 "DAY_OF_WEEK", // &lt;-- 周中日( 周几 ) "DAY_OF_WEEK_IN_MONTH", "AM_PM", "HOUR", "HOUR_OF_DAY", "MINUTE", "SECOND", "MILLISECOND", "ZONE_OFFSET", "DST_OFFSET"&#125;; DAY_OF_YEAR，DAY_OF_MONTH，DAY_OF_WEEK 在下面的例子中效果是相同的。原因它们在于 add方法 的内部实现是一样的 ( 为了便于理解，建议使用 DAY_OF_YEAR )。但是这3个 field 用在别的方法中时，含义就不同了，如 get、set方法。1234567891011121314public static void main(String[] args) &#123; SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Calendar calendar = new GregorianCalendar(); // 34天前，calendar对象的时间被修改为 34天前 calendar.add(Calendar.DAY_OF_YEAR, -34); System.out.println(format.format(calendar.getTime())); // 34天后，calendar对象的时间 又回到原值 calendar.add(Calendar.DAY_OF_MONTH, 34); System.out.println(format.format(calendar.getTime())); // 64天后，calendar对象的时间被修改为 64天后 calendar.add(Calendar.DAY_OF_WEEK, 64); System.out.println(format.format(calendar.getTime()));&#125; 结果如下，当前时间是 2018-11-01 16:00:42 :1232018-09-28 16:00:422018-11-01 16:00:422019-01-04 16:00:42 2.2.2 年月加减计算还是 add 函数，只是 field_name 改了。123456789101112public static void main(String[] args) &#123; SimpleDateFormat format=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Calendar cal=new GregorianCalendar(); System.out.println("当前时间："+format.format(cal.getTime())); cal.add(Calendar.MONTH, 3); System.out.println("3个月后："+format.format(cal.getTime())); cal.add(Calendar.MONTH, -12); System.out.println("12个月前："+format.format(cal.getTime())); cal.add(Calendar.YEAR, -10); System.out.println("10年前："+format.format(cal.getTime()));&#125; 结果：1234当前时间：2018-11-01 16:44:363个月后：2019-02-01 16:44:3612个月前：2018-02-01 16:44:3610年前：2008-02-01 16:44:36 2.2.3 其他操作1、 Calendar 的 get 和 set 方法1234567891011//获取日期的每部分int year =calendar.get(Calendar.YEAR); int month=calendar.get(Calendar.MONTH)+1; //月份从0开始int day =calendar.get(Calendar.DAY_OF_MONTH); int hour =calendar.get(Calendar.HOUR_OF_DAY); int minute =calendar.get(Calendar.MINUTE); int second =calendar.get(Calendar.SECOND); //日期在年的第几周int weekOfYear = calendar.get(Calendar.WEEK_OF_YEAR);//周几，1-周日，2-周一，3-周二... 7-周六int dayOfWeek=calendar.get(Calendar.DAY_OF_WEEK); 上面列举了get方法。 set 用于设置时间，不再举例。 2、获取月的总天数1int day=calendar.getActualMaximum(Calendar.DAY_OF_MONTH); 3、两个日期之间相隔的天数12// date1 和 date2 为 Date类型long day=(date1.getTime()-date2.getTime())/(24*60*60*1000); 4、9月份第一个星期一是几号12345678910111213141516public static void main(String[] args) &#123; SimpleDateFormat format=new SimpleDateFormat("yyyy-MM-dd"); Calendar calendar=new GregorianCalendar(); //设置时间为9月1号 calendar.set(Calendar.MONTH, Calendar.SEPTEMBER); //8 int day=1; calendar.set(Calendar.DAY_OF_MONTH, day); System.out.println(format.format(calendar.getTime())); //遍历直到第一个星期一 while(calendar.get(Calendar.DAY_OF_WEEK)!=Calendar.MONDAY) &#123; calendar.set(Calendar.DAY_OF_MONTH, ++day); &#125; System.out.println(format.format(calendar.getTime())); System.out.println(calendar.getTime());&#125; 结果:1232018-09-012018-09-03Mon Sep 03 18:52:07 CST 2018]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java运算java.math.BigDecimal]]></title>
    <url>%2F2018%2F10%2F31%2Fjava%E8%BF%90%E7%AE%97java-math-BigDecimal%2F</url>
    <content type="text"><![CDATA[空值可以强转为 BigDecimal 类型 ：123Object a=null;BigDecimal b=(BigDecimal)a;//b=null 调用b时，注意非空判断。 BigDecimal常用的构造方法：12345BigDecimal(double val) BigDecimal(int val)BigDecimal(long val)BigDecimal(char[] in)BigDecimal(String val) // 建议使用 参考java API .参数类型为double的构造方法的结果有一定的不可预知性。new BigDecimal(0.01) 结果是：0.010000000000000000208…而 new BigDecimal(“0.01”) 就是 0.01 。 1. 加减乘除123456//加add(BigDecimal)//减 subtract(BigDecimal) //乘multiply(BigDecimal) 加减乘除 其实最终都返回的是一个新的BigDecimal对象，因为BigInteger与BigDecimal都是不可变的（immutable）的，在进行每一步运算时，都会产生一个新的对象。所以a.add(b);虽然做了加法操作，但是a并没有保存加操作后的值，正确的用法应该是a=a.add(b); 加减乘一般不用考虑精度，而 除法需要考虑精度 (scale) 问题，BigDecimal 的除法重载了6次，一般用下面的方法就够了：12//除BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) 例子：123BigDecimal b1=new BigDecimal("100");BigDecimal b3=new BigDecimal("3");System.out.println(b1.divide(b3, 10, BigDecimal.ROUND_HALF_UP)); 结果：133.3333333334 分析: 精度scale=10，保留10位小数。 BigDecimal.ROUND_HALF_UP 四舍五入。 BigDecimal 提供了 8 中 舍入模式(Rounding mode)：12345678public final static int ROUND_UP = 0; //public final static int ROUND_DOWN = 1; //public final static int ROUND_CEILING = 2;public final static int ROUND_FLOOR = 3;public final static int ROUND_HALF_UP = 4; //public final static int ROUND_HALF_DOWN = 5;public final static int ROUND_HALF_EVEN = 6;public final static int ROUND_UNNECESSARY = 7; 常用的有： ROUND_UP 进一法(不论保留位是多少，都进一) ROUND_DOWN 截断法(不论保留位是多少，都舍弃) ROUND_HALF_UP 四舍五入法(保留位大于等于5进一，否则就舍弃) ROUND_HALF_DOWN 五舍五入(保留位及以后位大于5进一，否则舍弃) ROUND_HALF_UP 和 ROUND_HALF_DOWN 很像，只是在对5 的进位尺度有一点点不同。比如，3.0500 保留两位小数：ROUND_HALF_UP：3.1ROUND_HALF_DOWN：3.0 3.0501 保留两位小数：ROUND_HALF_UP：3.1ROUND_HALF_DOWN：3.1 2. 设置精度1BigDecimal setScale(int newScale, int roundingMode) newScale : 精度，保留小数的位数。RoundingMode : 进位模式，上面 8 种模式之一。 3. 比较大小对比：Returns:-1, 0, or 1 as this BigDecimal is numerically less than, equal to, or greater than val.1int compareTo(BigDecimal val) 说明：a.compareTo(b) 若a&gt;b : 返回1 若a=b : 返回0 若a&lt;b : 返回-1 4. 其他乘方：Returns a BigDecimal whose value is (this^n), The power is computed exactly, to unlimited precision.1BigDecimal pow(int n) 取绝对值：Returns a BigDecimal whose value is the absolute value of this BigDecimal, and whose scale is this.scale().1BigDecimal abs() 取反：Returns a BigDecimal whose value is (-this),and whose scale is this.scale().1BigDecimal negate()]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java正则表达式-1]]></title>
    <url>%2F2018%2F10%2F30%2Fjava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[java.util.regex 下有两个类，Pattern 和 Matcher 。 1. 抛砖引玉 Pattern.matchesPattern.matches(regex,str) 要求 字符串str 完全符合 匹配规则(字符串)regex ，返回结果才为 true。123456789101112131415public static void main(String[] args) &#123; String str="A compiled representation of a regular expression."; String regex=".*re.*"; boolean b=Pattern.matches(regex, str); System.out.println("是否包含字符串re: "+b); //Pattern.matches(regex, str) 等价于Pattern.compile(regex).matcher(str).matches() boolean b2=Pattern.compile(regex).matcher(str).matches(); System.out.println(b2); System.out.println(Pattern.matches("re", "A compiled representation of a regular expression."));//false System.out.println(Pattern.matches("\\d+","123")); //true System.out.println(Pattern.matches("\\d+","123a")); //false System.out.println(Pattern.matches("\\d+","123a456")); //false &#125; 正则表达式，就是一个指定匹配规则的字符串，这个字符串(正则表达式)必须被编译成 Pattern类的实例 才能创建 Matcher 对象。正则表达式先编译成 Pattern实例 再创建 Matcher对象有一个好处：多个 matcher 可以共享一个 pattern，达到复用的效果。如下，引用 java API 提供的例子:123Pattern p = Pattern.compile("a*b");Matcher m = p.matcher("aaaaab");boolean b2 = m.matches(); //true 下面的写法与上面等价，其内部实现就是上面三行代码，只是 一个匹配的简写 罢了：1boolean b1 = Pattern.matches("a*b", "aaaaab"); //true 2. Groups and capturing 捕获组通过 从左到右 数开头圆括号，对捕获组进行编号。例如下面的正则表达式 捕获组 ：( (A) (B (C)) )1 &emsp;((A)(B(C)))2 &emsp;(A)3 &emsp;(B(C))4 &emsp;(C)0 &emsp;整个字符串，((A)(B(C))) 捕获组的例子：123456789101112131415161718192021public static void main(String[] args) &#123; String str="for example, there are four such groups"; String regex="((.*)(,)(.*))"; Pattern pattern=Pattern.compile(regex); Matcher m=pattern.matcher(str); if(m.find()) &#123; System.out.println("start: "+m.start()); System.out.println("end: "+m.end()); System.out.println("group : "+m.group()); System.out.println("group等价于: "+"str.substring(m.start(),m.end())"); System.out.println(str.substring(m.start(),m.end())); System.out.println("------"); System.out.println("group1 : "+m.group(1)); System.out.println("group2 : "+m.group(2)); System.out.println("group3 : "+m.group(3)); System.out.println("group4 : "+m.group(4)); System.out.println("group0 : "+m.group(0)); &#125;else &#123; System.out.println("字符串与正则表达式 不完全匹配"); &#125;&#125; 结果： Matcher 的 find() 函数 的两个特点：1、 如果正则表达式里 包含 分组。那么，find()函数 会对 str 与 regex 做完全匹配。若匹配上，返回 true，此时可以通过 group(int i) 来访问每一个组；若未匹配上，返回 false 。2、 如果正则表达式 不包含 分组。那么，find()函数 会对 str 与 regex 做 不完全 匹配。即只要 str 中包含 regex 就会返回 true。此时可以通过 group() 来访问匹配到的 regex (注：str中可能有多个regex，第一次find只能获取到第一个匹配，第二次find获取到第二个，以此类推)，regex在str中的起始位置可以通过 start() 和 end() 获得。 find() 函数 的第 2 个特点，看例子会更清楚：123456789101112131415public static void main(String[] args) &#123; String str1="A compiled representation of a regular expression."; String regex1="re"; Pattern p=Pattern.compile(regex1); Matcher m1=p.matcher(str1); if(m1.find()) &#123; System.out.println("m1.start: "+m1.start()); System.out.println("m1.end: "+m1.end()); System.out.println("m1.group(): "+m1.group()); System.out.println(str1.substring(m1.start(), m1.end()));//与上等价写法 System.out.println("m1.group(0): "+m1.group(0)); // group(1..n)会报错 System.out.println("====="); &#125;&#125; 结果：123456m1.start: 11m1.end: 13m1.group(): rerem1.group(0): re===== 如果把if 换成 while， 结果：123456789101112131415161718192021222324m1.start: 11m1.end: 13m1.group(): rerem1.group(0): re=====m1.start: 14m1.end: 16m1.group(): rerem1.group(0): re=====m1.start: 31m1.end: 33m1.group(): rerem1.group(0): re=====m1.start: 42m1.end: 44m1.group(): rerem1.group(0): re===== 分析：“ A compiled representation of a regular expression. “这句话有4个 re ，但是第一次 find ，group() 只能匹配到下标为[11,13)的第一个字符串。后面3个 需要多次find 获得。 看一个实际应用的例子：把字符串 “$year$ $month$ $day$” 中的年月日换成真实的年月日。123456789101112131415161718192021public static void main(String[] args) &#123; Map&lt;String,String&gt; map=new HashMap&lt;String,String&gt;(); map.put("year", "2018"); map.put("month", "10"); map.put("day","30"); String str="$year$ $month$ $day$"; //String regex="\\$[^\\$]+\\$"; String regex="\\$.*?\\$"; Pattern p=Pattern.compile(regex); while(true) &#123; Matcher m=p.matcher(str); if(!m.find()) break; String group=m.group(); String param=group.replaceAll("\\$",""); //System.out.println(param); str=str.replace("$"+param+"$",map.get(param)); &#125; System.out.println(str);&#125; 结果：12018 10 30 分析： regex=”\\$.*?\\$” 问号表示 非贪婪匹配 ，默认是贪婪匹配。 regex=”\\$[^\\$]+\\$” 也可以完成此例，这是参照公司框架代码的写法。 此例关键在于，循环多次find，每次把第一个替换掉，这样可以遍历到所有的匹配到的字符串。 3. Pattern 的方法-splitString[] split(CharSequence input)String 实现了 CharSequence 接口，因此可以给split传一个 String 参数。 12Pattern p=Pattern.compile("\\++");String[] str=p.split("1+1+2+3"); 结果：1234str[0]=1str[1]=1str[2]=2str[3]=3 String 也有一个 split 方法 ：String[] split(String regex) 4. 附录4.1 常用正则表达式 规则 正则表达式语法 一个或多个汉字 ^[\u0391-\uFFE5]+$ 邮政编码 ^[1-9]\d{5}$ 邮箱 ^[a-zA-Z_]{1,}[0-9]{0,}@(([a-zA-z0-9]-*){1,}.){1,3}[a-zA-z-]{1,}$ 用户名（字母开头 + 数字/字母/下划线） ^[A-Za-z][A-Za-z1-9_-]+$ 手机号码 ^1[3 &#124;4&#124;5&#124;8][0-9]\d{8}$ URL ^((http &#124;https)://)?([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 18位身份证号 ^(\d{6})(18&#124;19&#124;20)?(\d{2})([01]\d)([0123]\d)(\d{3})(\d&#124;X&#124;x)?$ 4.2 正则表达式语法参见]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习7-Spring JDBC]]></title>
    <url>%2F2018%2F10%2F23%2FSpring%E5%AD%A6%E4%B9%A07-Spring-JDBC%2F</url>
    <content type="text"><![CDATA[0. 前言最原始的(不考虑ORM框架，不考虑Spring JDBC)，我们用 JDBC 操作数据库通常是以下几步： 连接数据库：加载驱动，根据url，用户名，密码连接数据库。(初始化连接池) 获取connection。 获取statement。 增删改查，提交。(查询返回ResultSet) 关闭连接 通常，我们会编写一个 DBUtils 类来管理连接，然后编写 DAO 封装增删改查方法。 因为更简便、耦合度低的操作数据库的框架出现，现在人们开发程序很少直接用 JDBC 了。本文介绍 Spring 提供的 API JdbcTemplate ，后面再介绍 MyBatis 框架。JDBCTemplate 封装了获取连接，执行SQL，释放连接等操作。 1. Spring 与 JDBC 整合Spring 提供了： JdbcTemplate AOP事务管理 统一异常处理 DataAccessException Spring + JDBC 开发步骤： 搭建开发环境：引入各种jar包，包括Spring(Core，AOP，DAO) ,连接池dbcp，JDBC包等。 编写实体类domain 编写Dao数据库操作逻辑 applicationContext.xml 中配置，扫描Dao组件，注入 JdbcTamplate 对象 举个例子：1、搭建开发环境，略。2、 编写 domain 类：12345678910package cn.mitrecx.domain;import java.math.BigDecimal;public class Emp &#123; private Integer id; private String name; private Integer age; private BigDecimal salary; //get set方法略&#125; 3、 Dao数据库操作：12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.mitrecx.dao;import java.util.List;import javax.annotation.Resource;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import cn.mitrecx.domain.Emp;@Repository //扫描到Spring容器public class EmpDao &#123; @Resource private JdbcTemplate template; /** * 向MySQL数据库emp表中插入一条数据 * @author cx * @param emp 实体对象 * @time 上午8:43:02 */ public void insert(Emp emp) &#123; String sql="insert into emp(name,age,salary) values(?,?,?)"; Object[] param= &#123;emp.getName(),emp.getAge(),emp.getSalary()&#125;; //update 可用在 增删改 template.update(sql, param); &#125; public void deleteById(int id) &#123; String sql="delete from emp where id=?"; Object[] param= &#123;id&#125;; template.update(sql, param); &#125; public void deleteByName(String name) &#123; String sql="delete from emp where name=?"; Object[] param= &#123;name&#125;; template.update(sql, param); &#125;//查找 public List&lt;Emp&gt; queryAll()&#123; String sql="select * from emp"; EmpRowMapper empRowMapper=new EmpRowMapper(); //自定义RowMapper List&lt;Emp&gt; list=template.query(sql, empRowMapper); return list; &#125;&#125; 查找时，需要RowMapper参数，用于把数据库字段和domain字段对应：12345678910111213141516171819package cn.mitrecx.dao;import java.sql.ResultSet;import java.sql.SQLException;import org.springframework.jdbc.core.RowMapper;import cn.mitrecx.domain.Emp;public class EmpRowMapper implements RowMapper&lt;Emp&gt; &#123; @Override public Emp mapRow(ResultSet resultSet, int index) throws SQLException &#123; Emp emp=new Emp(); emp.setId(resultSet.getInt("id")); emp.setName(resultSet.getString("name")); emp.setAge(resultSet.getInt("age")); emp.setSalary(resultSet.getBigDecimal("salary")); return emp; &#125;&#125; 4、 applicationContext.xml 配置：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd"&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;context:component-scan base-package="cn.mitrecx"/&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp" &gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="template" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;!-- 注入连接信息 --&gt; &lt;property name="dataSource" ref="dbcp"&gt;&lt;/property&gt; &lt;!-- dataSource数据源， 连接池: dbcp,c3p0,proxool --&gt; &lt;/bean&gt; &lt;!-- dbcp连接池 --&gt; &lt;bean id="dbcp" class="org.apache.commons.dbcp2.BasicDataSource"&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="123456"&gt;&lt;/property&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://cherry.mitrecx.cn:3306/DBmitre?useUnicode=true&amp;amp;characterEncoding=utf8"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类：123456789101112131415161718192021222324package cn.mitrecx.dao;import java.math.BigDecimal;import java.util.List;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import cn.mitrecx.domain.Emp;public class TestDao &#123; public static void main(String[] args) &#123; ApplicationContext ac=new ClassPathXmlApplicationContext("applicationContext.xml"); EmpDao empDao=ac.getBean("empDao",EmpDao.class);// Emp emp=new Emp();// emp.setName("李敖");// emp.setAge(23);// emp.setSalary(new BigDecimal("5000"));// empDao.insert(emp);// empDao.deleteByName("李敖"); List&lt;Emp&gt; list=empDao.queryAll(); for(Emp emp1:list) &#123; System.out.println(emp1.getName()+" "+emp1.getAge()); &#125; &#125;&#125; 结果： 2. Spring MVC 与 JDBC template 结合Spring MVC 和 JDBC Template 结合，这不是一个新的知识，只是在 Spring MVC 的基础上，加上 上一节 介绍地 JDBC Template 数据库操作。 直接看一个简单的实例，就清楚怎么写了。 最近，我也在想，一直写简单的例子，什么时候才能掌握Spring ？其实，这应该是一个日积月累的过程。达到一定的量，就会有质的改变。能独立做好无数个简单的例子，就已经在深入学习了。不要怕一直在做简单的例子，应该考虑如何在最短的时间学会更多的简单的例子。。 下面演示利用 JDBC Template 向 MySQL 数据库插入一条数据： 1、servlet 配置文件 web.xml ： 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1"&gt; &lt;display-name&gt;spring11-8-JdbcTemplate&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 2、 操作页面 add.jsp : 12345678910111213&lt;%@page pageEncoding="utf-8" contentType="text/html; charset=utf-8" %&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body style="font-size: 30px;"&gt; &lt;form action="addHandle.do" method="post"&gt; name: &lt;input type="text" name="name"/&gt;&lt;br/&gt; age: &lt;input type="text" name="age"/&gt;&lt;br/&gt; salary: &lt;input type="text" name="salary"/&gt;&lt;br/&gt; &lt;input type="submit" value="提交"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 3、 实体类 Emp.java : 1234567891011package cn.mitrecx.domain;import java.math.BigDecimal;public class Emp &#123; private Integer id; private String name; private Integer age; private BigDecimal salary; //get set 方法略&#125; 4、 数据库操作类 EmpDao.java :DAO类一定要注意 template 成员的值 是由Spring 容器注入的。template 在 applicationContext.xml 中配置。123456789101112131415161718192021package cn.mitrecx.dao;import javax.annotation.Resource;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import cn.mitrecx.domain.Emp;@Repository("empDaoID") //扫描到Spring IoC容器，id为empDaoIDpublic class EmpDao &#123; @Resource(name="template") //注入id为template的bean，已在applicationContext.xml中配置 private JdbcTemplate template; public void insert(Emp emp) &#123; String sql="insert into emp(name,age,salary) values(?,?,?)"; Object[] param= &#123;emp.getName(),emp.getAge(),emp.getSalary()&#125;; //update 可用在 增删改 template.update(sql, param); &#125;&#125; 5、 Spring 配置文件 applicationContext.xml:注意组件扫描 的 base-package 属性，一定要包含所有需要扫描的包。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:util="http://www.springframework.org/schema/util" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd"&gt; &lt;!-- HandlerMapping : 用mvc:annotation-driven包含了多个bean，其中有handlerMapping这个bean --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 扫描controller --&gt; &lt;context:component-scan base-package="cn.mitrecx"&gt;&lt;/context:component-scan&gt; &lt;!-- ViewResolver --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- ViewResolver的前缀后缀属性，用于给controller返回的mav加前后缀 --&gt; &lt;property name="prefix" value="/WEB-INF/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="template" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;!-- 注入连接信息 --&gt; &lt;property name="dataSource" ref="dbcp"&gt;&lt;/property&gt; &lt;!-- dataSource数据源， 连接池: dbcp,c3p0,proxool --&gt; &lt;/bean&gt; &lt;!-- dbcp连接池 --&gt; &lt;bean id="dbcp" class="org.apache.commons.dbcp2.BasicDataSource"&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="123456"&gt;&lt;/property&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://cherry.mitrecx.cn:3306/DBmitre?useUnicode=true&amp;amp;characterEncoding=utf8"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 6、 controller 组件 ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package cn.mitrecx.controller;import java.io.UnsupportedEncodingException;import java.math.BigDecimal;import javax.servlet.http.HttpServletRequest;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import cn.mitrecx.dao.EmpDao;import cn.mitrecx.domain.Emp;@Controllerpublic class ViewController &#123; @RequestMapping("/add.do") public ModelAndView add() &#123; ModelAndView mav=new ModelAndView(); mav.setViewName("add"); return mav; &#125; @RequestMapping("/addHandle.do") public String addHandle(HttpServletRequest request) &#123; try &#123; request.setCharacterEncoding("utf-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; ApplicationContext ac=new ClassPathXmlApplicationContext("applicationContext.xml"); EmpDao empDao=ac.getBean("empDaoID",EmpDao.class); /* *不能直接 new EmpDao() *直接new的对象，无法获取到注入到的成员 template(在applicationContext.xml中定义)。 *****确切的说，直接new的对象，无法获取到Spring容器注入到 此对象 的成员。 */ //EmpDao empDao=new EmpDao(); Emp emp=new Emp(); emp.setName(request.getParameter("name")); emp.setAge(Integer.parseInt(request.getParameter("age"))); emp.setSalary(new BigDecimal(request.getParameter("salary"))); empDao.insert(emp); return "success"; &#125;&#125; 结果：]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习6-过滤器,异常处理,拦截器]]></title>
    <url>%2F2018%2F10%2F17%2FSpring%E5%AD%A6%E4%B9%A06-%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. 过滤器过滤器在介绍 servlet 已经 讲过，这里在讲是为了抛砖引玉，说明 Spring 提供了一些 拦截器 ， 在开发中，我们可以直接拿来用。 用拦截器解决中文乱码问题：从页面表单( utf-8 ) 传到 controller( iso-8859 ) 的中文是乱码的。解决问题很简单，在controller 中加一行代码就能解决。1request.setCharacterEncoding("UTF-8"); 考虑到，每个 controller 都会有编码问题，所以写一个 过滤器 统一处理比较好。 写一个类 MyFilter.java12345678910111213141516171819202122232425262728293031323334353637383940package cn.mitrecx.filter;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class MyFilter implements Filter &#123; private String conf; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; // 拦截方法 @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; //前期逻辑 request.setCharacterEncoding(this.conf); //执行chain.doFilter，程序就会继续向后执行 chain.doFilter(request, response); //后期逻辑 &#125; /** * 启动Tomcat服务器时，加载web.xml里的Filter配置 */ @Override public void init(FilterConfig arg0) throws ServletException &#123; // TODO Auto-generated method stub this.conf=arg0.getInitParameter("encoding"); System.out.println(conf); &#125;&#125; 在 web.xml 中配置过滤器12345678910111213&lt;filter&gt; &lt;filter-name&gt;myFilter&lt;/filter-name&gt; &lt;!-- &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;--&gt; &lt;filter-class&gt;cn.mitrecx.filter.MyFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;myFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 事实上，上面的这个过滤器Spring 已经写好了，我们直接在web.xml 中配置一下就行了。配置方法：用1&lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; 替换1&lt;filter-class&gt;cn.mitrecx.filter.MyFilter&lt;/filter-class&gt; 即可。 CharacterEncodingFilter 这个类在 spring-web-5.0.0.RELEASE.jar 中，在这个jar 包中有十几个过滤器。 2. 异常处理异常处理，我们首先能想到的是 try-catch。这里不用try-catch，用Spring 提供的异常处理机制。有两种处理方法： 全局按异常类型处理，遇到异常直接抛出，统一处理。 局部单独处理。 就 第一种处理方法（全局） 举个例子： controller 123456789101112131415package cn.mitrecx.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class ExceptionController &#123; @RequestMapping("/exception.do") public String execute() throws Exception&#123; String ss=null; //故意制造一个空指针异常，throws Exception，交个容器处理 ss.length(); return "ok"; &#125;&#125; applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:util="http://www.springframework.org/schema/util" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd"&gt; &lt;!-- HandlerMapping --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- controller --&gt; &lt;context:component-scan base-package="cn.mitrecx.controller"&gt;&lt;/context:component-scan&gt; &lt;!-- ViewResolver --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- ViewResolver的前缀后缀属性，用于给controller返回的mav加前后缀 --&gt; &lt;property name="prefix" value="/WEB-INF/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 异常处理器 --&gt; &lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt; &lt;property name="exceptionMappings"&gt; &lt;props&gt; &lt;!-- key是异常类型，value是视图名 --&gt; &lt;prop key="java.lang.Exception"&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 这样，空指针异常将不会出现一个500页面，而是 WEB-INF/error.jsp 呈现的内容。 这个流程可以描绘成下面这幅图： SimpleMappingExceptionResolver 是Spring提供的一个简单的异常处理器，我们可以自己写一个，只要实现 HandlerExceptionResolver接口 就行。 事实上， SimpleMappingExceptionResolver 也是 实现了 HandlerExceptionResolver接口的。 这里给一个demo：写一个异常处理类MyExceptionHandler.java：1234567891011121314151617package cn.mitrecx.exception;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;public class MyExceptionHandler implements HandlerExceptionResolver&#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object arg2, Exception e) &#123; ModelAndView mav=new ModelAndView(); System.out.println("异常信息："+e); mav.setViewName("error"); return mav; &#125;&#125; applicationContext.xml 中配置：1&lt;bean class="cn.mitrecx.exception.MyExceptionHandler"&gt;&lt;/bean&gt; 第二种异常处理方法（局部）：把第一种异常处理方法的 controller 改一下：123456789101112131415161718192021222324252627282930package cn.mitrecx.controller;import javax.servlet.http.HttpServletRequest;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class ExceptionController &#123; @RequestMapping("/exception.do") public String execute() &#123; String ss=null; //故意制造一个空指针异常，throws Exception，交个容器处理 ss.length(); return "ok"; &#125; /** * 这个 异常处理方法只对当前controller起作用， * 方法名自定义，参数固定 * @author cx * @param request * @time 下午11:15:33 */ @ExceptionHandler public String handleException(HttpServletRequest request, Exception e) &#123; return "localError"; &#125;&#125; 此时，当我访问exception.do 时，不会到异常处理页面WEB-INF/error.jsp，而会访问异常处理页面WEB-INF/localError.jsp 3. Spring拦截器组件拦截器组件是 Spring MVC 特有的组件。拦截器组件可以在 controller 之前拦截，也可以在 controller 之后拦截。还可以在 jsp 解析完成后拦截。 拦截器使用步骤： 编写一个拦截器组件，实现 HandlerInterceptor 在applicationContext.xml 中配置拦截器 实现如下：编写拦截器组件1234567891011121314151617181920212223242526272829303132333435363738package cn.mitrecx.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;public class LoginInterceptor implements HandlerInterceptor &#123; //controll 之前，bool 返回false，就会拦截，拦截器后面的组件就不执行了 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("preHandle: 在controll前拦截。"); HttpSession session=request.getSession(); String userName=(String) session.getAttribute("userName"); //登录过 if(userName!=null) &#123; // 按正常流程走 return true; &#125;else &#123; //未登录过，或登录失效 //重定向到登录页面 response.sendRedirect("login.do"); return false; &#125; &#125; // controll 之后 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("postHandle: controll 之后"); &#125; // 请求出来完毕，输出之前 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("afterCompletion..."); &#125;&#125; applicationContext.xml1234567891011&lt;!-- 配置拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 拦截哪些请求，/**表示拦截所有请求 /*表示拦截所有不包含子目录的请求 --&gt; &lt;mvc:mapping path="/**"/&gt; &lt;!-- 放过哪些请求 --&gt; &lt;mvc:exclude-mapping path="/login.do"/&gt; &lt;mvc:exclude-mapping path="/checkup.do"/&gt; &lt;bean class="cn.mitrecx.interceptor.LoginInterceptor"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习5-Spring web MVC]]></title>
    <url>%2F2018%2F10%2F16%2FSpring%E5%AD%A6%E4%B9%A05-Spring-web-MVC%2F</url>
    <content type="text"><![CDATA[1. Spring Web MVC 简介Spring Web MVC 是构建在 Servlet API 上的原始Spring框架。它的正式名称”Spring Web MVC”来自于它的源组件(spring-webmvc)，但是通常我们简称它为 “Spring MVC” 。在Spring Framework 5.0 引入了一个 reactive-stack 的web 框架，其名称为 “Spring WebFlux”，名称同样来自于它的源组件(spring-webflux)，Spring WebFlux 是与Spring MVC 并行存在的(不是Spring MVC的替代)。 Spring MVC 依赖于 Spring IoC 。Spring MVC 用于 开发 具有 MVC 模式的 web应用。 Spring MVC 的 Context Hierarchy(上下文层次体系) 如下，图源来自于Spring官方参考指南 ： 2. Spring MVC 开发步骤 在 web.xml 文件中 配置 DispatcherServlet 在 applicationContext.xml 文件中 配置 HandlerMapping 编写 controller (实现Controller) 在applicationContext.xml中配置注入(或注解注入) 配置 ViewResolver 用于寻找页面展示文件 编写 页面展示文件(jsp、HTML等) 注：导包需要 spring-context-5.0.0.RELEASE.jar spring-core-5.0.0.RELEASE.jar spring-beans-5.0.0.RELEASE.jar commons-logging.jar spring-expression-5.0.0.RELEASE.jar spring-web-5.0.0.RELEASE-sources.jar spring-web-5.0.0.RELEASE.jar spring-webmvc-5.0.0.RELEASE.jar 扩展，以后开发用 standard.jar spring-aop-5.0.0.RELEASE.jar jstl.jar mybatis-3.4.6.jar mysql-connector-java-8.0.12.jar 导包很麻烦？ 先学习下 Maven. 3. Spring MVC 入门实例实例结果: 实现过程如下： 1、 在 web.xml 中配置 DispatcherServlet12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1"&gt; &lt;display-name&gt;spring10-16-MVC1&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 2、 编写controller 组件：处理逻辑12345678910111213141516171819package controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;public class HelloController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ModelAndView mav=new ModelAndView(); //设置返回页面的名称，此名称会经过ViewResolver加工，最终定位到一个文件 mav.setViewName("helloSpring"); //绑定数据，等价于 request.setAttribute mav.getModel().put("msg", "由 mav.getModel().put传出"); return mav; &#125;&#125; 3、 配置HandlerMapping 把请求交给对应的 controller 组件注入controller ，也可以用注解注入配置(注入)ViewResolver 组件，为controller组件定位jsp页面 applicationContext.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:util="http://www.springframework.org/schema/util" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd"&gt; &lt;!-- HandlerMapping --&gt; &lt;bean id="handlermapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;!-- helloController取自controller的id名 --&gt; &lt;prop key="/hello.do"&gt;helloController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- controller --&gt; &lt;bean id="helloController" class="controller.HelloController"&gt; &lt;/bean&gt; &lt;!-- ViewResolver --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- ViewResolver的前缀后缀属性，用于给controller返回的mav加前后缀 --&gt; &lt;property name="prefix" value="/WEB-INF/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 4、 展示页面 helloSpring.jsp1234567891011&lt;%@page pageEncoding="utf-8" contentType="text/html; charset=utf-8" %&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body style="font-size: 30px;"&gt; hello Spring web MVC. &lt;br/&gt; &lt;br/&gt; msg: $&#123;msg &#125; &lt;br/&gt; requestScope.msg: $&#123;requestScope.msg &#125; &lt;/body&gt;&lt;/html&gt; 4. 使用注解改进程序Spring MVC 使用注解开发步骤和前面步骤一样，只是：把applicationContext.xml 中的 handlerMapping 这个 bean 用 mvc:annotation-driven 代替,把 配置controller 用 扫描context:component-scan 代替，controller类里加上注解。 使用注解的好处是方便灵活。 程序实现：web.xml 不变。 applicationContext.xml12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:util="http://www.springframework.org/schema/util" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd"&gt; &lt;!-- HandlerMapping : 用mvc:annotation-driven包含了多个bean，其中有handlerMapping这个bean --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 扫描controller --&gt; &lt;context:component-scan base-package="controller"&gt;&lt;/context:component-scan&gt; &lt;!-- ViewResolver --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- ViewResolver的前缀后缀属性，用于给controller返回的mav加前后缀 --&gt; &lt;property name="prefix" value="/WEB-INF/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; controller组件 helloSpring.java 123456789101112131415161718package controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controllerpublic class HelloController &#123; @RequestMapping("/hello.do") //直接把请求和处理方法关联 public ModelAndView execute() &#123; ModelAndView mav = new ModelAndView(); mav.getModel().put("msg", "注解版"); //返回视图名称 mav.setViewName("helloSpring"); return mav; &#125; /*可以写多个方法，结合RequestMapping注解匹配处理多个请求*/&#125; 页面 helloSpring.jsp12345678910&lt;%@page pageEncoding="utf-8" contentType="text/html; charset=utf-8" %&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body style="font-size: 30px;"&gt; hello Spring web MVC. &lt;br/&gt; &lt;br/&gt; msg: $&#123;msg &#125; &lt;/body&gt;&lt;/html&gt; 结果：]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习4-注解]]></title>
    <url>%2F2018%2F10%2F15%2FSpring%E5%AD%A6%E4%B9%A04-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[JDK 5.0 ，是JDK (Java Development Kit) 具有里程碑的一个版本。2004年发布的。SE(JavaSE): standard edition，从JDK 5.0开始，改名为Java SE。EE(JavaEE): enterprise edition，从JDK 5.0开始，改名为Java EE。JDK 5.0 引入许多新特性，包括泛型(Generic)、可变参数、for-each、注解 等。java SE 8 我上大学那年发布的(2014)。Java SE 10 2018年3月发布。时间过得真快…. 注解 : 在 类的定义，方法的定义，成员变量的定义 前使用，格式为 @注解标记名 。 1. 组件扫描 (component-scan)可以根据包的路径，把包下所有的组件扫描，如果发现组件类定义前有以下标记，将会把组件扫描的Spring IoC 容器，这样同一个包下的组件就不用一个一个的在主配置文件中配置bean了。 @Controller @Service @Repository @Component @Named—需要引入第三方标准包 以上的注解可以混用，但是一般我们按类使用： @Controller 用于扫描控制层组件 @Service 扫描业务层组件 @Repository 扫描数据访问层组件 @Component 扫描其他组件 1.1 注入对象一个组件扫描的例子：在applicationContext.xml中，开启组件扫描12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:util="http://www.springframework.org/schema/util" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd"&gt; &lt;!-- 扫描包controller下的组件 --&gt; &lt;context:component-scan base-package="controller"/&gt;&lt;/beans&gt; 包controller下的组件LoginController.java ：12345678910111213141516171819202122232425package controller;import org.springframework.stereotype.Controller;import org.springframework.context.annotation.Scope;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;@Controller //注解: 扫描到Spring容器@Scope("prototype") //等价于&lt;bean scope="prototype"&gt; , 默认singletonpublic class LoginController &#123; public void execute() &#123; System.out.println("处理逻辑"); &#125; //了解一下 @PostConstruct //等价于 init-method public void init() &#123; System.out.println("初始化逻辑"); &#125; @PreDestroy //等价于 destroy-method public void destroy() &#123; System.out.println("销毁"); &#125;&#125; 注：扫描到Spring IoC容器中的组件 id 默认是 此类名并且首字母小写。如果想要改变 id 名， 可以在注解后加指定的id名：@Controller(“loginComponent1”) 利用注解注入属性：12345678910111213package other;import org.springframework.stereotype.Component;import javax.annotation.Resource;@Componentpublic class Student &#123; @Resource //注入 id 为 phone(默认和属性同名) 的对象 private Phone phone; //@Resource(name="指定id") 可以通过name指定id 来注入 指定的对象 //@Autowired 按类型注入&#125; 1.2 注入字符串/数值通过 Value注解 注入，都是固定的写法，直接看一个例子掌握： MyDataSource.java12345678910111213141516171819202122232425262728293031323334package data;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.stereotype.Component;@Component("myDataSource")public class MyDataSource &#123; @Value("#&#123;db.username&#125;") //将db对象key为username的值注入 private String userName; @Value("#&#123;db.password&#125;") private String password; @Value("#&#123;db.driver&#125;") private String driver; @Value("#&#123;db.url&#125;") private String url; public void getConnection() &#123; System.out.println("数据库连接操作"); System.out.println(userName); System.out.println(password); System.out.println(driver); System.out.println(url); &#125; public static void main(String[] args) &#123; ApplicationContext ac=new ClassPathXmlApplicationContext("applicationContext.xml"); MyDataSource ds=ac.getBean("myDataSource",MyDataSource.class); ds.getConnection(); &#125;&#125; 配置文件applicationContext.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:util="http://www.springframework.org/schema/util" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd"&gt; &lt;!-- 扫描data包下的组件 --&gt; &lt;context:component-scan base-package="data"/&gt; &lt;!-- 实例化一个properties对象，用于存储配置信息 --&gt; &lt;util:properties id="db"&gt; &lt;prop key="username"&gt;root&lt;/prop&gt; &lt;prop key="password"&gt;123&lt;/prop&gt; &lt;prop key="driver"&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key="url"&gt;jdbc:mysql://cherry.mitrecx.cn:3306/DBmitre?useUnicode=true&amp;amp;characterEncoding=utf8&lt;/prop&gt; &lt;!-- 当然，这些prop也可以写在文件中，通过location属性加载 --&gt; &lt;/util:properties&gt;&lt;/beans&gt; 执行结果：]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习3-Spring IoC各种类型注入]]></title>
    <url>%2F2018%2F10%2F13%2FSpring%E5%AD%A6%E4%B9%A03-%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[Bean Overview :A bean definition is essentially a recipe for creating one or more objects.Bean定义本质上是创建一个或多个对象的配方(方法)。 1. 各种类型注入的配置方式给bean的属性注入值，这些配置方式都是固定的，不难理解。所以直接给出一个例子展示各种类型的注入方法。bean：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package domain;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class Person &#123; private String name; private int age; private List&lt;String&gt; friends; private Set&lt;String&gt; interests; private Map&lt;String,String&gt; books; private Properties db; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public List&lt;String&gt; getFriends() &#123; return friends; &#125; public void setFriends(List&lt;String&gt; friends) &#123; this.friends = friends; &#125; public Set&lt;String&gt; getInterests() &#123; return interests; &#125; public void setInterests(Set&lt;String&gt; interests) &#123; this.interests = interests; &#125; public Map&lt;String, String&gt; getBooks() &#123; return books; &#125; public void setBooks(Map&lt;String, String&gt; books) &#123; this.books = books; &#125; public Properties getDb() &#123; return db; &#125; public void setDb(Properties db) &#123; this.db = db; &#125;&#125; 1.1 注入字符串，数值字符串注入上一篇博客已经涉及到了。数值注入的话，Spring会在内部做类型转换，所以我们可以为数值类型(如，int)注入可以转换为数值字符串。123456&lt;bean id="p1" class="domain.Person"&gt; &lt;property name="name" value="cx"&gt;&lt;/property&gt; &lt;property name="age" value="24"&gt;&lt;/property&gt;&lt;/bean&gt; 注：如果想要给name属性注入空值null123&lt;property name="name"&gt; &lt;null/&gt;&lt;/property&gt; 1.2 注入 List 和 Set123456789101112131415161718&lt;bean id="p1" class="domain.Person"&gt; &lt;property name="friends"&gt; &lt;list&gt; &lt;value&gt;汤姆&lt;/value&gt; &lt;value&gt;杰克&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="interests"&gt; &lt;set&gt; &lt;value&gt;足球&lt;/value&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;value&gt;乒乓球&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 1.3 注入Map12345678910&lt;bean id="p1" class="domain.Person"&gt; &lt;property name="books"&gt; &lt;map&gt; &lt;entry key="朱光潜" value="谈美"&gt;&lt;/entry&gt; &lt;entry key="亚当斯密" value="国富论"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 1.4 注入Property1234567891011&lt;bean id="p1" class="domain.Person"&gt; &lt;property name="db"&gt; &lt;props&gt; &lt;prop key="username"&gt;root&lt;/prop&gt; &lt;prop key="password"&gt;123&lt;/prop&gt; &lt;prop key="driver"&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 1.5 使用表达式注入#{表达式}#{id名.属性} 或 #{id名.key}如果是对象属性的话，需要类有getter。 1.6 使用 util:使用 util:集合类型 可以把集合的配置放在 标签下。当别的 需要时，可以直接调用集合。 使用 util: 需要引入命名空间：123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd"&gt;&lt;util:list id="list1"&gt; &lt;value&gt;汤姆&lt;/value&gt; &lt;value&gt;杰克&lt;/value&gt;&lt;/util:list&gt;&lt;!-- 调用集合对象list1，和前面1.2中的配置等价 --&gt;&lt;bean id="p1" class="domain.Person"&gt; &lt;property name="friends" ref="list1"&gt; &lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt; 注：util:集合类型 包括：util:listutil:setutil:maputil:properties 和 的子标签是一样的。当集合需要 重复利用 时，util:集合类型 显然是更好的选择。 值得注意的是， 可以读取文件：比如，在src目录下有一个db.properties文件：1234# key = valueusername = rootpassword = 123driver = com.mysql.jdbc.Driver 在applicationContext.xml 文件中用 的 location 属性读取：12&lt;util:properties id="db1" location="classpath:db.properties"&gt;&lt;/util:properties&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习2-Spring IoC 管理对象]]></title>
    <url>%2F2018%2F10%2F13%2F2-Spring-IoC-%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[1. 管理对象创建，初始化，释放资源，销毁。 下载Spring jar 包 1.1 如何管理对象a. 搭建Spring IoC开发环境 引入相关jar包spring-core-5.0.0.RELEASEspring-context-5.0.0.RELEASEspring-beans-5.0.0.RELEASEspring-expression-5.0.0.RELEASEcommons-logging 在src下添加applicationContext.xml文件，内容如下： 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd"&gt;&lt;/beans&gt; b. 在applicationContext.xml文件中配置bean，通过ApplicationContext对象取得配置的beanapplicationContext.xml文件 用构造方法创建bean对象 配置如下：123&lt;!-- 相当于 new GregorianCalendar(); 注意id的值唯一--&gt;&lt;bean id="calendar1" class="java.util.GregorianCalendar"&gt;&lt;/bean&gt; java类通过ApplicationContext获取bean123456//实例化Spring容器ApplicationContext ac=new ClassPathXmlApplicationContext("applicationContext.xml");//从Spring容器中获取id为calendar1的对象Calendar c1= ac.getBean("calendar1",Calendar.class);//以上操作等价于 Calendar c1=new GregorianCalendar(); applicationContext.xml文件 用静态工厂方法创建bean对象 配置如下(所谓工厂，就是封装了对象场景的细节)：1234&lt;!-- 相当于Calendar.getInstance() ; 注意id的值唯一--&gt;&lt;bean id="calendar2" class="java.util.Calendar" factory-method="getInstance"&gt; &lt;!-- factory-method的值是类中的方法名 --&gt;&lt;/bean&gt; java类通过ApplicationContext获取bean1234//从Spring容器中获取id为calendar2的对象Calendar c2= ac.getBean("calendar2",Calendar.class);//以上操作等价于 Calendar c2=Calendar.getInstance(); 小结：不论xml配置中用构造方法创建bean对象，还是用静态工厂方法创建bean对象，在java类里获取bean的方法都是一样的。了解一下：如果我们想要获取对象的属性，而这个属性任然是一个对象。比如：1Date date=c2.getTime(); 那么如何通过Spring 配置获取呢？获取方法如下：applicationContext.xml1234&lt;bean id="date1" factory-bean="c2" factory-method="getTime"&gt; &lt;!-- factory-bean的值是Spring容器中现有的对象名 --&gt; &lt;!-- factory-method的值是对象中的方法名 --&gt;&lt;/bean&gt; java类1Date date=ac.getBean("date1",Date.class); 1.2 Spring创建bean对象—属性配置 控制对象创建方式：元素的 scope属性 支持 singleton 和 prototype 两种创建方式。scope的缺省值是singleton，一般用默认。singleton 方式：每次 ac.getBean(“id”) 相同id取出的是同一个bean对象 (Spring容器中只实例化一个bean对象)。prototype 方式：每次取出不是同一个bean对象。 控制对象初始化：元素的 init-method属性 可以指定bean对象的初始化方法，init-method的值是bean初始化方法名，这样每创建一个bean对象就会调用一次初始化方法 (注：singleton只会初始化一次)。初始化工作放在 构造方法 中的话，初始化会在对象创建过程中进行；初始化工作放在 初始化方法 中则在对象创建后进行。 控制对象销毁：元素的 destroy-method属性 可以指定bean对象的销毁方法。满足下面两个条件才有效：—组件(bean)对象为singleton模式—调用AbstractApplicationContext容器对象的close()方法 控制singleton对象创建时机：元素 lazy-init=true 可以推迟singleton模式的bean对象的创建时间。默认的创建ApplicationContext对象的时候，singleton模式的bean对象就会被创建；lazy-init=true singleton模式的bean对象在实例化时才被创建。 2. 依赖注入(dependency injection)利用注入设置bean 属性的值。 2.1 set注入举个例子，利用 set注入 设置属性的值：bean：1234567891011121314151617181920212223public class User implements Serializable&#123; private Integer id; private String username; private String password; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; applicationContext.xml 配置：123456&lt;bean id="user1" class="domain.User"&gt; &lt;!-- 信息的 set注入，底层调用的是User bean的setter --&gt; &lt;property name="id" value="1001"&gt;&lt;/property&gt; &lt;property name="username" value="cx"&gt;&lt;/property&gt; &lt;property name="password" value="123"&gt;&lt;/property&gt;&lt;/bean&gt; 处理类中调用：123ApplicationContext ac=new ClassPathXmlApplicationContext("applicationContext.xml");User u1= ac.getBean("user1",User.class);//u1的id="1001", username="cx", password="123" 说明：如果现在需要改u1属性的值，只要修改配置文件即可，不用修改代码了。注：如果User新加一个属性computer，而Computer有属性cpu, memory，可以使用 ref 替代 value 注入。 123456789101112&lt;bean id="comp1" class="domain.Computer"&gt; &lt;property name="cpu" value="corei7"&gt;&lt;/property&gt; &lt;property name="memory" value="8G"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="user1" class="domain.User"&gt; &lt;!-- 信息的 set注入，底层调用的是User bean的setter --&gt; &lt;property name="id" value="1001"&gt;&lt;/property&gt; &lt;property name="username" value="cx"&gt;&lt;/property&gt; &lt;property name="password" value="123"&gt;&lt;/property&gt; &lt;property name="computer" ref="comp1"&gt;&lt;/property&gt;&lt;/bean&gt; 2.2 构造器注入接着上面set注入的例子 中的bean，现在做 构造器注入 ：beans:123456789101112131415public class User implements Serializable&#123; private Integer id; private String username; private String password; private Computer computer; public User(Integer id,String username,String password,Computer computer) &#123; this.id=id; this.username=username; this.password=password; this.computer=computer; &#125;&#125; applicationContext.xml 配置：1234567891011121314&lt;!--set注入Computer--&gt;&lt;bean id="comp2" class="domain.Computer"&gt; &lt;property name="cpu" value="corei8"&gt;&lt;/property&gt; &lt;property name="memory" value="16G"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--构造器注入User--&gt;&lt;bean id="user2" class="domain.User"&gt; &lt;!-- 构造器注入，底层调用的是User bean的构造方法 --&gt; &lt;constructor-arg index="0" value="1002"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="cx"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="2" value="123"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="3" ref="comp2"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 这里不对bean的自动注入autowire做说明。 3. 总结简而言之，IoC控制反转就是把对象创建控制权 从处理类手里 交到了Spring手里 ，这一控制权改变建立在 依赖注入 的机制上。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习1-Spring Framework 简介]]></title>
    <url>%2F2018%2F10%2F12%2FSpring-Framework-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[1. 为什么选择Spring 框架如果没有Spring 框架，我们按照 MVC模式 开发一个 web应用，需要配置web.xml，写Servlet来处理请求，写实体类和DAO类，写jsp展示页面等。这样做思路和结构都很清晰，没有什么不好。那为什么我们还要用Spring 框架？原因： 松耦合–IoC, AOP。 面向切面编程(AOP)–组件复用，将系统服务(安全、事务、日志等)从业务逻辑中分离出来。 简化web开发–缩短开发时间。可见，Spring 框架的设计哲学是优秀的，于是许多开发者选择了Spring web MVC。 2. 了解一下-术语Spring不同的背景下，Spring的含义是不同的。通常我们说的 Spring 指的是 Spring项目家族 ，包含Spring boot，Spring Framework, Spring Cloud等等。这个Spring系列的博客，指的是Spring Framework。没有特殊说明的话，后面Spring 默认指的是Spring Framework。 Spring Framework被分离成多个模块，我们开发的web应用可以选择自己需要的模块。这些模块的核心是 Core Container，包含 配置模块和依赖注入机制(dependency injection mechanism)。此外，Spring Framework 支持不同的应用结构(application architecture)： messaging(消息传递) transactional data and persistence(事务数据和持久化) web 还包含 基于 Spring MVC 的web框架 和 Spring WebFlux 响应式的web框架。 3. Spring 的版本历史 Version Date Notes 0.9 2002 Rod Johnson开发了第一版 1.0 2003 里程碑 2.0 2006 3.0 2009 4.0 2013 JavaSE 8，Groovy 2，JavaEE 7 5.0 2017 WebFlux，响应式编程 参考资料1、Spring Framework Overview2、 Spring Projects3、SSH框架——Spring + Struts + Hibernate简介-20164、SSM框架——详细整合教程(Spring + SpringMVC + MyBatis)]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsp标签和el表达式]]></title>
    <url>%2F2018%2F10%2F10%2Fjsp%E6%A0%87%E7%AD%BE%E5%92%8Cel%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[jsp标签和el表达式1. jsp标签jsp标签用来替换jsp文件中的java代码。因为直接在jsp文件中写java代码，不方便维护，所以sun制定了 jsp标签技术规范。 可以将jsp标签看做一个占位符，容器遇到jsp标签，会依据标签名找到对应的标签类，然后执行标签类中的代码。简而言之，jsp标签用来代替jsp文件中的java代码 使用jsp标签的好处：1、 jsp文件方便维护2、 方便代码的复用 jstl ：java标准标签库( java standard tag lib ), apache 开发的一套标签库，捐献给sun，sun将其命名为jstl。 如何使用 jstl：1、 将jstl相关的jar文件拷贝到 WEB-INF/lib 目录下。注：如果使用javaEE 5.0(包含了jstl相关的jar文件)，一般不用拷贝，不绝对，和Tomcat版本有关。2、 使用 taglib 指令导入相应的标签。 jstl 几个常用的标签：1、 ifuri取自standard.jar的META-INF目录中的c.tld(或c-rt.tld)的uric 是命名空间的前缀(别名)1234567&lt;%@taglib uri="http://java.sun.com/jstl/core" prefix="c"%&gt;&lt;c:if test="" var="" scope=""&gt; &lt;!-- test属性为true时，容器会执行if标签体，test属性可以使用el表达式--&gt;&lt;!-- var属性：指定绑定名称（绑定结果是test结果） --&gt;&lt;!-- scope属性：指定绑定范围，page，request，session，application--&gt;&lt;/c:if&gt; 2、choose12345678&lt;c:choose&gt; &lt;c:when test=""&gt; &lt;!--when可以出现一次或多次，当test属性为true时，执行when下的语句--&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;!--otherwise可以出现0次或1次，表示其他情况--&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; 3、forEach123456&lt;!--用来遍历集合或数组--&gt;&lt;c:forEach items="" var="" varStatus=""&gt; &lt;!--items属性指定要遍历的集合或数组--&gt; &lt;!--var属性指定一个绑定名，绑定范围固定是pageContext--&gt;&lt;/c:forEach&gt;&lt;!--注：每次从集合或数组中取一个元素，然后绑定到pageContext上，绑定名由var属性指定--&gt; tld自定义jsp标签的实现 2. el表达式el (Expression Language) 表达式是一套简单的运算规则，用于给jsp标签的属性赋值，也可以直接输出。 el 表达式的使用：1、 访问 bean 的属性 方式一：${user.name}容器会依次从 pageContext，request，session，application 中查找（getAttribute) 绑定名为 “user” 的对象 ，找到该对象后，调用该对象的 “getName” 方法 ，然后输出。可以使用 pageScope, requestScope,sessionScope,application 指定查找范围，如，${pageScope.user.name} 方式二：${user[“name”]}[ ]里可以是一个绑定名，也可以是从0开始的下标（访问数组） 2、 进行一些简单的运算，运算结果可以给jsp标签赋值，也可以直接输出 算术运算 “ +, -, *, /, % “如，${1+1}, ${“3”+”4”} 关系运算 “ &gt;, &gt;=, &lt;, &lt;=, ==, != “如，${2&gt;1}, ${user.name==”cx”} 逻辑运算 “ &amp;&amp;, ||, ! “如，${1&lt;2 || 3&lt;4} empty运算, 判断集合是否为空，或字符串是否是一个空字符串如，${empty str} str为空返回true，不空为false 3、 读取请求参数值 (jsp负责展示数据，不适合处理请求) ${param.username}等价于 request.getParameter(“username”) ${paramValues.friends}等价于request.getParameterValues(“friends”) 如果 el 表达式解析不了，请检查 web.xml 文件 的 web-app 标签属性，如下配置：123456&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1"&gt;&lt;/web-app&gt; 3. jsp 自定义标签tld (tag lib descriptor)自己写一个标签：1、 在WEB-INF目录下建一个文件hello.tld, 文件内容如下：123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;taglib xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd" version="2.0"&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;ExampleTLD&lt;/short-name&gt; &lt;uri&gt;/WEB-INF/hello.tld&lt;/uri&gt; &lt;description&gt;完成一个自定义jsp标签库&lt;/description&gt; &lt;tag&gt; &lt;name&gt;hello&lt;/name&gt; &lt;tag-class&gt;test.HelloTag&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;/tag&gt;&lt;/taglib&gt; 2、 编写标签的实现类123456789101112package test;import java.io.IOException;import javax.servlet.jsp.JspException;import javax.servlet.jsp.JspWriter;import javax.servlet.jsp.tagext.SimpleTagSupport;public class HelloTag extends SimpleTagSupport &#123; @Override public void doTag() throws JspException, IOException &#123; JspWriter out=getJspContext().getOut(); out.println("自定义标签输出，由JspWriter输出"); &#125;&#125; 3、 使用自定义的tag12345678910&lt;%@page pageEncoding="utf-8" contentType="text/html; charset=utf-8" %&gt;&lt;%@taglib uri="/WEB-INF/hello.tld" prefix="c1" %&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body style="font-size: 30px;"&gt; &lt;p&gt;自定义标签&lt;/p&gt; &lt;c1:hello/&gt; &lt;/body&gt;&lt;/html&gt; 运行结果： 注：如果在标签里添加属性，需要在实现类里加上对应的属性和setter，实现类属性的值是从标签属性中获取的。同时还需要在tld 文件中配置 attribute 标签，attribute 的子标签(tag Subelements/嵌套元素nested elements) 介绍如下：12345678910111213&lt;attribute&gt;(Optional) Defines the name of the attribute as it appears in the tag element in the JSP page. For example: &lt;name&gt;myAttribute&lt;/name&gt; (Required)attribute name &lt;required&gt;true | false&lt;/required&gt; (Optional) Defines whether this attribute has optional use in the JSP page. If not defined here, the default is false — that is, the attribute is optional by default. If true is specified, and the attribute is not used in a JSP page, a translation-time error occurs. &lt;rtexprvalue&gt;true | false&lt;/rtexprvalue&gt; (Optional) Defines whether this attribute can take a scriptlet expression as a value, allowing it to be dynamically calculated at request time. If this element is not specified, the value is presumed to be false.&lt;/attribute&gt; 这只是一个 taglib 入门的例子，很简单，实现类继承的 SimpleTagSupport 还有一些方法, 这里不再深入学习 参考1、 Creating a Tag Library Descriptor]]></content>
      <categories>
        <category>jsp</category>
      </categories>
      <tags>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse中使用git]]></title>
    <url>%2F2018%2F10%2F09%2Feclipse%E4%B8%AD%E4%BD%BF%E7%94%A8git%2F</url>
    <content type="text"><![CDATA[eclipse 使用 git 进行版本控制如果没有git插件，需要先安装git插件。 git配置如下图： git eclipse中的项目： 在GitHub上建一个repository 本地项目右键, Team , share Project , Git , 创建本地repository(勾选use or create) 新建的本地仓库有 NO-HEAD 标识，要先把远程仓库pull到本地仓库，使用 https协议 commit 到本地仓库 push 到 GitHub远程仓库 这是我git的结果，注意一下.gitignore , 这个文件里是提交时指定忽略的文件。git 相关学校 看这篇博客.]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彼得 杜拉克个人管理思维]]></title>
    <url>%2F2018%2F10%2F08%2F%E5%BD%BC%E5%BE%97-%E6%9D%9C%E6%8B%89%E5%85%8B%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[西元前四百四十年，有一个著名的希腊雕刻家叫做–菲狄亚斯。菲狄亚斯在当时被委任要制作帕特农神庙上面的雕像。但是当菲狄亚斯去跟市政府请款时，市政府却不愿意付钱。原因是这些雕像位于神庙的屋顶上，而神庙位于山丘的制高点，所以人们只能够看到雕像的正面。然而，菲狄亚斯申请了整座立体雕像的费用，所以市政府不愿意拨款。这时，菲狄亚斯反驳说，“you are wrong, The gods can see.” 如果我们今天是为了某一个人或某一个团体的认定而去做某件事。那我只会做人们看得到的那个部分。那我也只会在那个部分有所成长，在那个部分有所得。但如果我想着举头三尺有神明，我就会超出别人的期待来做事情。我就不再是为了别人的认同和掌声来做这件事。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>正能量影片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet线程安全]]></title>
    <url>%2F2018%2F09%2F23%2Fservlet%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[servlet 线程安全问题容器在默认情况下，只会创建一个 servlet实例。容器收到一个请求，就会 启动一个线程 来处理。 如果有多个请求同时访问某个 servlet，就会有多个线程调用同一个 servlet实例，就有可能产生线程安全问题（如，这些线程要修改servlet的属性）。 一个 多线程访问 servlet 示例：1234567891011121314151617181920212223package web;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ThreadServlet extends HttpServlet &#123; private int count = 0; @Override protected void service(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException &#123; count++; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 输出线程名+线程个数 System.out.println(Thread.currentThread().getName() + ":" + count); &#125;&#125; 利用 jMeter 测试：1、 打开 jMeter，创建一个线程组 2、 配置线程组 3、 为线程组添加 访问协议类型，配置并启动 4、 测试结果 解决servlet 线程安全问题把可能产生线程不安全的程序 用 synchronized(this) 括起来。12345678910111213141516171819202122232425package web;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ThreadServlet extends HttpServlet &#123; private int count = 0; @Override protected void service(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException &#123; synchronized(this) &#123; count++; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 输出线程名+线程个数 System.out.println(Thread.currentThread().getName() + ":" + count); &#125; &#125;&#125; 测试结果：]]></content>
      <categories>
        <category>servlet</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet监听器]]></title>
    <url>%2F2018%2F09%2F22%2Fservlet%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
    <content type="text"><![CDATA[监听器监听器 是 servlet规范 中定义的一种特殊的组件，用来监听容器产生的事件。 容器产生的事件主要有两大类：1、 生命周期相关的事件容器创建或销毁了 request，session，servlet上下文 时产生的事件。 2、 绑定数据相关的事件调用了 request，session，servlet上下文 的 setAttribute，removeAttribute 时产生的事件。 1. servlet 上下文什么是 servlet上下文 ？ 容器启动之后，会为每一个web应用 创建唯一的一个符合ServletContext接口的对象。 1.1 特点1、 唯一性： 一个web应用 对应唯一一个上下文。2、 持久性： 只要容器没有关闭，并且应用没有被删除，则上下文会一直存在。 获得上下文的 4种途径：GenericServlet，或 ServletConfig，或 FilterConfig，或 HttpSession提供的 getServletContext 方法。 1.2 上下文的作用：将数据绑定到上下文，应用可以随时访问。1、绑定数据，setAttribute，getAttribute，removeAttribute注：request.setAttribute, session.setAttribute, ServletContext.setAttribute, 在绑定数据时，应该优先使用生命周期短的对象绑定，这样可以节约内存空间( request &lt; session &lt; context )。 例如：在 ServletA对象中绑定 一条数据，在ServletRead对象中读取并显示。ServletA.java12345678910111213141516171819202122package web;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ContextA extends HttpServlet&#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=utf-8"); PrintWriter out=response.getWriter(); // 获得上下文context，注：HTTPServlet 是 GenericServlet的子类 ServletContext ctx= getServletContext(); // 将一条数据绑定到 context ctx.setAttribute("userList", "陈兴，mitre"); out.close(); &#125;&#125; ContextRead.java1234567891011121314151617181920212223package web;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ContextRead extends HttpServlet &#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=utf-8"); PrintWriter out=response.getWriter(); //获得上下文context ServletContext ctx=getServletContext(); // 读取context绑定的数据 String ul=(String)ctx.getAttribute("userList"); out.println(ul); out.close(); &#125;&#125; web.xml1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1"&gt; &lt;display-name&gt;web06-context&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;write&lt;/servlet-name&gt; &lt;servlet-class&gt;web.ContextA&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;write&lt;/servlet-name&gt; &lt;url-pattern&gt;/set&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;read&lt;/servlet-name&gt; &lt;servlet-class&gt;web.ContextRead&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;read&lt;/servlet-name&gt; &lt;url-pattern&gt;/get&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 2、 访问全局的初始化参数。web.xml配置：ServletContext对象读取: String getInitParameter(String paramterName) 例如：接着上一个例子在 web.xml 配置：12345&lt;!-- 全局的初始化参数 --&gt;&lt;context-param&gt; &lt;param-name&gt;company&lt;/param-name&gt; &lt;param-value&gt;宇信&lt;/param-value&gt;&lt;/context-param&gt; 在 ServletRead.java 中读取初始化参数(添加两行代码):123456789101112131415161718192021222324252627package web;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ContextRead extends HttpServlet &#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=utf-8"); PrintWriter out=response.getWriter(); //获得上下文context ServletContext ctx=getServletContext(); // 读取context绑定的数据 String ul=(String)ctx.getAttribute("userList"); out.println(ul); // 读取 全局的初始化参数 String companyName=ctx.getInitParameter("company"); out.println("&lt;br/&gt;"+companyName); out.close(); &#125;&#125; 执行结果: 2. 监听器写一个监听器：1、 写一个 java类，实现相应的监听器接口。注：要依据监听的事件类型来选择合适的接口。比如，要监听 session 的创建和销毁，需要实现 HttpSessionListener接口。 2、 实现接口方法，完成监听处理逻辑。 3、 配置 web.xml 实例：使用监听器统计在线人数。 配置web.xml12345678910111213141516171819&lt;!--首页--&gt;&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;&lt;!-- 监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;web.CountOnline&lt;/listener-class&gt;&lt;/listener&gt;&lt;!--退出--&gt;&lt;servlet&gt; &lt;servlet-name&gt;logout&lt;/servlet-name&gt; &lt;servlet-class&gt;web.LogOutServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;logout&lt;/servlet-name&gt; &lt;url-pattern&gt;/logout&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 退出界面/首页 index.jsp123456789101112131415&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是首页&lt;/h1&gt; 当前系统在线人数： &lt;%= application.getAttribute("count") %&gt; &lt;a href="logout" &gt;退出&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; CountOnline类 实现 HttpSessionListener 接口。当前浏览器 HttpSession 还不存在时，每次打开 http://localhost:8080/web06-context/ 地址，都会触发 sessionCreated 方法，继而创建 HttpSession 对象。如果当前浏览器 已经有 HttpSession 对象了，那么就不会触发 sessionCreated 方法。12345678910111213141516171819202122232425262728293031323334public class CountOnline implements HttpSessionListener&#123; /** * session对象创建时 会调用此方法 */ @Override public void sessionCreated(HttpSessionEvent arg0) &#123; System.out.println("session对象 正在创建.."); // 通过HttpSessionEvent 获取 HttpSession 对象 HttpSession session=arg0.getSession(); // 通过会话session 获取上下文ServletContext ServletContext sctx=session.getServletContext(); Integer count=(Integer)sctx.getAttribute("count"); if(count==null) &#123; count=1; &#125;else &#123; count++; &#125; sctx.setAttribute("count", count); &#125; /** * session对象销毁时 会调用此方法 */ @Override public void sessionDestroyed(HttpSessionEvent arg0) &#123; System.out.println("session对象 正在销毁。。"); HttpSession httpSession=arg0.getSession(); ServletContext sctx=httpSession.getServletContext(); Integer count=(Integer)sctx.getAttribute("count"); count--; sctx.setAttribute("count", count); &#125;&#125; 退出登录(销毁HttpSession): LogOutServlet.java123456789101112131415package web;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class LogOutServlet extends HttpServlet&#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession hSession=request.getSession(); hSession.invalidate(); &#125;&#125;]]></content>
      <categories>
        <category>servlet</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet过滤器]]></title>
    <url>%2F2018%2F09%2F21%2Fservlet%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[过滤器servlet 规范中 定义的一种特殊的组件，用来拦截容器的调用过程。 容器收到请求后，通常情况下会调用servlet 的 service 方法来处理请求，如果有过滤器，则 容器先调用过滤器的方法。 注： 容器一启动，就会创建过滤器。 写一个 过滤器1、 写一个 java类，实现 Filter 接口。 2、 在 doFilter方法 里，编写拦截处理逻辑。 3、 配置 过滤器 ( web.xml )。 实例：写一个评论页面，在评论框中输入评论，如果评论包含“敏感字”就不显示评论，如果不包含就显示评论。 1、 在根目录webContent下，写一个 comment.jsp 页面：1234567891011&lt;%@page contentType="text/html; charset=utf-8" pageEncoding="utf-8" %&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="comment" method="post"&gt; 评论: &lt;input type="text" name="content"/&gt; &lt;input type="submit" value="提交"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 2、 写一个 CommentServlet.java， 先不考虑过滤：1234567891011121314151617181920package comment;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class CommentServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=utf-8"); request.setCharacterEncoding("utf-8"); PrintWriter out = response.getWriter(); String comment = request.getParameter("content"); out.println("&lt;h1&gt;你的评论是: " + comment + "&lt;/h1&gt;"); out.close(); &#125;&#125; 配置一下 web.xml ，然后 Tomcat部署，debug ,可以正常访问，下面加入过滤器。 3、写一个过滤器 CommentFilterA.java，屏蔽敏感字”傻” ：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package web;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class CommentFilterA implements Filter &#123; /** * 容器启动后，会创建过滤器对象 只会创建一个 */ public CommentFilterA() &#123; System.out.println("FilterA 的构造 方法"); &#125; /** * 容器在创建好 过滤器对象 之后， 接下来会调用对象的init 方法 init 方法只会执行一次 注： 可以在web.xml 中配置 * &lt;init-param&gt;提供初始化参数 由 FilterConfig arg 来读取 */ @Override public void init(FilterConfig arg0) throws ServletException &#123; //可以定义一个属性，来保存 容器(web.xml,init-param)传过来的FilterConfig对象 //config=arg0 //在别处 就可以 读初始化参数: //String ils = config.getParameter("illegalString"); System.out.println("FilterA init方法。。"); &#125; /** * 容器调用 doFilter方法来处理请求。 * * @param ServletRequest * arg0 请求对象 * @param ServletResponse * arg1 响应对象 * @param FilterChain * arg2 过滤器链 如果调用 过滤器链 的 doFilter方法 则容器会继续向后调用 */ @Override public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException &#123; System.out.println("FilterA 的 doFilter 方法 开始执行！"); // 强转，因为要调用的方法是 HttpServletRequest子类的方法 HttpServletRequest request = (HttpServletRequest) arg0; HttpServletResponse response = (HttpServletResponse) arg1; // 先执行过滤器，对请求报文 utf-8 编码处理 request.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=utf-8"); PrintWriter out = response.getWriter(); String content = request.getParameter("content"); if (content.indexOf("傻") != -1) &#123; // 包含了敏感字 out.println("&lt;h1&gt;评论包含了敏感字--傻&lt;/h1&gt;"); &#125; else &#123; // 没有包含敏感字，继续向后调用 arg2.doFilter(arg0, arg1); &#125; System.out.println("FilterA 的 doFilter 方法 执行完毕！"); &#125; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125;&#125; 4、配置 web.xml , 添加 过滤器配置：1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1"&gt; &lt;display-name&gt;web05-Filter&lt;/display-name&gt; &lt;filter&gt; &lt;filter-name&gt;filterA&lt;/filter-name&gt; &lt;filter-class&gt;web.CommentFilterA&lt;/filter-class&gt; &lt;!-- 初始化参数，非必须，通过FilterConfig对象读取 --&gt; &lt;init-param&gt; &lt;param-name&gt;illegalString&lt;/param-name&gt; &lt;param-value&gt;猪&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filterA&lt;/filter-name&gt; &lt;url-pattern&gt;/comment&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;comt&lt;/servlet-name&gt; &lt;servlet-class&gt;comment.CommentServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;comt&lt;/servlet-name&gt; &lt;url-pattern&gt;/comment&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 5、部署，测试可以实现过滤 “傻” 字。 第一个 java过滤器 完成。 注：当有多个过滤器时，容器会依据 在web.xml 中的先后顺序 来调用。在前面的先调用。 java过滤器的优点1、 在不修改源程序的基础上，为程序增加一些过滤条件（过滤器独立于已存在的servlet程序）。 2、 将多个组件相同的处理逻辑集中写在过滤器里面，方面代码维护。比如，request.getSession 做登录验证。]]></content>
      <categories>
        <category>servlet</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat启动错误]]></title>
    <url>%2F2018%2F09%2F20%2Ftomcat%E5%90%AF%E5%8A%A8%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[九月 02, 2018 4:30:51 上午 org.apache.tomcat.util.digester.SetPropertiesRule begin信息: Starting Servlet Engine: Apache Tomcat/8.0.36九月 02, 2018 4:30:54 上午 org.apache.jasper.servlet.TldScanner scanJars信息: At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.九月 02, 2018 4:30:54 上午 org.apache.catalina.core.ContainerBase startInternal严重: A child container failed during startjava.util.concurrent.ExecutionException: org.apache.catalina.LifecycleException:Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/web01copy]] 12345678&lt;servlet&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;servlet-class&gt;emp.ActionServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; *.do被我写成了 /*.do 而导致了错误。 仅仅一个 “/“ 导致起不了Tomcat。。平时一定要细心呀。 我在网上搜了半天都没找到解决方法，而这个错误就在 console 输出的错误提示中。 总结：我们把应用部署到 Tomcat 中，当Tomcat 启动不了的时候，无非有两种可能(不考虑Tomcat不兼容)：1、 缺少jar包（或版本不兼容）2、 应用配置有问题而这两种可能都是应用的问题。]]></content>
      <categories>
        <category>servlet</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet状态管理]]></title>
    <url>%2F2018%2F09%2F20%2Fservlet%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[状态管理将浏览器和 web服务器 之间的多次交互作为一个整体来处理。并且将多次交互所涉及的数据（状态）保存下来。 1. cookiecookie 是 服务器临时保存在浏览器端的少量数据。 工作原理：1、当 浏览器 访问服务器时，服务器可以将少量数据以 set-cookie消息头 的方式发送给浏览器，浏览器会将这些数据临时保存下来。2、当 浏览器 再次 访问服务器时，会将之前保存的这些数据以 cookie消息头 的方式发送给服务器。 在 response 对象中 添加 cookie：12Cookie c=new Cookie(String name, String value);response.addCookie(c); 从请求对象request中 读取 cookie：12345//获取请求对象中的 cookie（可能是多个）Cookie[] request.getCookies();String cookie.getName();String cookie.getValue(); 2. cookie 编码问题如果 中文乱码，那么需要编码( encode ) 放在 cookie 中的汉字。比如编码成 “utf-8” (三个字节保存一个汉字)，然后再传输。 编码 与 解码12345//编码：把字符串str 按照 字符集charset 编码String URLEncoder.encode(String str, String charset);//解码：把字符串str 按照 字符集charset 解码String URLDecoder.decode(String str, String charset); 注：对添加到 cookie 中的字符串 编码处理，在取出 浏览器发送来的 cookie 时 也要解码处理。 3. cookie 的生存时间缺省情况下，浏览器会把cookie 保存在内存里，只要浏览器不关闭，cookie 就一直存在，浏览器关闭，cookie 就会被销毁。 自己设置 cookie 的生存时间：12//单位是秒cookieName.setMaxAge(int seconds); seconds &gt; 0 , 浏览器把 cookie 保存在硬盘上，如果超过了指定时间， cookie 会被删除。seconds &lt; 0 , 缺省情况。seconds = 0 , cookie 会被立刻删除。一般用于删除已存在的 cookie。 例如删除已存在的 cookie username：123456//创建一个同名cookie usernameCookie c=new Cookie("username","轩辕荣耀");//添加到响应对象上，用于发送给浏览器。//一旦发送给浏览器会把浏览器端的同名cookie替换, 然后删除c.setMaxAge(0);response.addCookie(c); 4. cookie 路径问题浏览器在向某个地址发请求时，会比较该地址是否匹配 cookie 的路径，如果匹配，那么响应的 cookie 会加载请求报文头里发送出去。 cookie 的默认路径：等于添加该 cookie 的组件 (servlet/jsp) 的路径。 路径匹配规则：请求路径等于cookie 的路径，或者请求路径是cookie的子路径。 5. session 会话session： 服务器端为维护状态而创建的一个特殊的对象。 工作原理：浏览器访问服务器时，服务器会创建一个session 对象，session对象 有一个唯一的id ，称之为 sessionId。服务器会将 sessionId 以 cookie 的方式发送给浏览器。浏览器再次访问服务器时，会将 sessionId 以 cookie的方式发送给服务器，服务器端可以利用sessionId找到对应的session对象。 5.1服务端如何获得 session方式 11HttpSession s=request.getSession(true/false); true:先查看 request请求 中有没有 sessionId ，如果没有，就创建一个 session对象。如果有，就 依据此 sessionId 查找对应的 session 对象，如果找到则返回，找不到就创建一个新的session对象。false:先查看 request请求 中有没有 sessionId ，如果没有，返回 null如果有，就 依据此 sessionId 查找对应的 session 对象，如果找到则返回，找不到就创建一个新的session对象。 方式 21234// 常用写法HttpSession s=request.getSession();// request.getSession(true) 的简写形式// 等价于 request.getSession(true) 5.2 session 常用方法假设 有一个 session 对象 名为 sessionName： 1234567891011//获得 session 的 idString sessionName.getId();// 绑定数据sessionName.setAttribute(String name, Object obj);// 根据绑定名 获得 绑定值// 该方法可能返回 nullObject sessionName.getAttribute(String name);// 解除绑定sessionName.removeAttribute(String name); 5.3 session 超时服务器 会将 空闲时间过长的 session对象 删除。 缺省的删除时间在 Tomcat 的 server 工程中的 web.xml 中已默认配置。1234&lt;!-- web.xml 默认 30 minutes --&gt;&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 可以用编程的方式修改 缺省时间：1setMaxInActiveInterval(int seconds); 5.4 删除 session1invalidate(); 注：为什么 不叫 delete 或 drop，而叫 invalidate ？因为 容器在实现 invalidate 的时候，并没有删除 session 对象，而是 抹去 session 对象的值，然后重新赋值 再交给用户使用。 6. 登录案例实现用户名-密码 登录系统机制 详细步骤： 1、 在数据库中创建一张表(user)，用于存储用户名-密码等信息(隐私信息应当加密)。 2、 包entity: 创建实体类 (User)。 3、 包dao: 创建 DBUtil.java 连接数据库工具类，创建 UserDao.java 提供 数据库操作。 4、 包web: ActionServlet.java 5、 WebContent 目录: login.jsp 登录页面，success.jsp 登录成功页面。 6、 session 验证：登录成功后，将一些数据绑定到 session 对象上，比如，session.setAttribute(“user”,user);对于需要保护的资源(success.jsp) , 添加session验证代码：123456//ActionServlet.java 代码://登录成功，将一些数据绑定到session对象上HttpSession session=request.getSession();session.setAttribute("user", user);response.sendRedirect("success.jsp");//登录失败/不登录 不绑定 数据到session success.jsp 代码：12345Object obj=session.getAttribute("user");// 如果没有登录if(obj==null)&#123; response.sendRedirect("login.jsp");&#125; 注：登录成功，就绑定一些数据到 session 对象，登录失败则不绑定。所以，在登录成功的页面 需要 对session对象 验证是否有 绑定数据，如果有就显示登录成功的页面，如果没有 就返回登录页面。]]></content>
      <categories>
        <category>servlet</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信托业务]]></title>
    <url>%2F2018%2F09%2F02%2F%E4%BF%A1%E6%89%98%E4%B8%9A%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[信托业务被委托人在委托人授权的权限内从事的民事、商事法律行为对委托人生效。根据授权从事商事活动的 被委托人 又称为 经纪人。根据授权从事民事诉讼、仲裁活动的 被委托人 又称为 代理人。 1. 受托人受托人 是信托业务的关系人之一，又称 被委托人 或 受委托人 受托人是信托业务的关系人之一，接受信托并按约定的信托条件，享受对信托财产进行管理和处理的人。受托人对信托财产的管理，是指不变更财物或权利的性质，而只对财产现状进行利用、改良、维护和保存; 受托人对信托财产的处理，指受权对信托财产进行财物或权利的变更或消除的行为。 受托人从事管理或处理财产时，必须严格遵循信托人的信托目的，对受益人的利益负责，不能借机为其自身谋利益。 受托人可以由法人承当，也可以由自然人担任。 2. 信托业务1、 授权基于授权而形成授权人与被授权人之间由法律直接规定赋予的公民权人为授权人，因他人授权而取得权利的人为被授权人 。 授权人与被授权人之间因授权而形成委托(代理)关系，在委托合同中当事人之间形成委托关系，授权人为委托人，被授权人为被委托人(受委托人、受托人) 2、 委托基于委托合同而形成委托关系《合同法》第三百九十六条 委托合同是委托人和受托人约定，由受托人处理委托人事务的合同。 3、 代理代理人（nominee/agent）是以被代理人名义进行代理活动的人。可以是自然人或法人。自然人为代理人时，必须具有相应的民事行为能力；法人为代理人时，其代理行为应符合法人的宗旨和业务范围。代理人不得超越代理权限进行代理，不得滥用代理权。代理人有权在代理权限范围内独立为意思表示，但不得损害被代理人利益。代理人知道被委托事项违法仍然进行代理的，应与被代理人负连带责任。依当事人的授权委托而确定的代理人，称为“委托代理人”或“意定代理人”；依法律直接规定而确定的代理人称为“法定代理人”；依人民法院或指定机关指定而确定的代理人，称为“指定代理人”。 类型 命名角度及对应名称 名称 授权 授权人 被授权人 委托 委托人 被委托人、受委托人、受托人 代理 被代理人、本人 代理人]]></content>
      <categories>
        <category>宇信工作</category>
      </categories>
      <tags>
        <tag>银行业务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贷款分类]]></title>
    <url>%2F2018%2F09%2F01%2F%E8%B4%B7%E6%AC%BE%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1. 按贷款主体经济性质分 国有及国家控股企业贷款。 集体企业贷款。 私营企业贷款。 个体工商业者贷款。 2. 按贷款信用程度划分 信用贷款。指以借款人的信誉发放的贷款。 担保贷款。指保证贷款、抵押贷款、质押贷款。保证贷款，指按规定的保证方式以第三人承诺在借款人不能偿还贷款时，按约定承担一般保证责任或者连带责任而发放的贷款。抵押贷款，指按规定的抵押方式以借款人或第三人的财产作为抵押物发放的贷款。质押贷款，指按规定的质押方式以借款人或第三人的动产或权利作为质物发放的贷款。 票据贴现。指贷款人以购买借款人未到期商业票据的方式发放的贷款。 3. 按贷款经营属性划分 自营贷款。指贷款人以合法方式筹集的资金自主发放的贷款，其风险由贷款人承担，并由贷款人收回本金和利息。 委托贷款。指由政府部门、企事业单位及个人等委托人提供资金，由贷款人(即受托人)根据委托人确定的贷款对象、用途、金额、期限、利率等代为发放、监督使用并协助收回的贷款。贷款人(受托人)只收取手续费，不承担贷款风险。 特定贷款。指经国务院批准并对贷款可能造成的损失采取相应补救措施后责成国有独资商业银行发放的贷款。 4. 按贷款使用期限划分 短期贷款。指贷款期限在1年以内(含1年)的贷款。目前主要有6个月、1年等期限档次的短期贷款。这种贷款也称为 流动资金贷款，在整个贷款业务中所占比重很大，是金融机构最主要的业务之一。 中、长期贷款。中期贷款指贷款期限在1年以上(不含1年)5年以下(含5年)的贷款。长期贷款，指贷款期限在5年(不含5年)以上的贷款。人民币中、长期贷款包括固定资产贷款和专项贷款。 5. 按贷款的使用质量划分 正常贷款。指预计贷款正常周转，在贷款期限内能够按时足额偿还的贷款。 不良贷款。不良贷款包括呆账贷款、呆滞贷款和逾期贷款。 注：呆账贷款，指按财政部有关规定列为呆账的贷款。呆滞贷款，指按财政部有关规定，逾期(含展期后到期)并超过规定年限以上仍未归还的贷款，或虽未逾期或逾期不满规定年限但生产经营已终止、项目已停建的贷款(不含呆账贷款)。 自1998年起，将陆续对商业银行贷款质量按国际金融同业标准分类评级，即将银行贷款划分为 正常、关注、 次级、可疑、损失 五个等级，后三类贷款称为“不良贷款”。 6. 附：贷款金额贷款金额 是贷款合同和借据上面的金额； 贷款余额 是 贷款金额 扣减还款金额后的余额。简单说，贷款金额 指的发放贷款的金额，贷款余额 指的剩余的贷款金额。比如你贷款100万，你过了一个月还了10万元。贷款金额是100万元，贷款余额是90万元。]]></content>
      <categories>
        <category>宇信工作</category>
      </categories>
      <tags>
        <tag>银行业务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工具]]></title>
    <url>%2F2018%2F09%2F01%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1. 编辑器1.1 vimLinux 系统中最好用的文本编辑器之一。用法参见：1vimtutor 1.2 UltraEditWindows 下 最好用 的文本编辑器。UltraEdit是一个很全面的编辑器：HTML EditorHEX EditorPHP editorCSS editorC++ EditorShell scriptsPL/SQL EditorVisual Basic editor UE 常用的快捷键： Ctrl+J 选中一个单词 F3 / Ctrl+F3 查找上一个/下一个 配合Ctrl+J 或Ctrl+F使用 Ctrl+B 匹配括号 Ctrl+E 删除当前行 Alt+C 列模式 Ctrl+F5 / Alt+F5 大小写转换 Ctrl+F2 为当前行添加书签 F2 / Alt+F2 下一个/上一个书签 Ctrl+R 就是 replace，支持RE Ctrl+N 新建new Ctrl+F4 关闭Tab 2. Chrome浏览器chrome常用快捷键： Ctrl+g/ Ctrl+Shift+g 搜索上一个或下一个 Ctrl+T 新打开一个Tab Ctrl+shift+T 恢复已关闭的Tab Ctrl+W 关闭当前Tab Ctrl+F 搜索 Alt+D 选中地址栏 2.1 Chrome插件之VimiumVimium被称之为黑客级的插件。它可以让我们在 Chrome 中 用键盘代替鼠标 上网。查看使用方法：1shift + / 2.2 Chrome插件之SwitchyOmega配合软件 shadowsocks 使用，方便快捷的翻墙插件。]]></content>
      <categories>
        <category>编程工具</category>
      </categories>
      <tags>
        <tag>编程工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet]]></title>
    <url>%2F2018%2F09%2F01%2Fservlet%2F</url>
    <content type="text"><![CDATA[1. 什么是servlet ？sun公司制定的一种用来扩展web服务器功能 的 组件 (规范)。（1）扩展web服务器功能&nbsp;&nbsp;&nbsp;web服务器只能处理静态资源的请求（即事先需要把HTML文件准备好），可以使用servlet来扩展，即web服务器可以通过调用servlet来处理动态资源的请求，比如访问数据库。（2）组件规范&nbsp;&nbsp;&nbsp;组件：符合一定规范，实现部分功能，并且需要部署到相应的容器内才可以运行的软件模块。&nbsp;&nbsp;&nbsp;servlet是一个容器，需要部署到相应的servlet容器里才能运行。&nbsp;&nbsp;&nbsp;容器：提供组件运行环境的程序。 2. 如何写一个servlet不利用开发工具，纯手写一个servlet： 写一个java类，实现 Servlet接口 或者 继承 HttpServlet抽象类 。 编译终端 javac 命令编译需要引入 javax 扩展包中的 servlet-api.jar (javax.servlet.*，在 Tomcat 主目录的 lib 文件夹中有此包)。如果在 eclipse 中开发，需要 Window -》 Preferences -》Server -》 Runtime Environments 下 添加 Tomcat 的主目录，同时需要注意 右击项目 -》 build path -》libraries -》 add library -》 Server Runtime 在项目上 添加 Tomcat 容器。 打包（变成一个组件）创建具有如下结构的文件夹：APPname/（应用名）&nbsp;&nbsp; WEB-INF/&nbsp;&nbsp;&nbsp;&nbsp; classes/&nbsp;&nbsp;&nbsp;&nbsp; lib/ (可选，放jar文件)&nbsp;&nbsp;&nbsp;&nbsp; web.xml (部署描述文件) 部署将第3步创建好的整个文件夹添加到 Tomcat容器里。注： 可以使用 jar 命令将第3步创建好的整个文件夹压缩成 “.war” 的文件，然后拷贝。 启动容器，访问servlethttp://ip:port/APPname/url-pattern注： url-pattern 在web.xml 文件中定义 3. Tomcat是如何运行的：在浏览器地址栏输入一个地址step1.&nbsp; browser 根据ip, port 建立连接。step2.&nbsp; browser 将相关数据 (请求参数) 打包，然后发送。step3.&nbsp; Tomcat 解析请求数据包，并且将解析到的数据封装到 request 对象，同时创建一个response对象。step4.&nbsp; Tomcat容器创建 servlet 对象，然后调用该对象的 service() 方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注：Tomcat 容器会将 request 和 response 传递，通过 request 获得请求参数，将处理结果写到 response 。step5.&nbsp; Tomcat 容器读取 response 中的处理结果，并将处理结果打包发送给 browser。step6.&nbsp; 浏览器解析相应数据包，生成相应的页面。 4. 请求资源路径 和 请求参数4.1 web.xml 配置请求资源路径容器如何处理请求资源路径：在浏览器地址栏输入 http://ip:port/web_App_name/hello.html容器根据 应用名 找到 应用所在的目录，并去 web.xml文件 中查找有没有一个和”/hello.html” 匹配的servlet。具体调用按下列顺序： 如果 web.xml 中有，就调用此servlet。 如果 web.xml 中没有，就调用 WebContent(应用主目录) 目录 下的 对应的”/hello.html” 文件。 如果 Webcontent 目录下也没有资源文件， 将会报 404 。 web.xml 中配置 有三种匹配方式：1、 精确匹配 /hello.html 2、 通配符匹配 /* 使用 “ * “ 匹配 0 或 多个 字符 3、 后缀匹配 *.do 使用 “ *. “ 开头，后接多个字符 ,比如，后接 do ，会处理所有 以 “ .do “ 结尾的请求。注： 后缀匹配 不以 “ / “ 开头 。 4.2 请求参数没有请求参数：http://localhost:8080/TestTomcat2/wowowo有请求参数：http://localhost:8080/TestTomcat2/wowowo?num=10问号 表示 后面是一些请求参数。num是请求参数名。http://localhost:8080/TestTomcat/bmi?weight=60&amp;height=1.9&amp; 连接多个请求参数。 5. 字符集编码问题servlet 输出中文有乱码response.getWriter().println 方法在默认情况下，会使用”iso-8859-1”来编码，而 “iso-8859-1” 编码不支持中文。 解决，把响应输出编码方式 设置为 utf-8 ：1response.setContentType("text/html;charset=utf-8") 注意顺序：先设置编码，后获取输出流 response.getWriter()。 表单中包含中文参数值 引起乱码原因： 表单 提交时，browser会对表单中的值进行编码（用页面的编码方式），服务端解码时，默认用 iso-8859-1 来解码。解决，把页面字符集设置为 utf-8 同时 把服务端解码方式 设置为 utf-8 ：1、 在HTML 的 &lt;head&gt; 中加个&lt;meta&gt; 标签，指定表单提交时的编码方式：1&lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt; 2、 服务端 request.getParameter() 必须使用相同的 字符集 解码:1request.setCharacterEncoding("utf-8"); 该指定只对 POST请求 有效，对 GET请求 无效 (GET方法提交表单是，提交的内容在URL中，一开始就已经按照编码分析提交内容，所以 setCharacterEncoding() 对 GET 无效)。 注意顺序：先设置编码，后获取 参数 request.getParameter()。 6. 转发1、 转发：一个 web 组件 (servlet/jsp) 将 未完成的处理交个另外一个 web 组件 继续做。比如，一个 servlet 将处理结果 转发 给一个 jsp 来展现。 2、 如何转发： 绑定数据到 request 对象上 123456//name 绑定名， obj 绑定值//obj 不存在的话 就是nullrequest.setAttribute(String name, Object Obj);//依据绑定名获得绑定值Object request.getAttribute(String name); 获得转发器 12//uri 是转发的地址RequestDispatcher rd= request.getRequestDispatcher(String uri); 转发 1rd.forward(request, response); 注： 转发之后 ， 浏览器的地址不变。即，浏览器访问的地址，不会随着转发而改变，转发是服务器内部的事情，浏览器并不知情。 转发地址有限制，必须是同一个应用。 转发可以共享请求对象，响应对象。 重定向不能共享，因为重定向浏览器会发起两次请求。第一次请求完毕会销毁request 和 response 。 7. 处理servlet 运行时异常处理 servlet 运行时异常有两种方法： 1、 转发到异常处理页面绑定异常处理信息到 request转发到一个异常处理页面编写异常处理页面 2、 交个容器处理将异常抛给容器， throw new ServletException(e)在 web.xml 中配置异常处理页面，编写异常处理页面 通常， 系统异常 (如，数据库连接断了)交给容器处理。应用异常 (如，登录密码错误)一般使用转发来处理。 8. 路径问题1、 超链接:1&lt;a href="delete.do"&gt;删除&lt;a&gt; 2、 表单提交:1&lt;form action="add.do"&gt; 3、 重定向:1response.sendRedirect("list.do"); 4、 转发：1request.getRequestDispatcher("listEmp.jsp"); 绝对路径： 以 “/” 开头。超链接、表单提交、重定向 写绝对路径时： 从 应用名 开始写。转发 写绝对路径时： 从 应用名之后 开始写。 硬编码：路径写死，如：/webApp/jsp/hello.jsp注意： 不要把 应用名 直接写在路径里！应该使用下面的方法获取部署时的应用名：1String rootDir = request.getContextPath() 相对路径： 不以 “/” 开头。]]></content>
      <categories>
        <category>servlet</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 安装与命令行操作]]></title>
    <url>%2F2018%2F09%2F01%2FMySQL-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[MySQL1. Ubuntu 安装 MySQL 1234#安装 mysql-server 会要求输入 root密码sudo apt-get install mysql-server apt-get isntall mysql-clientsudo apt-get install libmysqlclient-dev 启动 mysql 服务： 12service mysql startsudo netstat -apt | grep mysql 如果看到有mysql 的 socket 处于 listen 状态则表示 启动成功。 2. MySQL命令行2.1 登录MySQL123mysql -u root -p# -u root 表示用 root 账户登录# -p 表示 password 本地登录 MySQL 没有问题，但是远程登录的时候，默认是拒绝连接的，这是配置文件默认配置的问题。12345678910111213cd /etc/mysqlvim mysql.conf.d/mysql.cnf# 修改 系统变量 bind-address 为0.0.0.0 表示绑定地址任意# bind-address = 0.0.0.0service mysql restart``` 更多 [server系统变量](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html) 详细配置 参见官方文档。## 2.2 查看数据库### 2.2.1显示数据库```MySQLshow databases 如果已经用 root 用户登录了，如下图，可以看到默认的 4 个数据库(不包括DBmitre，这是我后来创建的)。 2.2.2连接数据库： use &lt;数据库名&gt;12345--查看当前使用的数据库，默认是NULLselect database();--选择数据库 DBmitreuse DBmitre; 2.3 创建和删除数据库12345--create database &lt;数据库名&gt;create database DBmitre;--drop database &lt;数据库名&gt;drop database DBmitre; 2.4 创建用户1、增加一个用户 user1 密码为 password1，让他可以在任何主机上登录( 主机地址填写为% )，并对所有数据库有查询、插入、修改、删除的权限。首先用root用户连入MYSQL，然后键入以下命令：1grant select,insert,update,delete on *.* to use1r@% Identified by “password1”; 2、增加一个用户 user2 密码为 password2,让他只可以在localhost上登录，并可以对数据库 DBmitre 进行查询、插入、修改、删除的操作（localhost指本地主机，即MYSQL数据库所在的那台主机），这样用户即使用知道user2的密码，他也无法从internet上直接访问数据库，只能通过MYSQL主机上的web页来访问了。1grant select,insert,update,delete on DBmitre.* to user2@localhost identified by “password2”; 3、如果你不想 user2 有密码，可以再打一个命令将密码消掉。1grant select,insert,update,delete on DBmitre.* to user2@localhost identified by “”; 2.5 其他命令 12345678 --显示MYSQL的版本 select version();--当前选择的数据库select database();--当前用户及数据库连接地址select user(); 3. 字符集问题查看表的字符集1234show create table table_name \G;--查看字符集show variables like &apos;%char%&apos;; 修改 表 的字符集：1ALTER TABLE table_name DEFAULT CHARACTER SET character_name; 同时修改 表和列 的字符集：1ALTER TABLE table_name CONVERT TO CHARACTER SET utf8; 注：也可以修mysql配置文件/etc/my.cnf 来改变字符集。在 [mysqld] 下 添加 character_set_server=utf8 修改字符集，然后重启。 JDBC 连接MySQL 这样还不能完全解决乱码问题，因为 JDBC 驱动默认的字符集 是 ISO-8859-1。解决方法：在连接URL中加 “?useUnicode=true&amp;characterEncoding=utf8” 来指定 JDBC 驱动连接数据库的字符集。 12345678910111213public static Connection getConnection() throws Exception &#123; String driver="com.mysql.jdbc.Driver"; String url="jdbc:mysql://cherry.mitrecx.cn:3306/DBmitre"; Connection conn=null; try &#123; Class.forName(driver); conn=DriverManager.getConnection(url+"?useUnicode=true&amp;characterEncoding=utf8","root","1234567"); &#125; catch (Exception e) &#123; e.printStackTrace(); throw e; &#125; return conn; &#125; 注：Oracle 数据库不会存在这样字符编码的问题。 references MySQL 8.0 Reference Manual Mysql常用命令行大全]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 用户管理]]></title>
    <url>%2F2018%2F09%2F01%2FLinux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Linux用户管理1. 添加用户1234#添加用户useradd -s /bin/bash -m mitre#设置密码passwd mitre -s: name of user’s login shell-m: home directory 或者：1sudo adduser mitre useradd 和 adduser 区别：useradd 如果后面不添加任何参数选项，创建出来的默认是“三无”用户：一无Home Directory，二无密码，三无系统Shell。adduser 创建用户的过程是一种人机对话，系统会提示你输入各种信息，然后会根据这些信息帮你创建新用户。 2. 删除用户1userdel -r mitre -r 表示:Files in the user’s home directory will be removed along with the home directory itself and the user’s mail spool.Files located in other file systems will have to be searched for and deleted manually.用户home目录中的文件将随home目录本身和用户的邮件卷一起删除。位于其他文件系统中的文件将必须手动搜索和删除。 3. sudosudo /ˈsuːdoʊ/ :以前：superuser do现在：substitute user do 如果用户XXX没有 superuser 权限，使用 sudo 时，会提示： XXX is not in the sudoers file. This incident will be reported. 把XXX加入 sudoers 中：1vim /etc/sudoers 添加: username &nbsp;&nbsp; ALL=(ALL:ALL) ALL 4. 用户的其他操作12345678#查看哪些用户在线who -H#切换用户 substitutesu username#切换到rootsudo -s The Unix command su), which stands for(代表，表示) substitute user is used by a computer user to execute commands with the privileges of another user account. 5. references sudo sudo and sudoers]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsp学习]]></title>
    <url>%2F2018%2F09%2F01%2Fjsp%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1. jsp 简介jsp 是 sun 公司制定的一种 服务器端动态页面技术 规范。 jsp 文件以 “.jsp” 结尾，文件内容主要是 HTML 和 少量 java 代码。容器会将 jsp 文件自动转换成一个 servlet ，然后执行。 我们用 (PrintWriter)out.println 可以动态地生成页面，那么为什么还需要 jsp ？原因有二： out.println 只适用于生成简单的页面。生成复杂的页面，修改将会十分困难。 jsp 将页面与 java控制逻辑代码(servlet) 分开，专注 动态生成页面。简洁，简单，功能强大。 2. 如何写一个 jspstep1. 创建 “.jsp” 文件 step2. 添加以下内容：1、 HTML(css, js) 直接写 2、 java 代码： ① java 代码片段 &lt;% java 语句; %&gt; ② jsp 表达式&lt;%= java表达式 %&gt; 等价于 out.print(java对象);jsp表达式的唯一的作用是，不用写print 语句了。。。 3、 隐含对象(9个) 在 jsp 文件中可以直接使用的对象：outrequestresponsesession 4、 指令指令：通知容器，在将 jsp 文件转化成 servlet 类时，做一些额外的处理，比如 导包。 指令的语法：&lt;%@ 指令名称 属性=属性值 %&gt; page 指令：import 属性 用于导包例如：1&lt;%@page import = "java.util.*" %&gt; contentType 属性 response.setContentType() 的内容pageEncoding 属性 jsp 文件的编码例如：1&lt;%@page contentType="text/html;charset=utf-8" pageEncoding="utf-8" %&gt; include指令:将 jsp 文件转换成 servlet 类时，将 file 属性 指定的文件的内容插入到所在位置：1&lt;%@include file="header.jsp" %&gt; 3. jsp 是如何执行的 容器将 jsp 文件转换成一个 servlet 类 HTML（css, js） —&gt; 放在service 方法中，用out.write 输出。 &lt;% java 语句; %&gt; —&gt; 放在service 方法中，原封不动。 &lt;%= java表达式 %&gt; —&gt; 放在service 方法中，out.print(java表达式) 输出。 容器调用 servlet 可以看出，jsp 最终还是转换成 java 代码了。如： hello.jsp 执行以后 生成 hello_jsp.java]]></content>
      <categories>
        <category>jsp</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>servlet</tag>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议的简单应用]]></title>
    <url>%2F2018%2F09%2F01%2FHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 什么是HTTP协议由 w3c 制定的网络应用层协议，规定了 浏览器与web服务器 之间如何通信，以及数据包的结构。通信过程：step1. 建立连接step2. 发送请求step3. 发送相应step4. 关闭连接 特点：一次请求，一次连接。即如果浏览器需要发送新的请求，就需要建立新的连接。这样设计的优点是，服务器可以利用 有限的连接 为尽可能多的 请求 服务。 2. HTTP数据包格式 请求数据包请求行消息头实体内容 相应数据包状态行消息头实体内容 利用 eclipse 自带的抓包工具 抓个包：打开 window -&gt; show view -&gt; other -&gt; debug -&gt; tcp/ip monitor右击空白处-&gt; properties -&gt; add比如简单配置如下OK 完了 start。现在访问12#以下路径# http://localhost:8888/TestTomcat2/bmi?height=1.7&amp;weight=100 注意端口是8888，这个monitor就是一个代理服务器，它会转发到Tomcat 监听的8080端口。源代码 现在看看 monitor 转发了什么(show header)Request:123456789101112131415161718#请求行#注：GET请求会把请求参数放在路径的后面GET /TestTomcat2/bmi?height=1.7&amp;weight=100 HTTP/1.1 # 键值对 用冒号: 隔开Host: localhost:8080 #消息头Connection: keep-alive Upgrade-Insecure-Requests: 1 #浏览器信息User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)AppleWebKit/537.36 (KHTML, like Gecko)Chrome/68.0.3440.84 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate, br Accept-Language: en,zh;q=0.9,lb;q=0.8,zh-CN;q=0.7,en-US;q=0.6 #实体内容#这是一个GET请求，实体内容没有数据！#只有POST请求，才有内容 Response:12345678910111213#状态行HTTP/1.1 200#消息头#Content-Type服务器返回的数据类型Content-Type: text/html;charset=ISO-8859-1 Content-Length: 39 Date: Wed, 08 Aug 2018 16:31:22 GMT#实体内容34.602076124567475&lt;h1&gt;my pride&lt;/h1&gt;#浏览器解析其中的数据，生成相应的页面 3. HTTP的两种请求方式GET请求以下情况，浏览器发送 get 请求 直接输入url 点击链接 表单默认提交方式 123&lt;!--表单的 提交方式method 默认就是get --&gt;&lt;form method=&quot;get&quot;&gt;&lt;/form&gt; GET请求特点： 请求参数放在请求资源路径的后面 最多只能提交2k字节 不安全 POST请求以下情况，浏览器发送 post 请求 设置表单 method=”post” 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;!-- 模拟content-type消息头 --&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt; &lt;/head&gt; &lt;body style="font-size:30px;"&gt; &lt;form action="TestTomcat2" method="post"&gt; &lt;fieldset&gt; &lt;legend&gt;欢迎&lt;/legend&gt; 身高：&lt;input name="height"/&gt; 体重：&lt;input name="weight"/&gt; &lt;input type="submit" value="确定"/&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 12345# 打开URLhttp://localhost:8888/TestTomcat2# 填好表单，点击提交# 将会自动跳转到以下URL，请求参数不会显示出来http://localhost:8888/TestTomcat2/bmi post 请求特点： 不会把请求参数显示在URL中 相对安全 （注：不会对请求参数加密） 4. HTTP 状态码：404 : HTTP Status 404 – Not Found 没有资源描述：The requested resource is not available.或者是，The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. 可能原因： 请求地址写错 没有部署该应用 map.xml 中， 不一致 500 : HTTP Status 500 – Internal Server Error 服务器程序运行错误cannot be cast to javax.servlet.Servlet 可能原因： 我们自己写的 servlet 没有继承 HTTPServlet. (console: cannot be cast to javax.servlet.Servlet) map.xml 中， 写错了，包中没有这个 class。 代码写的不严谨，比如 对请求参数没有做检查就去转换。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程桌面Ubuntu]]></title>
    <url>%2F2018%2F09%2F01%2F%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2Ubuntu%2F</url>
    <content type="text"><![CDATA[远程桌面UbuntuLinux 有 ssh ，Windows 有 Xshell ，那么还要远程桌面干嘛？？ssh隧道 虽然强大，但是在安装 Oracle Weblogic Server/Oracle数据库 的时候，ssh 将束手无策。有了图形桌面，在服务端安装 Oracle产品 将易如反掌。 1. 服务端(Ubuntu)不论是 Windows 还是 Linux 远程连接 Ubuntu 都需要在远程服务端安装 桌面环境 。 1.1 xrdp 和 vncxrdp: An open source remote desktop protocol(rdp) server.xrdp uses the remote desktop protocol to present a GUI(Graphical User Interface) to the user. vnc 是一种 图形桌面共享系统(graphical desktop sharing system)。它利用 RFB协议(Remote Frame Buffer protocol) 来远程控制另一台计算机。 1.2 在Ubuntu上安装桌面环境12# 安装xrdpsudo apt-get install xrdp 仅仅安装 xrdp 协议，还不能在windows上使用 远程桌面 连接到Ubuntu。还要安装vnc4Server才行：12345678# 安装vnc4serversudo apt-get install vnc4server# 安装xubuntu-desktopsudo apt-get install xubuntu-desktop# 向xsession中写入xfce4-session(每个用户需要单独运行)echo "xfce4-session" &gt;~/.xsession 开启xrdp服务1sudo service xrdp restart 2. 本地端(Linux/Windows)2.1 本地为 Windows 环境打开 Windows 自带的 远程桌面连接 工具，输入 服务端 IP 和 用户名，密码 就可以连接了。 2.2 本地为 Linux 环境暂时没试，以后再说。2018-8-21]]></content>
      <categories>
        <category>远程桌面</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>远程桌面</tag>
        <tag>xrdp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 安装weblogic]]></title>
    <url>%2F2018%2F09%2F01%2FLinux-%E5%AE%89%E8%A3%85weblogic%2F</url>
    <content type="text"><![CDATA[Ubuntu16.04 上搭建 weblogic 应用服务器weblogic简介：Oracle WebLogic Server is a scalable, enterprise-ready Java Platform, Enterprise Edition (Java EE) application server. The WebLogic Server infrastructure(基础设施) supports the deployment(部署) of many types of distributed applications(分布式应用程序) and is an ideal foundation for building applications based on Service Oriented Architectures (SOA).Oracle WebLogic Server是一个可扩展的企业Java平台，企业版（Java EE）应用服务器。WLS设施支持的许多类型的分布式应用程序的部署，它是一个基于面向服务的架构（SOA）的理想的构建应用的基础。简单来讲：WLS是一个企业级的应用服务器。 1. 准备工作 – java开发环境1java -version 如果没有jdk环境的话，首先安装jdk。安装方法：12345sudo add-apt-repository ppa:webupd8team/javasudo apt updatesudo apt install oracle-java8-installer 如果不能使用 add-apt-repository ，那么需要安装：12apt-get install python-software-propertiesapt-get install software-properties-common 2. 安装weblogic2.1 安装下载weblogic. 下载选择 generic installer(通用下载器) 即可。 其实安装WebLogic Server 非常简单。由于你对 Linux 图形桌面环境 不了解，那么你可能会走一点弯路。 工作需要，我买了阿里的云主机MITRE(Ubuntu16.04)。ssh 连接到MITRE上，然后在终端操作安装weblogic，可是，总是报 X11 与图形桌面相关的错误。明明是按照Oracle官网的安装教程走的，不可能错的啊！！于是在自己的laptop(Ubuntu16.04)上也安装了一遍。第一步就出问题了！查看相关资料验证了我的猜想，Oracle 的WebLogic Server安装必须要有桌面环境。 远程桌面Ubuntu16.04 的方法，参考这里 执行 jar文件 开始安装，基本上全选默认:1java -jar fmw_12.2.1.3.0_wls_generic.jar 安装WebLogic Server细节问题，参考这里 2.2 建域创建一个域(domain)：123456789# weblogic 12c 建域的脚本在这个目录下 /Oracle/Middleware/Oracle_Home/oracle_common/common/bin# 其他版本的weblogic ，查找建域脚本所在目录find . -name "config.sh" -print# 打开 find 到的那个目录cd config_dir#执行建域脚本./config.sh 注1 : 需要输入密码，模式选product 而不选 development。 注2 : weblogic 12c 在 Middleware/wlserver 目录下也有一个 config.sh , 但这个目录下的脚本是不建议( deprecated )使用的。可以自行打开查看。 注3 :我这里（WebLogic 12c Release）创建域也要桌面环境，但 11g 是不用的。。 2.3 配置密码文件 boot.properties每次在终端启动WebLogic的时候都要输入用户名、密码，很麻烦。可以在AdminServer 目录下创建security/boot.propertiesboot.properties里只要写上用户名、密码就可以了。123# domain/base_domain/servers/AdminServer/security/boot.propertiesusername=weblogicpassword=password 服务器启动一次，boot.properties会自动加密。 3. weblogic 相关问题./startWeblogic 启动webLogic， 启动到 卡住不动，据说，这是JDK一个bug。解决办法: 在weblogic启动脚本里 setDomainEnv.sh, 加入以下内容:12JAVA_OPTIONS="$&#123;JAVA_OPTIONS&#125; -Djava.security.egd=file:/dev/./urandom"export JAVA_OPTIONS references WebLogic Reference Guide]]></content>
      <categories>
        <category>weblogic</category>
      </categories>
      <tags>
        <tag>weblogic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu软件安装问题]]></title>
    <url>%2F2018%2F08%2F04%2Fubuntu%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天想安装一个ksh，结果报错了。然后我发现，install 任何软件都会报同样的错。错误如下：最后还有一句： E: Problem with MergeList /var/lib/apt/lists/ppa.launchpad.net_chris-lea_node.js_ubuntu_dists_xenial_main_binary-amd64_Packages这无疑是 软件源 (/etc/apt/sources.list)出问题了。 解决办法：1234#删除apt-get install 的所有软件状态包sudo rm /var/lib/apt/lists/* -vf#更新并覆盖所有以apt-get 方式安装的软件源或包sudo apt-get update /var/lib/apt/lists/var 包括系统运行时要 改变 的数据。 如果/usr是 安装时 会占用较大硬盘容量的目录，那么/var就是在系统 运作后 才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性 变动的文件 ，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件。 /var/lib/ 程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件有各自的目录。举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去。 /var/lib/apt 可以理解为apt的缓存。 安装软件Source list的问题都可以试试先删除缓存，再更新：12sudo rm /var/lib/apt/lists/* -vfsudo apt update /etc/apt/sources.list 的解读/etc/apt/sources.list 和/etc/apt/sources.list.d/*.list的各文件。 是 包管理工具 apt 所用的记录软件包仓库位置的配置文件。 /etc/apt/sources.list文件内容截取：1234deb http://mirrors.aliyun.com/ubuntu/ xenial universe# deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe#deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial-updates universe 可以看到，每一行(条目) 由 4个字段组成： 档案类型 仓库地址 发行版 软件包分类 档案类型 (Archive type)条目的第一个词 deb 或是 deb-src 表明了所获取的软件包档案类型。档案类型有两种： deb 档案类型为 二进制预编译软件包 ，一般我们所用的档案类型。 deb-src 档案类型为用于编译二进制软件包的源代码。 仓库地址 (Repository URL)条目的第二个词则是软件包所在仓库的地址。我们可以更换仓库地址为其他地理位置更靠近自己的镜像来提高下载速度。我用的镜像地址是 阿里云 的。 发行版 (Distribution)跟在仓库地址后的是发行版。发行版有两种分类方法:一类是 发行版的具体代号，如 xenial, trusty, precise 等；一类则是 发行版的发行类型，如oldstable, stable, testing 和 unstable。 软件包分类 (Component)跟在发行版之后的就是软件包的具体分类了，可以有一个或多个。 Ubuntu 对软件包的分类可以用下表来表示(参考自 Wikipedia): 自由软件 非自由软件 官方支持的 Main Restricted 非官方支持的 Universe Multiverse universe 社区维护的自由软件。multiverse 非自由软件。 References: /etc/apt/sources.list 详解 深入理解linux系统的目录结构]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[企业身份代码]]></title>
    <url>%2F2018%2F08%2F03%2F%E4%BC%81%E4%B8%9A%E8%BA%AB%E4%BB%BD%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[概述我国现有现有主要机构代码我国现有机构代码分为两类。一是“原始码”，即由登记管理部门在法人和其他组织注册登记时发放的代码，主要包括工商部门的工商注册号、机构编制部门的机关及事业单位证书号、民政部门的社会组织登记证号等。二是“衍生码”，即在法人和其他组织注册后，相关部门发放的管理码，如组织机构代码管理部门的 组织机构代码、人民银行的 机构信用代码、税务总局的纳税人识别号等。 1.组织机构代码。组织机构代码管理部门编制的组织机构代码共9位，包含本体代码（8位）和校验码（1位）两个部分。 2.工商注册号。工商部门编制的工商注册号共15位，包含首次登记管理机关代码（6位）、顺序码（8位）和校验码（1位）三个部分。 3.事业单位证书号。机构编制部门编制的事业单位证书号共12位，包含举办单位类别（1位）、核准登记的机关（6位）、同一机关辖内不同事业单位（5位）三个部分。 4.社会组织登记证号。民政部门编制的社会组织登记证号是汉字和阿拉伯数字的组合。 5.机构信用代码。人民银行编制的机构信用代码共18位，包含准入登记管理机构类别（1位）、机构类别（2位）、行政区划（6位）、结算账户开户许可证核准号标识位（8位）、校验码（1位）五个部分。 6.纳税人识别号。税务部门对已申领组织机构代码的纳税人编制的纳税人识别号共15位，包含行政区划码（6位）和组织机构代码（9位）两个部分。 组织机构代码代码一共有9位： 由8位数字(或大写拉丁字母)本体代码和1位数字(或大写拉丁字母)校验码组成。组织机构代码是对中华人民共和国内依法注册、依法登记的机关、企事业单位、社会团体，以及其他组织机构颁发一个在全国范围内唯一的、始终不变的代码标识。如同居民的身份证一样，组织机构代码证是组织机构在社会经济活动中统一赋予的单位身份证。组织机构代码系统覆盖范围广泛，对申领代码单位的资质审核也有数字档案（档案数字化）作为凭证，可以动态追溯每一个组织机构的历史发展变化。2016年10月18日，国家质量监督检验检疫总局发布《国家质量监督检验检疫总局关于修改和废止部分规章的决定》（总局令第184号），正式废止组织机构代码管理办法。组织机构代码在优化营商环境改革中退出了历史舞台。取而代之的是统一社会信用代码。 统一社会信用代码统一社会信用代码相当于让法人和其他组织拥有了一个全国统一的“身份证号”，是推动社会信用体系建设的一项重要改革措施。 1. 发展历程2015年6月4日，国务院常务会议决定实施法人和其他组织统一社会信用代码制度，提升社会运行效率和信用。截至2018年3月底，全国法人和非法人组织存量代码转换率为99.8%，存量证照换发率82%；全国个体工商户存量换码率95%。 2. 构成特点一是嵌入了组织机构代码作为主体标识码。通过组织机构代码的唯一性确保社会信用代码不会重码。换言之，组织机构代码的唯一性完美“遗传”给统一社会信用代码。二是在组织机构代码前增加行政区划代码，这个组合不难发现就是税务登记证号码。这样就提高了统一社会代码的兼容性，在过渡期内税务机关可以利用这种嵌套规则更加便利地升级到新的信用代码系统。三是预留前两位给登记机关和机构类别，这样统一社会信用代码在应用中更加清晰高效，第一位便于登记机关管理，可以作为检索条目，第二位可以准确给组织机构归类，方便细化分管。四是统一社会信用代码位数为18位，和身份证的位数相同，这一巧妙设计在未来“两码管两人”的应用中可以实现登记、检索、填表等统一。 现有机构代码存在的主要问题当前我国机构代码不统一，缺乏有效协调管理和信息共享工作机制，大多数代码仅应用于各部门内部管理，一些部门信息数据相互割裂封闭，存在信息孤岛问题。各类机构代码长度、含义、作用不同，有的部门如工商、民政、机构编制部门等，在法人和其他组织成立时赋码；有的部门如人民银行、税务部门等，在行使管理职能过程中再次赋码。法人和其他组织在设立和办理相关业务时，需到多个部门申请代码，有的还收取费用。多个代码共存现象较为普遍，影响了同一主体信息比对，增加了社会负担，降低了行政效率。 机构信用代码机构信用代码 是 中国人民银行 以金融业务为基础，赋予每个机构在全国范围内唯一的，不变的编码。 1. 什么是机构信用代码？机构信用代码，是指中国人民银行以金融业务为基础，按照一定规则赋予每一个机构在全国范围内唯一、不变的编码。机构信用代码以结算账户开户许可证核准号为基础编制，共18 位，包含有准入管理部门类别、机构类别、行政区划代码等内容。 2. 什么是机构信用代码证？机构信用代码证是承载机构信用代码的证书。机构信用代码证由中国人民银行统一式样和内容，记载机构信用代码、机构名称、注册地址及发证单位等信息。 3. 机构信用代码证有什么用？机构信用代码证已逐步在人民银行和银行业金融机构征信业务、信贷业务、账户业务、现金业务、票据业务、外汇业务等领域推广应用，将成为金融系统及其他经济领域机构客户身份识别的重要手段，成为机构的“经济身份证”。机构在人民银行和银行业金融机构办理业务时，出示机构信用代码证，可以得到更加方便、快捷的金融服务。四、哪些机构可以申领机构信用代码证？在中华人民共和国境内依法设立、从事经济活动的机关、事业单位、企业、社会团体、民办非企业以及其他组织均可申领机构信用代码。 4. 机构信用代码系统记录哪些信息？人民银行建设了机构信用代码系统对外提供服务，机构信用代码系统记录机构的基本信息：名称、登记注册部门、注册地址、成立日期等，以及机构已有的其他代码，如登记注册号、纳税人识别号等。机构信用代码系统通过存储机构的信用代码和其他已有代码，实现机构信用代码与其他代码的索引和关联查询功能。]]></content>
      <categories>
        <category>宇信工作</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[work&whark]]></title>
    <url>%2F2018%2F08%2F03%2Fwork-whark%2F</url>
    <content type="text"><![CDATA[搭建weblogic环境 学习servlet]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux系统管理]]></title>
    <url>%2F2018%2F02%2F18%2FLinux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[root: 系统管理员的登录管理员主要使用root用户ID履行职责。1grep "^root" /etc/passwd 以上命令输出可以看出root用户ID为0，事实上，任何一个以0为事实UID的进程都具有root的能力。 123su -#有时候需要用sudo执行sudo su - “ - ” 参数表示使用root的登录环境； 如果想保留当前用户的环境（如，主目录），就不用参数 “ - “。root的提示符（PS1）通常是 # su不仅可以切换到root用户，su可以切换到任何一个用户(su [opt] [uname])：12su mitresu mitrecx 用户管理理解/etc/passwd除密码以外，所有用户信息都存储在/etc/passwd中。这个文件曾经包含了密码，所以人们还一直在用passwd称呼它。现在密码加密存储在/etc/shadow。login和passwd程序会查阅这两个文件，以完成用户身份验证。 passwd文件一共7个字段： 用户名 密码：早期UNIX系统的密码是放在这个文件中的，但因为这个文件的特性是所有程序都能够读取，所以，这样很容易造成数据被窃取，因此后来就将这个字段的密码数据改放到/etc/shadow中了 UID：用户ID，每个账号名称对应一个UID，通常UID=0表示root管理员 GID：组ID，与/etc/group有关，/etc/group与/etc/passwd差不多，是用来规范用户组信息的 用户信息说明栏： 用来解释这个账号是干什么的 家目录：home目录，即用户登陆以后跳转到的目录，以root用户为例，/root是它的家目录，所以root用户登陆以后就跳转到/root目录这里 Shell：用户使用的shell，通常使用/bin/bash这个shell，这也就是为什么登陆Linux时默认的shell是bash的原因，就是在这里设置的，如果要想更改登陆后使用的shell，可以在这里修改。另外一个很重要的东西是有一个shell可以用来替代让账号无法登陆的命令，那就是/sbin/nologin。 理解/etc/groupgroup一个4个字段： 组名 密码 组ID（GID） 属于该组的用户列表 123#添加用户组 gid为1314 gname为offergroupadd -g 1314 offer#详细参数man 修改和添加用户配置文件1useradd -u 210 -g dba -c "THE RDBMS" -d /home/oracle -s /bin/ksh -m oracle useradd — create a new user or update default new user information -u, –uid UIDThe numerical value of the user’s ID. This value must be unique, unless the -o option is used. The value must be non-negative. The default is to use the smallest ID value greater than or equal to UID_MIN and greater than everyother user.-g, –gid GROUPThe group name or number of the user’s initial login group. The group name must exist. A group number must refer to an already existing group.If not specified, the behavior of useradd will depend on the USERGROUPS_ENAB variable in /etc/login.defs. If this variable is set to yes (or -U/–user-group is specified on the command line), a group will be created for the user, with the same name as her loginname.-c, –comment COMMENTAny text string. It is generally a short description of the login, and is currently used as the field for the user’s full name.-d, –home-dir HOME_DIRThe new user will be created using HOME_DIR as the value for the user’s login directory. The default is to append the LOGIN name to BASE_DIR and use that as the login directory name. The directory HOME_DIR does not have to exist but will not be created if it is missing.(如果没有HOME_DIE目录，这个-d选项会失效)-s, –shell SHELLThe name of the user’s login shell. The default is to leave this field blank, which causes the system to select the default login shell specified by the SHELL variable in /etc/default/useradd, or an empty string by default.-m, –create-homeCreate the user’s home directory if it does not exist. The files and directories contained in the skeleton directory(which can be defined with the -k option) will be copied to the home directory. 一个例子：123sudo useradd -s /bin/bash -m smsudo passwd smsudo userdel -r sm userdel — delete a user account and related files -r, –removeFiles in the user’s home directory will be removed along with the home directory itself and the user’s mail spool.Files located in other file systems will have to be searched for and deleted manually.(如果没有-r选项，就不会删除用户文件,需要自己手动删除) 维护安全因为计算机系统中的安全性最终与文件相关，所以错误的文件权限很容易被恶意用户用于hack。维护文件安全的三种机制： 受限制的shell（可以在passwd的第七字段设置） Set-User-Id(SUID): 临时能力（不同的事实UID和真实UID） 粘着位 粘着位，在/tmp，/usr/tmp目录下，不同的用户创建的文件其他用户可以访问，但不可以删除。这就是通过粘着位实现的。123chmod 1755 one.txtll one.txt-rwxr-xr-t 1 one one 54 2月 18 13:53 one.txt* 注意到，other用户的可执行的位置变成了t，即是 sticky bit。这样其他用户就不能删除不归它们所有的文件。（也不能写）粘着位的用处不大啊，不能删除的话，只要设置给other权限为” r - x “不就行了。。。 启动与关机计算机加电后，系统 会查找所有外围设备，然后执行一系列程序，最终把内核加载到内存中。内核随后生成init ( PID为1 )，init再进一步生成其他进程。init通常做为 initialization(n,初始化) 的缩写使用正常情况下，系统会处于以下这些系统相关的 运行级别（run-level） 之一：0 —— 系统关机1 —— 系统管理模式（加载了本地文件系统）2 —— 多用户模式（NFS不可用）3 —— 完全用户模式5 —— Linux 图形环境模式6 —— 关机和重启模式s或S —— 单用户模式（加载文件系统） 当系统重启时，init首先进入 运行级别 1或S，然后在转入用户模式（2、3或5）。当系统关闭时，init转为 运行级别 0或6 。 管理员可以显式使用init命令，将系统转为任意 运行级别 。12#查看运行级别who -r 我在一天工作结束时，要关机了！使用shutdown命令关闭计算机，shutdown用wall通知所有用户：系统将要关闭，并给出注销指令。注：一些系统（如Solaris）提供了reboot和halt命令，他们也会关闭系统，但不会向用户发出警告。在管理多用户系统时，应当坚持使用shutdown。 文件系统文件系统采用目录结构，有自己的根目录。操作系统通常驻留在多个文件系统上。在启动时，这些文件系统使用一种加载技术合并起来，向用户显示为单个文件系统。这些文件系统中有一个特殊系统—— 根文件系统。它包含UNIX的基本要素——root目录、/bin、/etc、/dev、/lib目录。大多数系统还有 交换文件系统 ，当系统内存中加载的内容过多时，内核会将一些进程移除内存，放到swap文件系统中。当这些交换的进程做好运行准备时，再将它们加载到内存。用户不能直接访问swap。 除了这些基本的文件系统之外，还有更多的文件系统。系统文件应当与用户创建的数据文件隔离存放。因此，通常有一个/home文件系统来容纳所有用户，将/usr、/tmp等作为独立的文件系统。 文件系统的4个组成部分： 启动块——这个块 包含了 一个小的 启动程序和分区表，它经常被称为主引导记录（MBR）。(原来，MBR在文件系统中) 超级块——这个区域包含了有关文件系统的全局信息。包括iNode和数据块的空闲列表。 inode块——包含了文件系统中 每个文件的inode。创建一个文件时，会在这里分配一个inode。 数据块——用户生成的 所有数据和程序 都存储在这一区域。 文件系统类型:ext4,ext3nfsswapvfatfat32windows里还有NTFS 加载和卸载文件系统mount : mount a filesystem12#mount device dirmount /dev/sda1 /tmp umount: unmount file systems12#umount &#123;directory|device&#125;umount /dev/sda1 注：在使用mount -a时，在mount配置文件中列出的所有文件系统都将被加载。在系统启动时会执行mount -a 。同样道理，shutdown会运行 umount -a 。 fsck： 文件系统检查fsck（file system consistency check，文件系统一致性检查）：update守护进程每30秒调用一次sync，将超级块和 inode 的内存副本写到磁盘。这一延迟为文件系统的不一致性创建了条件。如果在将超级块写到磁盘之前发生了掉电，文件系统将不在完整。fsck 命令用于检查和修复被破坏的文件系统。 管理磁盘空间df: 查看磁盘空闲空间df (disk free，磁盘空闲)命令分别报告每个文件系统上的空闲空间数。df - report file system disk space usage du: 磁盘利用率我们经常要查看一个特定目录树的使用情况，而不是整个文件系统的耗用情况。du（disk usage，磁盘利用率）命令会递推查看目录树。如果直接使用du，通常会显示很多文件（列出目录下的所有子目录，子目录的子目录…的使用情况）。一般我们可以使用 -s （summary）选项，只显示一层子目录，而且还是汇总的。 查看/home目录下各用户耗用的空间量： fdiskfdisk - manipulate disk partition table ，磁盘分区表操作工具；1sudo fdisk -l 分别在不同主机上运行，结果如下：注：fdisk可以添加、删除、转换分区，自己还没有尝试，略略… tar: 备份文件tar — The GNU version of the tar archiving utility 键选项（只能使用一个）： 选项 意义 -c 创建一个新档案 -x 从档案中提取文件 -t 列出档案中的内容 -r, -u 在档案中追加文件, -u只追加比档案新的文件 非键选项： 选项 意义 -f archive file，就是要操作的档案 -v 以长格式列出文件 -j –bzip2 -z –gzip, –gunzip –ungzip 测试：123456789101112131415161718192021222324252627282930313233343536373839#把当前目录下的shell脚本备份到 666档案mitre@mitre-TM1701666:~/Desktop$ tar -cvf 666 *.shhh.shifStr.shset.shtest.shtt.sh#把 以f开头的文件 追加到 666mitre@mitre-TM1701666:~/Desktop$ tar -uvf 666 f*first_prog.cfoomitre@mitre-TM1701666:~/Desktop$ tar -tvf 666-rwxrwxr-x mitre/mitre 56 2018-02-03 23:43 hh.sh-rwxrwxr-x mitre/mitre 166 2018-02-03 15:28 ifStr.sh-rwxrwxr-x mitre/mitre 77 2018-02-03 22:29 set.sh-rwxrwxr-x mitre/mitre 209 2018-02-03 02:29 test.sh-rwxrwxr-x mitre/mitre 268 2018-02-10 22:03 tt.sh-rw-rw-r-- mitre/mitre 425 2018-02-07 13:32 first_prog.c-rw-rw-r-- mitre/mitre 191 2018-01-31 18:01 foo#备份目录mitre@mitre-TM1701666:~/Desktop$ tar -jcvf dir.bzip2 Dir/Dir/Dir/rec_depositDir/Makefile2Dir/cdir/Dir/cdir/kkDir/MakefileDir/rec_deposit.oDir/quit.oDir/quit.cDir/rec_deposit.cDir/arg_check.hDir/quit.hDir/arg_check.cDir/progs.tarDir/arg_check.o]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统程序设计2-进程控制]]></title>
    <url>%2F2018%2F02%2F14%2FLinux%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[进程概述内核为进程映像分配内存，但还会在大量寄存器中维护控制信息。内核利用控制信息来切换进程。 虚拟地址空间在执行C程序时，“程序加载器”把磁盘上的二进制代码转移到内存中。如果 进程 需要，内核还会在内存中生成额外的空间。进程可以访问这一部分内存位置 称为进程的虚拟地址空间。虚拟地址空间划分为许多段： 文本段：包含要执行的指令(instruction)，是从磁盘文件读入的。一个程序的多个实例可以共享这个段（如：三个运行vi的用户将使用同一个文本段）。 数据段：存储着程序使用的全局、静态变量。 栈：存储着局部变量和函数的参数及返回地址。 其他段：命令行参数和环境变量通常在栈的底部。 进程表每个活动的进程的属性都存储在一个结构中，这个结构代表 进程表 中的一项。现代Linux/Unix在内存中维护进程表。进程表的重要属性如下： 进程的PID和PPID 进程的状态——运行、睡眠、僵尸等 进程的真实UID和GID 进程的事实UID和GID（effective 事实的，有效的） 文件说明符表 文件创建掩码 CPU使用信息 挂起的信号掩码 信号处置表 一个fork子进程的 进程表项 有许多字段都是从其父进程复制而来的。当子进程执行一个新程序是，进程表项保留，但一些字段会发生变化。 进程表中包含了与信号相关的重要数据 进程环境一个进程的环境包含存储在栈底部的shell 环境变量。这些变量可以在全局 environ 变量中获得，在C程序中声明如下：1extern char **environ; environ 是一个数组，其中的元素是指向char的指针（就是C风格字符串）。这个数组存储的指针指向 name=value 形式的环境变量字符串。这些值可以用两个函数getenv和setenv来设置和提取：12345//由环境变量名提取其值value，返回指向char类型(value)的指针char *getenv(const char *name);//envname是变量名，envval是变量值，overwrite决定是否覆盖已有值(0不覆盖，1覆盖)int setenv(const char *envname, const char *envval, int overwrite); 举例：12345//获取PATH的值char *path = getenv("PATH");//修改PATH为.setenv("PATH", ".", 1); process.c查看一些进程属性：123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; printf("PID: %4d, PPID: %4d\n", getpid(), getppid()); printf("UID: %4d, GID: %4d\n", getuid(), getgid()); printf("EUID: %4d, EGID: %4d\n", geteuid(), getegid()); printf("PATH = %s\n", getenv("PATH")); setenv("PATH",".",1); printf("New PATH=%s\n",getenv("PATH")); exit(0);&#125; fork: 复制当前进程通过fork()系统调用我们可以创建一个和当前进程印象一样的新进程.我们通常将新进程称为子进程,而当前进程称为父进程.而子进程继承了父进程的整个地址空间,其中包括了进程上下文,堆栈地址,内存信息进程控制块(PCB)等. fork的语法很简单，但其返回方式 不同寻常 :1pid_t fork(void); 为使内核能够区分原进程及复制进程， fork返回两次，分别给出不同的返回值： 子进程返回0 父进程返回子进程的PID 一个简单的fork程序：1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;int main()&#123; pid_t pid; printf("before fork \n"); pid=fork(); if(pid&gt;0) //返回子进程pid，在父进程中 &#123; sleep(1); printf("parent-----pid:%d\t ppid:%d\t child pid: %d\n", getpid(), getppid(), pid); &#125; else if(pid ==0) //返回0，在子进程中 printf("child -----pid:%d\t ppid:%d\n",getpid(),getppid()); else //这是返回-1的情况 &#123; printf("fork error\n"); exit(1); &#125; //以下语句会输出两遍，子父进程各一遍 printf("Both processes continue from here\n"); exit(0);&#125; 以上程序中，sleep(1)是为了让父进程在子进程后执行。因为子进程和父进程的执行顺序是随机的 。 fork()系统调用总结：1）fork()函数的一次调用返回2次返回。2）fork系统调用之后，父进程和子进程交替执行，并且它们处于不同空间中。3) 将fork()返回值大于零设置为父进程,这是因为子进程获得父进程的pid相对容易,而父进程获子进程pid难,所以在fork()系统调用中将子进程的pid作为父进程的返回值，解决了获得子进程pid的问题。 exec: 进程创建的最终步骤我们执行 fork 操作以创建进程，但多半会在后面跟有 exec 操作，在子进程的地址空间中运行另外一个程序。 exec叙述： 在 fork 期间继承的许多属性都不会因为 exec 而改变。例如：上一个程序的文件说明符、root目录、umask设置、全局变量都保持不变。不过coder可以通过两个方式来改变exec后的环境： 关闭一个或多个文件说明符，这样，在 fork 前后打开的文件就不能直接在exec的进程中读取。 向exec的进程中传送一个单独的环境，而不是在environ全局变量中保存默认环境。 我们经常用 exec 这个名称来指代这种关系，并没有一个名为 exec 的系统调用。事实上，有一个execve，有五个库函数都是以她为基础的。我们直接将她们称为exec或exec系列。整个系列可以分为两个部分，分别为 execl 集和 execv 集。注：execl中的 ”l” 表示一个参数列表（list），而execv中的 “v” 表示参数数目可变（variable）。 两个库函数：execl和execvexecl不使用PATH；第一个参数（path）表示一个绝对或相对路径名；其他参数表示命令行中的每个单词。execl用法：1int execl(const char *path, const char *arg0, ..., (char *) ); 例子：1execl("/bin/wc", "wc", "-l", "foo", (char *) 0); 在例子中我们看到，execl的参数以 (char *) 0 结尾，这就是一个0，被强制转换为指向char的指针，相当于NULL。例子表达的意思就是：1wc -l foo 因为execl要求单独指定命令行的每个单词，所以如果 在运行是才能知道参数 ，execl就无法使用了。解决办法是用execv。execv也不使用PATH，第一个参数（path）表示一个绝对或相对路径名；第二个参数是一个存放字符型指针的数组，数组里存放的是要执行的命令。execv用法：1int execv(const char *path, char *const argv[]); 例子：12char *cmdargs[]=&#123;"wc", "-l", "/etc/passwd", NULL&#125;;execv("/bin/wc", cmdargs); 相当于shell中的：1wc -l /etc/passwd 其实我并没有感觉execv有优越性。12345#include &lt;stdio.h&gt;int main()&#123; execl("/bin/wc", "wc", "-l", "/etc/passwd", (char *)0 ); printf("execl error");&#125; 为什么最后写一句”输出错误”？因为除非导致错误，否则对exec的调用不会返回。 其他exec成员execlp和execvp：这些函数使用PATH查找命令的位置，所以第一参数只要给出命令名即可。这里略过。 收集退出状态：wait 和 waitpid一般情况下，一个进程的终止要么是通过main，要么是调用exit或return。它向调用者返回退出状态，这一状态可以在shell中的参数 “$?” 中获得。当一个进程终止而又没有显式调用exit时，退出状态为 0 。在任何一种情况下，内核都会关闭所有已打开文件，刷新所有输出流，释放进程地址空间。但进程没有被完全删除。接下来，内核将退出状态放在进程表中，并将子进程的状态改为僵尸（zombie）。这一机制是“寄希望于” 父进程最终可能调用wait或waitpid，以拾取退出状态。如果父进程最终这样做了，内核就释放该进程表项，并从系统中删除该进程。注：我们无法杀死一个僵尸，因为它不是进程，但太多的僵尸会消耗进程表的可用位置。ps输出内容在最后一列将僵尸显示为。为清除僵尸，可能需要重启系统。 wait：父进程等待子进程死亡waitpid：更强大的等待机制我不清楚为什么需要 wait和waitpid，如果是为了完全删除进程，显示调用exit不就可以了吗？以后理解再说明。 [1]Sumitabha Das, Your UNIX/Linux: the Ultimate Guide, Third Edition]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统程序设计1--文件]]></title>
    <url>%2F2018%2F02%2F14%2FLinux%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A11-%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1. linux系统程序设计—文件系统调用是一种例程。系统调用用于执行文件I/O、分配内存、创建进程等。标准ANSI C库函数，如fopen和printf可以作为对象模块捆绑到一个档案中。系统调用与之不同，它们内置在内核中，一般由汇编语言编写。但是，提供了接口，可以像调用函数一样调用接口。 库函数通常不包含系统调用提供的精细控制功能 。例如：fopen不能设置文件权限，而open可以设置。只有利用stat系统调用才能知道文件的大小。只有fork系统调用才能创建进程。 系统调用要比调用库函数 的的开销大. 2. errno 和 perror：处理错误系统调用在错误时返回-1错误的发生可能会有多种原因——资源不可用、接收到一个信号、I/O操作失败、调用参数无效。 当系统调用返回-1时，内核将静态（全局）变量errno设定为一个正整数。这个用符号常量表示的整数与错误消息相关联。 仅当系统调用返回错误时才使用perror。perror函数语法：void perror(const char *s) ;函数的以一个字符串s为参数。函数输出：打印该字符串s、一个冒号、一个空格，然后是与errno相关联的消息。 符号常量 errno 消息 E PERM 1 Operation not permitted E NOENT 2 No such file or directory E SRCH 3 No such process E INTR 4 Interrupted system call E IO 5 I/O error E ACCES 13 Permission denied E EXIT 17 File exits E NOTDIR 20 Not a directory EISDIR 21 Is a directory 以下程序show_errors.c 1234567891011121314#include &lt;fcntl.h&gt; //获取open中的O_RDONLY#include &lt;stdio.h&gt; //获取fprintf中的stderr#include &lt;stdlib.h&gt; //获取exit#include &lt;sys/error.h&gt; //获取errnoint main(int argc, char **argv)&#123; //以只读模式打开 if(open(argv[1],O_RDONLY)==-1) //O表示open，RD表示read。 &#123; fprintf(stderr, "errno=%d\n", errno); perror("open"); &#125; exit(0);&#125; 执行时，如：$ ./a.out foofooerrno = 2open: No such file or directory 3. open: 打开和创建文件一些与文件Ｉ/O相关的系统调用： open , close read , write lseek truncate , ftruncate 在读写一个文件之前，必须要用open打开它。open语法：1int open（const char \*path, int oflag, ...) ; open以int形式返回一个文件说明符 ( file description ) 。当发生错误时，open返回 -1 。第一个参数(path)是一个指针，指向一个表示文件路径名的字符串(绝对路径或相对路径)，第二个参数(oflag)用于设置打开模式(读、写或读-写)。这一模式用三个符号常量表示：O_RDONLY 打开文件供读取O_WRONLY 打开文件供写入O_RDWR 打开文件供读和写这些常量在/usr/include下的文件 fcnlt.h 中定义。用法:123456int fd;//以只读方式打开passwd文件，如果打开出错，就打印错误if( (fd=open("/etc/passwd",O_RDONLY)) == -1)&#123; perror("open"); exit(1);&#125; 此外，open还有更多打开模式 ( 也在fcntl.h中定义 ):O_APPEND 追加模式打开文件(仅当打开模式为O_WRONLY或O_RDWR)O_TRUNC 将文件截短为0(条件同上)，其实就是覆盖文件(注:truncate 截短、缩短)O_CREAT 若文件不存在，则创建文件O_EXCL 若指定O_CREAT，且该文件存在，则生成一条错误O_SYNC 同步读写操作。确保在将数据写到磁盘之前，write不会返回1234//类似shell中的&gt;&gt;fd=open("foo.txt", O_WRONLY | O_APPEND )//类似shell中的&gt;fd=open("../foo.txt", O_WRONLY | O_TRUNC ) 如果文件不存在，就要用O_CREAT（有时会用到O_EXCL）创建它，并在第三参数指定其权限。Linux/Unix在sys/stat.h中提供了符号常量以设置权限但是也可以，用八进制(octal)数设置权限，必须添加前缀0。（例如0644而不是644）0644等同于：S_IRUSR|S_IWUSR | S_IRGRP | S_IROTH表示用户可读写，组可读，其他可写12//打开foo.txt，以截断方式写入，如果foo.txt不存在，就创建该文件fd = open("foo.txt", O_WRONLY|O_CREAT|OTRUNC, 0644); 4. close: 关闭文件程序在终止之前会关闭所有已打开文件，但不在需要文件时主动关闭是一种好习惯。close系统调用可以关闭一个文件:1int close(int fd); close用文件描述符( file description )作为参数，实际上是释放对该进程的文件说明符。close成功返回0，失败返回-1. 5. read: 读取文件两个系统调用——read和write——负责对常规文件(REG,regular)以及管道和套接字进行读写操作。这两个调用的语法类似，都利用了用户定义的缓冲区。read利用open返回的文件说明符来读取文件：1ssize_t read(int fildes, void *buf, size_t nbyte); read尝试从文件说明符fildes向缓冲区buf中读取nbyte个字符。文件说明符就是要读取的对象，缓冲区是读取后内容存放的地方，nbyte是一次读取n个字节注：nbyte通常是缓冲区本身的大小1234#define BUFSIZE 4096int n;char buf[BUFSIZE];while( (n=read(fd, buf, BUFSIZE))&gt;0 ) //由open获得的fd 每次read调用，读取4096个字节。在遇到EOF之前，read返回所读字符数，而遇到EOF时，返回0( 准确地说，是文件的大小是缓冲区的整数倍，最后一次遇到EOF返回0 )。但最后一次迭代可能例外，最后一次迭代中，返回的是尚未读取的字符数（因为文件的大小可能不是缓冲区大小的整数倍）。read错误返回-1。例如：如上程序，fd描述的文件有4100个字节，第一次迭代read返回4096，第二次迭代read返回4个字节，第三次返回0。 如果要处理所读取的每个字符，可将buf声明为一个char变量，然后将其地址传给read：123int n;char buf;while( (n=read(fd, &amp;buf, 1))&gt;0 ) 用单字符缓冲区读取100个字符需要100次系统调用，这个代价高昂。在这种情况下，诸如fgetc之类的库函数是比较好的选择。 6. write： 写文件1ssize_t write(int fildes, const void *buf, size_t nbyte) ; write把缓冲区的内容写入到fildes说明的文件中。write返回所写字符个数。如果write运行期间磁盘已满或文件大小超出系统限制，则write返回-1。1234#define BUFSIZE 8192int n;char buf[BUFSIZE];n = write(fd, buf, BUFSIZE); 和read一样，write可以一次写一个字符：12char buf;write(fd, &amp;buf, 1); 一个利用系统调用复制文件的程序： 12345//quit.h#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void quit(char *, int); 1234567//quit.c#include "quit.h"void quit(char *message, int exit_status)&#123; perror(message); exit(exit_status);&#125; 123456789101112131415161718192021222324//ccp.c#include&lt;fcntl.h&gt;#include&lt;sys/stat.h&gt;#include "quit.h"#define BUFSIZE 1024int main(int argc,char **argv)&#123; int fd1,fd2; int n; char buf[BUFSIZE]; if((fd1=open(argv[1],O_RDONLY))==-1) quit("open",1); if((fd2=open("passwd.bak",O_WRONLY|O_CREAT|O_TRUNC, 0664))==-1) quit("open2",2); while( (n=read(fd1,buf,BUFSIZE))&gt;0)&#123; if(n!=write(fd2,buf,n)) quit("write",3); &#125; close(fd1); close(fd2); exit(0);&#125; 编译、运行：12345678#编译quit.c 生成quit.o目标文件$ gcc -c quit.c#用ccp.c和quit.o编译出a.out(默认的可执行文件名，可用-o指定别的名)$ gcc ccp.c quit.o#执行程序，复制passwd的内容到当前目录下的passwd.bak文件中$ ./a.out /etc/passwd write不一定写入磁盘，如果把ccp.c中的第二个open和close删除，把fd2改为1 ( 或改为STDOUT_FILENO，需要包含头文件unistd.h )，就可以写到标准输出了。123456789101112131415161718192021222324#include&lt;fcntl.h&gt;#include&lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include "quit.h"#define BUFSIZE 1024int main(int argc,char **argv)&#123; int fd1,fd2; int n; char buf[BUFSIZE]; if((fd1=open(argv[1],O_RDONLY))==-1) quit("open",1);// if((fd2=open("passwd.bak",O_WRONLY|O_CREAT|O_TRUNC, 0664))==-1)// quit("open2",2); while( (n=read(fd1,buf,BUFSIZE))&gt;0)&#123; if(n!=write(STDOUT_FILENO,buf,n)) quit("write",3); &#125; close(fd1);// close(fd2); exit(0);&#125; 注：读写标准流时，应当使用符号常量STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO作为文件说明符，而不是他们所表示的整数0、1、2。这些符号常量在unistd.h中定义。 缓冲IO和无缓冲IO带不带缓存是相对层来说的。如果你要写入数据到文件上时（就是写入磁盘上），内核先将数据写入到内核中所设的缓冲储存器。假如这个缓冲储存器的长度是100个字节，你调用系统函：1ssize_t write (int fd,const void * buf,size_t count); 写操作时，设每次写入长度count=10个字节，那么你几要调用10次这个函数才能把这个缓冲区写满，此时数据还是在缓冲区，并没有写入到磁盘。缓冲区满时才进行实际上的IO操作，把数据写入到磁盘上，所以上面说的“不带缓存””不是没有缓存而是没有直写进磁盘。 那么，既然不带缓存的操作实际在内核是有缓存器的，那带缓存的IO操作又是怎么回事呢？ 带缓存IO也叫标准IO，符合ANSI C 的标准IO处理，不依赖系统内核，所以移植性强，我们使用标准IO操作很多时候是为了减少对read()和write()的系统调用次数，带缓存IO其实就是在用户层再建立一个缓存区，这个缓存区的分配和优化长度等细节都是标准IO库代你处理好了，不用去操心.还是用上面那个例子说明这个操作过程：内核缓存（注意这个不是用户层缓存区）区长度是100字节，我们调用不带缓存的IO函数write()就要调用10次，这样系统效率低，现在我们在用户层建立另一个缓存区（用户层缓存区或者叫流缓存），假设流缓存的长度是50字节，我们用标准C库函数的fwrite()将数据写入到这个流缓存区里面，流缓存区满50字节后在进入内核缓存区，此时再调用系统函数write()将数据写入到文件（实质是磁盘）上，标准IO操作fwrite()最后还是要掉用无缓存IO操作write,这里进行了两次调用fwrite()写100字节也就是进行两次系统调用write()。 lseek: 定位偏移指针truncate和ftruncate：截短文件umask： 在创建期间修改文件权限目录导航–getcwd读取目录123456//打开目录DIR *opendir(const char *dirname);//读打开的目录，这个结构体至少有目录的inode和dirName两个成员struct dirent *readdir(DIR *dirp);//关闭打开的目录int closedir(DIR *dirp) 修改目录中的项目 mkdir和rmdir——这些调用的意义与同名命令相同 link和symlink——link创建一个硬链接，symlink创建一个符号链接 unlink——和rm差不多，删除一个普通文件或符号链接，它不会删除目录 rename——和mv一样 读取Inode：struct stat 和 stat123456789101112131415161718struct stat&#123; ino_t st_ino ; //Inode 编号 mode_t st_mode; //模式(类型和权限) nlink_t st_nlink; //硬链接数 uid_t st_uid; //UID(所有者) gid_t st_gid; //GID(用户组所有者) dev_t st_rdev; //设备ID(用于设备文件) off_t st_size; //文件大小(字节) time_t st_atime; //最后访问时间 time_t st_mtime; //最后修改时间 time_t st_ctime; //inode 最后修改时间 blksize_t st_blksize ; //IO的优选块大小 blkcnt_t st_blocks; //分配的块数&#125;; stat系统调用：1234int stat(const char *path, struct stat *buf);int lstat(const char *path, struct stat *buf);int fstat(int fildes, struct stat *buf); stat和lstat的第一参数需要路径名，第二参数是一个stat结构的地址（把第一参数下的文件信息以stat结构存放在第二参数中）。stat和lstat的区别是，对于符号链接，stat会沿着符号链接前进：如果，文件foo是链接到bar的(foo-&gt;bar)，那么对foo进行stat操作，stat会用bar的属性填充stat结构, 而 lstat会提取foo的属性。其他方面，stat和lstat没有区别。lstat更常用。fstat的第一参数是文件说明符，第二参数同样是stat结构地址。 access：检查实际用户的权限1int access(const char *path, int amode); 第一参数是 路径名, 第二参数指定了 要测试的访问权限 。amode可以取以下4个值：R_OK ——读取权限正常W_OK ——写权限OKX_OK ——执行权限OKF_OK ——文件存在 修改文件属性chmod和fchmod：改变文件权限chown：改变所有权utime：改变时间戳]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim tutor]]></title>
    <url>%2F2018%2F01%2F22%2Fvim-tutor%2F</url>
    <content type="text"><![CDATA[vim tutor今天man vim 把vim使用手册祥读了一番，有一些新的发现。1man vimtutor 发现一个tutor文件 用vim打开这个文件 这个tutor概括了一些vim使用方法，概括的简洁明了，很好。 tutor 之外“ . “是一个重复命令。“ . “用于重复输入模式或命令模式中的命令。例如：4dd删除4行，然后按” . “会继续删除4行；/(查找) , n(查找下一个) , .(重复上一个编辑命令)这三个命令构成了奇妙的三重唱，如：/int(查找int)，用cw替换int输入double，然后按n(查找下一个),再按. ，下一个int直接变成double，不用再用键盘输入double了。 ps.vim里有3个操作符(operator)： c(change)，d(delete)，y(yank,copy)操作符常与其他命令(motion)组合使用，常用的motions：$(行末)G(文件末) – d30G删除光标到第30行的内容w(操作一个词)e(end of word,和w差不多)/(操作到第一次匹配到的内容那一行（不包括）) – ?反向 一个操作符自身重复时（cc，dd，yy），仅对当前行起作用。可prepend数字，以操作多行。 :e FILENAME – （需要保存当前文件，）自动退出文件，打开名为FILENAME的文件 ：r FILENAME – retrieving and mering，可以配合!(ex模式下的exclamation point)，如： “:r !ls -al” 配置vimrc：1vim ~/.vimrc 添加以下内容：1234567891011121314151617181920#显示行号set nu#自动语法高亮syntax on# 缩进set autoindentset smartindent#匹配高亮set hlsearch# 默认缩进4个空格set shiftwidth=4#使用tab时 tab空格数set softtabstop=4#tab 代表4个空格set tabstop=4#使用空格替换tabset expandtab# 根据 /usr/share/vim/vim74/colors，更改配色方案，例如：color murphy]]></content>
      <categories>
        <category>编程工具</category>
      </categories>
      <tags>
        <tag>编程工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017-成长]]></title>
    <url>%2F2017%2F12%2F31%2F2017-%E6%88%90%E9%95%BF%2F</url>
    <content type="text"><![CDATA[以中有足乐者, 不知口体之奉不若人也, 盖余之勤切艰若此. –宋濂 刚刚我看了 17 年的计划. 不忘初心, 坚持可贵.最终还是两者都放弃了, 不放弃不一定能有好结果, 但放弃的确 使我很狼狈. 2017 年最终还是走错了一大步. 2017年快要过完了, 90后全部都成年了. 属于90后的青少年的时代已经过去了.不得不承认时间过得太快. 我 18岁 的时候是2013年, 当时上高二. 当时的生活无忧无虑, 喜欢足球, 地下城与勇士, 没有别的想法. 今年大四, 22岁, 2018 年 7 月份就要毕业了.人生已经到了这个尴尬的年纪, 胸怀理想, 一无所有. 2017年我做了哪些事：1, 写了2017年robocup的TDP, 虽然是生搬硬套的, 虽然很蹩脚, 但是通过了TC的认证, 还是挺开心的. 2, 准备了6个多月考研, 在8月23号决定放弃了. 这件错误的决定, 从开始就是错误的. 在我准备考研的这段时间, 大鹏拿了物联网大赛的一等奖, 邓勇拿了Robocup 2D技术挑战赛的冠军. 现在大鹏和肖忘生在上海工作, 邓勇在北京. 只有我还在学校. 3, 谈了一场不靠谱的恋爱. 4, 在上海找了一个多月的工作. 那些笔试题我应该可以过的. 5, 毕业设计的题目选了 RoboCup 3D 方向. 6, 把《c++ primer》(5), 《effective c++》看了一遍, 用 Python 写了两个爬虫. 一些没有实现的目标：一天一篇博客, 太难实现了. 一个星期一篇或许比较合理.每天两个小时的英语… 找工作失败总结：1, 不知道自己能做什么2, 会的东西太少, 而且不精通3, 不知道 c++ 能做什么4, 基础太菜–只是略懂 c++ , 代码量太少5, 归根结底, 实践少, 理论差. 首先, 现在我在人生的低谷中, 我必须相信一件事, 现在对我个人没有什么可怕的, 所有的不好的结果我都接受了. 不论生活是多么的糟糕, 还是要为 2018 做一个计划.1, Java2, MySQL3, 掌握网络编程4, 每周至少一篇博客, 每天至少1小时英语5, 找一份工作, 赚点钱, 还mi pro借的钱 勿以往之不谏, 知来者之可追. 既然不喜欢, 那就努力改变.多一点客观, 少点主观.人生短暂, 认准目标, 坚定的走下去就好了.三年, 一个梦想, 别的都不想.]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[No such file or directory]]></title>
    <url>%2F2017%2F12%2F17%2FNo-such-file-or-directory%2F</url>
    <content type="text"><![CDATA[我已经下载了jdk8(Java SE Development Kit 8u151)，并配置好了环境变量，可是运行java时却提示，找不到文件。文件确实是存在的，而且不是无效的符号链接文件。用file命令查看文件是可执行的。这报了一个不该报的错误啊？网上解决方法： 说我的Ubuntu运行环境是64位，没有所需要的32位运行环境。没错，是我下载错了，我下载的是x86（32位的jdk），而不是x64。如果我想在64位Ubuntu上安装32位jdk必须要有32位的环境。 但是这样并不能很好的解决问题，在64位Linux系统上安装32位的软件确实是不妥当的。可以看出问题换了一种方式存在。 还是下载x64解压，配置环境变量靠谱。 还有一种更简单的 源安装 的方式：12345sudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install oracle-java8-installer]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题8:二叉树的下一个结点]]></title>
    <url>%2F2017%2F12%2F12%2F%E9%9D%A2%E8%AF%95%E9%A2%988-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目:给定一颗二叉树和其中一个结点，找出中序遍历序列的下一个结点。二叉树的存储结构为三叉链表，即每个结点除了有指向左右孩子的指针还有指向父结点的指针。 12345struct BinaryTreeNode&#123; char m_cValue; BinaryTreeNode* m_pLeft, * m_pLeft; BinaryTreeNode* m_pParent;&#125;; 分析：如下简图，二叉树的中序遍历序列为{d, b, h, e, i, a, f, c, g} 。 如果一个结点有右子树，那么这个结点的下一个结点为其右子树的最左子节点。 如果一个结点没有右子树，且这个结点是父节点的左孩子结点，那么这个结点的下一个结点是其父结点。 如果一个结点没有右子树，且这个结点是父节点的右孩子结点。从当前结点出发，找它的父结点，一直找到它的祖宗结点B是祖宗结点A的左孩子，那么祖宗结点A便是下一个结点。（如果有下一个结点的话）假如找 i 的下一个结点，如下图。我们可以直接看出 i 的下一个结点是 a ，那么这么找呢？设两个指针即可解决问题。只要pCurrent是pParent的左孩子结点，那么pParent就是下一个结点。如果一直到pParent为空了，还没找到，说明此结点是最后一个结点，不存在下一个结点。 代码：1234567891011121314151617181920212223BinaryTreeNode* getNext(BinaryTreeNode* pNode)&#123; if(pNode==nullptr) return nullptr; BinaryTreeNode* pNext=nullptr; if(pNode-&gt;m_pRight!=nullptr)&#123; pNext=pNode-&gt;m_pRight; while(pNext-&gt;m_pLeft!=nullptr) pNext=pNext-&gt;m_pLeft; return pNext; &#125; else if(pNode-&gt;m_pParent!=nullptr)&#123; BinaryTreeNode* pCurrent=pNode; BinaryTreeNode* pParent=pCurrent-&gt;m_pParent; //这个循环条件，退出循环时，要么pParent为空，要么pCurrent是pParent的左孩子 while(pParent!=nullptr &amp;&amp; pParent-&gt;m_pLeft!=pCurrent)&#123; pCurrent=pParent; pParent=pParent-&gt;m_pParent; &#125; pNext=pParent; &#125; return pNext;&#125; 下面复习一下非递归中序遍历（二叉链表存储结构）。再用此图..思想:算法从根结点开始： 如果结点不空，循环将结点的左孩子入栈，一直到最左孩子的”左空结点”入栈为止；如果结点空，空结点入栈； “空结点”出栈； 如果栈不空，就出栈一个栈顶结点(出栈的结点就是遍历的结点)，同时入栈该结点的右孩子； 从1开始 代码:1234567891011121314151617181920212223void InOrderTraverse(BinaryTreeNode* T, bool (*visit)(BinaryTreeNode* e))&#123; std::stack&lt;BinaryTreeNode* &gt; sc; BinaryTreeNode* p = T; sc.push(p); //p先入栈--根先入栈 while(!sc.empty())&#123; while(p!=nullptr)&#123; sc.push(p-&gt;m_pLeft); p=sc.getTop(); &#125; sc.pop(); //空结点出栈 if(!sc.empty())&#123; p=sc.getTop(); visit(p); //遍历结点 sc.pop(); sc.push(p-&gt;m_pRight); &#125; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题7:重建二叉树]]></title>
    <url>%2F2017%2F12%2F11%2F%E9%9D%A2%E8%AF%95%E9%A2%987-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目：输入二叉树的前序遍历和中序遍历的结果，重新构建该二叉树。输入的先序遍历和中序遍历的结果都不含有重复的数字。例如：先序遍历 {1, 2, 4, 7, 3, 5, 6, 8 }中序遍历 {4, 7, 2, 1, 5, 3, 8, 6 }重建后如下图：二叉树的结点定义：12345struct BinaryTreeNode&#123; int m_nValue; BinaryTreeNode* m_pLeft; BinaryTreeNode* m_pRight;&#125;; 构建思路：淡绿色的结点表示root结点。两个序列都有三个指针。绿色的指针只要有序列首地址和序列的长度得到。中序遍历 中的黄色rootInorder是从startInorder顺序遍历得到的根节点。由rootInorder-startInorder可以得到左子树的长度，由startPreorder和左子树长度可以得到leftPreorderEnd，leftPreorderEnd就是先序遍历左子树的最后一个结点，在先序遍历序列中有分割左右子树的效果。 下图是完成第一个结点的构建（根结点，蓝色），开始构建左子树（如果有左子树，这里是浅绿色2），用递归实现。本示例的根结点左孩子，只有左子树没有右子树。递归完成构建左子树，再递归构建右子树（如果有右子树，这里是浅绿色3）。 123456BinaryTreeNode* contruct(int* preorder, int* inorder, int length)&#123; if(preorder==nullptr || inorder==nullptr || length&lt;=0) return nullptr; return contructCore(preorder, preorder+length-1, inorder, inorder+length-1);&#125; 123456789101112131415161718192021222324252627282930313233343536373839BinaryTreeNode* contructCore(int* startPreorder, int* endPreorder, int* startInorder, int* endInorder)&#123; //构建根结点 int rootValue=startPreorder[0]; //startPreorder[0]是首地址元素 BinaryTreeNode* root = new BinaryTreeNode(); root-&gt;m_nValue=rootValue; root-&gt;m_pLeft=root-&gt;m_pRight=nullptr; //如果这是最后一个结点 if(startPreorder==endPreorder) &#123; //先序和中序序列都要检查，而且还要判断这个唯一的结点的值是否相等 if(startInorder==endInorder &amp;&amp; *startPreorder==*startInorder) return root; else throw std::exception("Invalid input"); &#125; //在中序遍历序列中找rootInorder int* rootInorder=startInorder; while(rootInorder&lt;endInorder &amp;&amp; *rootInorder!=rootValue) //书上是&lt;= ++rootInorder; if(rootInorder==endInorder &amp;&amp; *rootInorder!=rootValue) throw std::exception("Invalid input"); //在先序遍历序列中找leftPreorderEnd int leftLength = rootInorder - startInorder; int* leftPreorderEnd = startPreorder + leftLength; //如果有左子树，就递归构建左子树 if(leftLength&gt;0) root-&gt;m_pLeft=contructCore(startPreorder+1,leftPreorderEnd, startInorder,rootInorder-1); //如果有右子树, 左子树长度 一定小于 子树个数 if(leftLength&lt;endPreorder-startPreorder) root-&gt;m_pRight=contructCore(leftPreorderEnd+1,endPreorder, rootInorder+1,endInorder); return root;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题6:从尾到头打印单链表]]></title>
    <url>%2F2017%2F12%2F10%2F%E9%9D%A2%E8%AF%95%E9%A2%986-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E5%8D%95%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目:输入一个单链表的第一个结点(非头结点)，从尾到头打印单链表的每个结点。单链表的结点结构：1234struct ListNode&#123; int m_nValue; //n表示整型 ListNode * m_pNext; //p表示指针&#125;; 分析:改变顺序，第一个应该想到栈。其次，如果可以改变链表，把链表的指针反向也行。 12345678910111213void printListRevers(ListNode* pHead)&#123; std::stack&lt;ListNode* &gt; stack_node; ListNode* pNode=pHead; while(pNode!=nullptr)&#123; stack_node.push(pNode); pNode=pnode-&gt;m_pNext; &#125; while(!stack_node.empty())&#123; pNode=stack_node.top(); std::cout&lt;&lt;pNode-&gt;m_nValue&lt;&lt;std::endl; stack_node.pop(); &#125;&#125; 递归本质上是一个栈结构，这题也可以用递归实现。 1234567891011121314void printListRevers_Recursive(ListNode* pHead)&#123; //ListNode* pNode=pHead-&gt;m_pNext; //if(pNode)&#123; // printListRevers_Recursive(pNode); // std::cout&lt;&lt;pNode-&gt;m_nValue&lt;&lt;std::endl; //&#125; //以上代码没有考虑递归结束条件pHead==nullptr if(pHead)&#123; if(pHead-&gt;m_pNext)&#123; printListRevers_Recursive(pHead-&gt;m_m_pNext); &#125; std::cout&lt;&lt;pHead-&gt;m_nValue&lt;&lt;std::endl; &#125;&#125; 方法对比:虽然递归看起来简洁，但是如果链表非常长，就会导致函数调用的层数很深，可能导致调用函数栈溢出。显然，用栈循环的代码的鲁棒性更好。]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[awk]]></title>
    <url>%2F2017%2F12%2F09%2Fawk%2F</url>
    <content type="text"><![CDATA[awk入门awk进阶： 在终端tap ‘man awk’]]></content>
      <categories>
        <category>shell</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面试题5:替换空格]]></title>
    <url>%2F2017%2F12%2F09%2F%E9%9D%A2%E8%AF%95%E9%A2%985-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[c风格字符串都是以’\0’结尾的。 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int main()&#123; char str1[]="hello world"; char str2[]="hello world"; char * str3="hello world"; char * str4="hello world"; cout&lt;&lt;sizeof(str1)&lt;&lt;endl&lt;&lt;sizeof(str3)&lt;&lt;endl; if(str1==str2) cout&lt;&lt;"str1 == str2"&lt;&lt;endl; else cout&lt;&lt;"str1 != str2"&lt;&lt;endl; if(str3==str4) cout&lt;&lt;"str3 == str4"&lt;&lt;endl; else cout&lt;&lt;"str3 != str4"&lt;&lt;endl; return 0;&#125; 结果：结果分析： c风格字符串的结尾有一个’\0’，所以str1占12个字节，而不是11个。 str3是指针，所以占8个字节（我是64位Ubuntu）。 str1和str2数组的首地址不相同，所以 str1 != str2 。 str3和str4地址相同，指向同一个字符串常量，所以 str3 == str4 。第4点需要纠正一下：看str3和str4的值，str3和str4不是地址！而是字符串！我们的char型指针怎么变成了字符串？而且和c++中的string一样，还可以当成数组处理。str3和str4里存放的是指针指向的内容–字符串，不是字符串的地址。 实际上，数组和指针的存储机制不同。 数组，分配内存，把字符串复制进去 指针，不分配内存，把字符串常量的递增复制为指针值。 题目：实现一个函数，把字符串中的每个空格替换成”%20”。例如，输入“we are happy.”，则输出“we%20are%20happy.” 分析：这题的思想很简单，一般都能想到。先检查有多少个空格，转换后的字符串会变长（空格本来占一个字节，转换后变成3个字节）。算出转换后的长度，从后往前，把转换前的字符复制到转换后的空间中。把这题写在日志里的原因是，平时在c++中用字符串都是string对象，这里用的是数组。 代码实现：1234567891011121314151617181920212223242526272829void replaceBlank(char string[], int length)&#123; if(string==nullptr || length&lt;=0) return; int originLength=0; //字符串原始长度 int numberOfBlank=0; int i=0; while(string[i]!='\0')&#123; ++originLength; if(string[i]==' ') ++numberOfBlank; ++i; &#125; int newLength = originLength + numberOfBlank*2; int indexOfOrigin=originLength; int indexOfNew=newLength; while(indexOfOrigin&gt;indexOfNew &amp;&amp; indexOfOrigin&gt;=0)&#123; if(string[indexOfOrigin]==' ')&#123; string[indexOfNew--]='0'; string[indexOfNew--]='2'; string[indexOfNew--]='%'; &#125; else string[indexOfNew--]=string[indexOfOrigin]; &#125; --indexOfOrigin;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈和队列]]></title>
    <url>%2F2017%2F12%2F07%2F%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[栈和队列是操作受限的线性表。 栈栈的定义及基本操作栈(stack) 是限定仅在表尾进行插入和删除的线性表。对栈来说，表尾称为栈顶(top)，表头称为栈底(bottom)。栈的操作是按后进先出的原则进行的。因此，栈又称为后进先出(last in first out)的线性表。（简称LIFO结构） 插入元素操作称为入栈, 删除栈顶元素称为出栈 12345678910111213141516//构造一个空栈SinitStack(&amp;S)//销毁栈SdestoryStack(&amp;S)//将S清为空栈clearStack(&amp;S)stackEmpty(S)stackLength(S)getTop(S,&amp;e)push(&amp;S,e)pop(&amp;S,&amp;e)//从栈底到栈顶依次对S的每个数据元素调用visit()函数stackTraverse(S,visit()) 栈的表示和实现和线性表类似，栈也有两种存储方式：顺序栈和链栈。 顺序栈顺序栈，用 一组地址连续的存储单元 依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。top=0表示空栈。1234567//栈的顺序存储表示#define STACK_INIT_SIZE 100#define STACK_INCREMENT 10typedef struct&#123; elemType * base, * top; int stackSize;&#125;SqStack; 12345678910111213141516bool initStack(SqStack &amp;S)&#123; elemType S.base=(elemType * )malloc(STACK_INIT_SIZE * sizeof(elemType)); //存储空间分配失败 if(!S.base) exit(OVERFLOW); S.top=S.base; S.stackSize=STACK_INIT_SIZE; return true;&#125;//取栈顶元素int getTop(SqStack S, elemType &amp;e)&#123; //栈是否为空 if(S.top==S.base) return false; e=* (--S.top); return true;&#125; 1234567891011121314151617181920212223/*和顺序表, 链表类似*///入栈出栈，和链栈不同，顺序栈分配到的存储空间是连续的，//顺序栈都是批量分配内存，初始化100，增量10//删除也不会(不能)删除一个元素空间//而链栈的每个结点都要独立分配和回收bool push(SqStack &amp;S, elemType e)&#123; //栈满,top和base指针的差是 栈的元素个数 if(S.top-S.base&gt;=S.stackSize)&#123; S.base=(elemType * )ralloc(S.base,(S.stackSize+STACK_INCREMENT)* sizeof(elemType)); if(!S.base) exit(OVERFLOW); S.top=S.base+S.stackSize; //top可能变了 S.stackSize+=STACK_INCREMENT; &#125; * S.top++=e; //* S.top=e; S.top++; return true;&#125;bool pop(SqStack &amp;S, elemType &amp;e)&#123; //栈空 if(S.top==S.base) return false; e=* --S.top; return true;&#125; 123456bool destoryStack(SqStack &amp;S)&#123; S.top=S.base; free(S.base); S.stackSize=0; return true;&#125; 链栈链栈操作是单链表的操作的特例，可以参考单链表，这里不在详述。1234typedef struct SNode&#123; elemType data; struct SNode * next;&#125;Node, * stack; 栈的应用数制转换十进制数转换成d进制数，有一个通用的算法。例如转换成二进制：十进制转八进制代码：1234567891011121314//这里输出到标准输出void conversion(int N)&#123; SqStack S; initStack(S); while(N)&#123; push(S,N%8); N/=8; &#125; int e; while(!stackEmpty(S))&#123; pop(S,e); cout&lt;&lt;e; &#125;&#125; 括号匹配的检验如果是( [ {就入栈，遇到右括号就出栈相匹配的左括号，如果不匹配退出程序返回false；如果都匹配最后栈为空，返回true。 行编辑程序用’#’表示退格符，表示前一个字符无效；用’@’表示退行符，表示当前行无效。例如：whli##ilr#e(s# * s)outcha@putchar(* s=# ++)实际效果如下：while( s)putchar( s++)1234567891011121314151617181920212223void lineEdit()&#123; SqStack S; initStack(S); char ch,cPop; ch=getchar(); while(ch!=EOF)&#123; //EOF为文件结束符，Linux里是Ctrl+D while(ch!=EOF &amp;&amp; ch!='\n')&#123; switch(ch)&#123; case '#': pop(S,cPop);break; case '@': clearStack(S);break; default: push(S,ch);break; &#125; ch=getchar(); &#125; /******* 对栈中的元素进行处理 *******/ clearStack(S); if(ch!=EOF) ch=getchar(); &#125; destoryStack(S);&#125; 栈的其他应用迷宫求解表达式求值出栈顺序和卡特兰数 队列队列(queue) 是一种先进先出(First In First Out)的线性表。队头(front)只允许出队操作；队尾(rear)只允许入队操作。 链队列用链表表示队列123456789//单链队列typedef struct QNode&#123; elemType data; struct QNode * next;&#125;QNode, * QueuePtr;typedef struct &#123; QueuePtr front,rear;&#125;LinkQueue; 1234567891011121314151617bool initQueue(LinkQueue &amp;Q)&#123; QueuePtr front,rear; front=rear=(QueuePtr)malloc(sizeof(QNode)); if(!front) return false; Q.front-&gt;next=nullptr; return true;&#125;bool destoryQueue(LinkQueue &amp;Q)&#123; //从头结点开始，然后队头到队尾逐一删除 while(Q.front)&#123; Q.rear=Q.front-&gt;next; free(Q.front); Q.front=Q.rear; &#125; return true;&#125; 123456789101112131415161718192021222324bool enQueue(LinkQueue &amp;Q, elemType e)&#123; QueuePtr p; p=(QueuePtr)malloc(sizeof(QNode)); if(!p) exit(OVERFLOW); p-&gt;data=e; p-&gt;next=nullptr; Q.rear-&gt;next=p; Q.rear=p //不要忘了 return true;&#125;bool deQueue(LinkQueue &amp;Q, elemType &amp;e)&#123; //if(!Q.front-&gt;next) return false; /*应该这样判断*/ if(Q.front==Q.rear) return false; QueuePtr p=Q.front-&gt;next; e=p-&gt;data; Q.front-&gt;next=p-&gt;next; //free(p); 要先判断出队的元素是否是队尾元素 //如果是队尾元素，需要重新设置队尾指针 if(p==Q.rear) Q.rear=Q.front; free(p); return true;&#125; 循环队列循环队列便是队列的顺序存储方式。这种方式必须是循环的。如果不循环，前面队头出队的空间就无法再利用了，队列的空间很快会被“用完”，实际上队列可能很空。下图是未满的循环队列：下图是满的顺序队列 队列满的条件为 (Q.rear+1)%MAXSIZE==Q.front注： 这里少用一个元素的空间，用队头指针在队尾指针的下一个位置表示队列满。 1234567//-------循环队列 --队列的顺序存储结构----#define MAXSIZE 100typedef struct &#123;elemType * base; //初始化的冬天存储空间int front; //头指针，队列不空，指向队列头元素int rear; //尾指针，队列不空，指向队列尾元素的下一个位置&#125;SqQueue; 12345678910111213141516171819202122232425262728293031323334bool initQueue(SqQueue &amp;Q)&#123;//Q.base=(elemType * )malloc(MAXSIZE * sizeof(SqQueue)); Q.base=(elemType * )malloc(MAXSIZE * sizeof(elemType)); if(Q.base) exit(OVERFLOW); Q.front=Q.rear=0; return true;&#125;int queueLength(const SqQueue * Q)&#123; //return abs(Q.rear-Q.front); 这样可以的 return (Q.rear-Q.front+MAXSIZE)%MAXSIZE;&#125;bool enQueue(SqQueue &amp;Q,elemType e)&#123; if((Q.rear+1)%MAXSIZE==Q.front) //队满 return false; //Q.base[Q.rear++]=e; Q.base[Q.rear]=e; Q.rear=(Q.rear+1)%MAXSIZE; //注意循环！ return true;&#125;bool deQueue(SqQueue &amp;Q,elemType &amp;e)&#123; if(Q.front==Q.rear) //队空 return false; e=Q.base[Q.front];//Q.front=(Q.front-1)%MAXSIZE; Q.front=(Q.front+1)%MAXSIZE; //不会减一的！见最后一张图 return true;&#125; 对deQueue代码的理解 双端队列双端队列(deque)只允许在线性表的两端进行插入和删除，双端队列看似比栈和队列灵活，但实际运用远不及栈和队列。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面试题3：数组中重复的数字]]></title>
    <url>%2F2017%2F12%2F06%2F%E9%9D%A2%E8%AF%95%E9%A2%983%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目1: 找出数组中重复的数字在一个长度为n的数组中，数组中的数字都在0～n-1之间。数组中可能有重复的数字，也可能没有，如果有的话，找出数组中任意一个数字。 例如：{2,1,3,0,5,2,3}，找出2或3即可。 我的想法：先用快排排序，然后找重，这样可以找出所有的重复的数字。时间复杂度为O(nlogn)。 书上给出一个巧妙的解法，他的思想是：数组中的数字的范围是在数组的长度之内的。那么我们可以调整数组，把数组的元素值和位置对应起来。如果值和位置一一对应，则无重复元素；如果位置有多个值，则这个位置就是一个重复的数。 例如：{2,1,3,0,5,2,3}，假设数组a[7]a[0]==2, a[2]!=2, 可交换，把a[0]换到a[2]上：{3,1,2,0,5,2,3}a[0]==3, a[3]!=3, 可交换，把a[0]换到a[3]上： {0,1,2,3,5,2,3}a[0]==0, ok: {0,1,2,3,5,2,3}a[1]==1, ok: {0,1,2,3,5,2,3}a[2]==2, ok:a[3]==3, ok:a[4]==5, a[5]!=5, 可交换，把a[4]和a[5]交换：{0,1,2,3,2,5,3}a[4]==2, a[2]==2, 不可交换，2重复了 代码实现：12345678910111213141516171819202122232425bool findOneDuplication(int numbers[], int length, int* duplication)&#123; //数组为空，或数组长度不合法 if(numbers==nullptr || length&lt;=0) return false; //检查数组的元素是否合要求 for(int i=0; i&lt;length; ++i)&#123; if(numbers[i]&lt;0 || numbers[i]&gt;=length) return false; &#125; // for(int i=0; i&lt;length; ++i)&#123; //当此位置和值不相等，判断是否可交换。 //不可交换，即找到重复元素。可交换，执行交换操作。 while(numbers[i]!=i)&#123; if(numbers[i]==numbers[numbers[i]])&#123; * duplication=numbers[i]; return true; &#125; int temp=numbers[i]; numbers[i]=numbers[temp]; numbers[temp]=temp; &#125; &#125;return false; //刚好位置和值一一对应，没有找到重复的&#125; 此算法的时间复杂度为O(n);虽然有一个二重循环，但是这个二重循环的内层循环是交换操作，如果不需要交换，那么内层循环不执行；如果交换，那么后来需要执行的内层循环就少一次。总的时间复杂度为O(n)。 题目2：找出数组中重复的数字(不修改数组)注：与题目1不同，此题必有重复元素！在一个长度为n+1的整型数组中，数组元素值都在1～n之间。所以至少有一个数字是重复的，找出数组中任意一个重复的数字。 例如：{1, 2, 2, 3, 4, 5, 6, 7} 设为数组a[8]，算法实现找出2 这题当然也可以用快排排序，然后找出所有重复的数字。但是不能修改数组，这会使得不仅时间复杂度为O(nlogn)，还多出空间复杂度S(n)。 书上解法利用了必有一个重复的数字这一特点。例如：{5, 3, 1, 2, 2, 4, 7, 6 } 设为数组a[8]思路：这个长度为8的数组，所有数字都在数字区间1～7之间。中间的数字4把1~7分两段，一段1~4，一段5~7。接下来统计1~4这一段中出现数字的个数为5，说明有重复的。再把1~4分两段，1~2和3~4。1~2数字个数为3，说明有重复的。再把1~2分两段，1~1和2~2。1~1数字个数为1，无重复；2~2数字个数为2，2重复了。这种思想和 二分查找 有些类似。 代码实现：1234567891011121314151617181920212223int getOneDuplication(const int* numbers, int length)&#123; //如果数组不合法，返回-1 if(numbers==nullptr || length &lt;=0) return -1; //数字区间为start~end int start=1; int end=length-1; while(end&gt;=start)&#123; int middle=((end-start)&gt;&gt;1)+start; //有符号负数右移位要注意，这里是正数不用担心。 int count=countRange(numbers, length, start, middle); if(end==start)&#123; if(count&gt;1) return start; else break; &#125; if(count&gt;(middle-start+1)) end=middle; else start=middle+1; &#125; return -1;&#125; 1234567891011int countRange(int* numbers, int length, int start, int end)&#123; //这里可以不用判断数组为空，长度不合法 //if(numbers==nullptr || length&lt;0) // exit(1); int count=0; for(int i=0; i&lt;length; ++i)&#123; if(numbers[i]&gt;=start &amp;&amp; numbers[i]&lt;=end) count++; &#125; return count;&#125; 此算法能找到重复的，但是不能找到所有的重复的数字。时间复杂度为O(nlogn)。countRange被调用了O(logn)次，每次需要O(n)的时间。]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表]]></title>
    <url>%2F2017%2F12%2F05%2F%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[写在前面：数据结构（data structure）是相互之间存在一种或多种特定关系的数据元素的集合。元素之间的关系称为结构。4类基本结构： 集合，数据元素除了“同属一个集合”之外，别无其他关系。 线性结构，数据元素之间存在一个对一个的关系。 树形结构，一对多。 图状结构，多对多。 内容为看书总结《数据结构（严蔚敏）》。 线性表的类型定义线性表，栈和队列，串，均为线性结构。线性结构特点： 存在第一个数据元素 存在最后一个数据元素 除了第一个数据元素外，每个数据元素只有一个前驱 除了最后一个，每个数据元素只有一个后继 线性表的基本操作：1234567891011121314151617181920212223//构造一个空的线性表LInitList(&amp;L)//销毁线性表LDestroyList(&amp;L)//重置L为空表ClearList(&amp;L)ListEmpty(L)ListLength(L)//返回第一个与e满足compare的数据元素的位序，不存在返回0LocateElem(L,e,compare())//用e返回L中第i个数据元素的值GetElem(L,i,&amp;e)ListInsert(&amp;L,i,e)ListDelete(&amp;L,i,&amp;e)//依次对L的每个数据元素调用visit()，一旦visit()失败，则操作失败ListTraverse(L,visit()) 实现A=AUB：123456789void union(List &amp;La,List &amp;Lb)&#123; int La_len=ListLength(La); int Lb_len=ListLength(Lb); for(int i=1; i&lt;=Lb_len; ++i)&#123; GetElem(Lb,i,e); if(!LocateElem(La,e,equal)) ListInsert(La, ++La_len, e); &#125;&#125; 合并两个非递减的线性表La, Lb: 1234567891011121314151617181920212223242526272829void MergeList(List La, list Lb, List &amp;Lc)&#123; InitList(Lc); int i=j=1; int k=0; int La_len=ListLength(La), Lb_len=ListLength(Lb); while((i&lt;=La_len)&amp;&amp;(j&lt;=Lb_len))&#123; int ai, bj; GetElem(La, i, ai); GetElem(Lb, j, bj); if(ai&lt;=bj)&#123; ListInsert(Lc, ++k, ai); ++i; &#125; else&#123; ListInsert(Lc, ++k, bj); ++j; &#125; &#125; while (i&lt;=La_len) &#123; int ai; GetElem(La, i++, ai); ListInsert(Lc, ++k, ai); &#125; while (j&lt;=Lb_len) &#123; int bj; GetElem(Lb, j++, bj); ListInsert(Lc, ++k, bj); &#125;&#125; 线性表的顺序表示线性表的顺序表示：用一组地址连续的存储单元依次存储线性表的数据元素。假设线性表的每个元素占l个存储单元：LOC( ai+1 )=LOC( ai )+l LOC( ai )=LOC( a1 )+(i-1)* l 下面给出的存储结构是一个c语音中的结构体。在出c++中，这就是一个类，初始化函数就是类的构造函数。 12345678//线性表的的动态分配 顺序存储结构# define LIST_INIT_SIZE 100#define LISTINCREMENT 10 //存储空间分配增量typedef struct&#123; ELemType * elem; //存储空间基址 int length; int listSize;&#125;SqList; 12345678//构造一个空的线性表bool InitList_Sq(SqList &amp;l)&#123; L.elem=(ElemType * )malloc(LIST_INIT_SIZE * sizeof(ElemType));if(!L.elem) exit(OVERFLOW); //存储空间分配失败L.length=0;L.listSize=LIST_INIT_SIZE;return true;&#125; 1234567891011121314151617//在顺序线性表L的第i个位置之前插入新的元素ebool ListInsert_Sq(SqList &amp;L, int i, ELemType e)&#123; if(i&lt;1||i&gt;L.length+1) //插入位置i不合法 return false; if(L.length&gt;=L.listSize)&#123; //当前存储空间已满 ELemType * newBase=(ElemType * )realloc(L.elem, (L.listSize+LISTINCREMENT)* sizeof(ElemType)); if(!newBase) exit(OVERFLOW); L.elem=newBase; L.listSize += LISTINCREMENT; &#125; int * q=&amp;(L.elem[i-1]); for(int *p=&amp;(L.elem[L.length-1]); p&gt;=q; --p) * (p+1) = * p ; * q = e; ++L.length; //表长增1 return true;&#125; realloc(void * __ptr , size_t __size) ： 更改已经配置的内存空间，即更改由malloc()函数分配的内存空间的大小。如果是将分配的内存扩大，则有以下情况：1）如果当前内存段后面有需要的内存空间，则直接扩展这段内存空间，realloc()将返回原指针。2）如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据块释放掉，返回新的内存块位置。3）如果申请失败，将返回NULL，此时，原来的指针仍然有效。 123456789101112//在顺序线性表中删除第i个元素，并用e返回其值bool ListDelete_Sq(SqList &amp;L, int i, ElemType &amp;e)&#123; if((i&lt;1)||(i&gt;L.ListLength)) //删除位置i不合法 return false; int * p = &amp;(L.elem[i-1]); e = * p; q = L.elem+L.length-1; //表尾元素的位置 for(++p; p&lt;=q; ++p) * (p-1) = * p; --L.length; // return true;&#125; 线性表的链式表示线性表的顺序存储结构的特点是：逻辑上相邻的两个元素在物理位置上也相邻。优点是可以随机存取元素(按位序)；缺点是插入删除需要移动大量元素。链式存储结构的特点是用一组任意的存储单元存储数据元素(不要求连续)。 单链表单链表(线性链表):一个结点(node)包括一个数据域和一个指针域。下图为带头结点的单链表：L是LinkList型的变量，是单链表的头指针。若单链表为空表，则头结点的指针域为空（L-&gt;next==NULL），头结点的指针域存储指向第一个结点的指针。下图为带头结点的空表： 如果不带头结点，L==NULL表示空表。 12345//线性表的单链表存储结构typedef struct LNode&#123; ElemType data; struct LNode * next;&#125;LNode, * LinkList; 1234567891011121314//逆序输入n个元素值，建立带头结点的单链表Lvoid creatList_L(LinkList &amp;L, int n) &#123; L = (LinkList)malloc(sizeof(LNode)); L-&gt;next = NULL; int data; for (int i = 1; i &lt;= n; ++i) &#123; //生成新结点 LinkList p = (LinkList)malloc(sizeof(LNode)); cin &gt;&gt; data; p-&gt;data = data; p-&gt;next = L-&gt;next; L-&gt;next = p; &#125;&#125; 12345678910111213//从带头结点的单链表L中，取第i个元素bool getElem_L(LinkList &amp;L, int i, ElemType e)&#123; LinkList p=L-&gt;next; //p指向第一个结点 int j=1; //j为计数器 while(p &amp;&amp; j&lt;i)&#123; p=p-&gt;next; ++j; &#125; if(!p || j&gt;i) //第i个元素不存在 return false; e=p-&gt;data; return true;&#125; 下面是一个简单的插入元素操作，却是单链表的重点。一个是寻找第i-1个结点，一个是插入操作。1234567891011121314151617//在带头结点的单链表L中第i个位置之前插入元素ebool listInsert_L(LinkList &amp;L, int i, ElemType e)&#123; LinkList p=L; //p表示第i-1位置的结点 int j=0; //j表示第i之前的那个位置，j=i-1 while(p &amp;&amp; j&lt;i-1)&#123; p=p-&gt;next; ++j; &#125; if(!p || j&gt;i-1) //i&lt;1或i大于表长+1 return false; s=(LinkList)malloc(sizeof(LNode)); s-&gt;data=e; s-&gt;next=p-&gt;next; p-&gt;next=s; return true;&#125;//我们一般的想法是先检查插入位置是否合法,再找第i-1个位置//本算法很巧妙 删除依然巧妙，应该掌握这种方法。12345678910111213141516//删除带头结点单链表中的第i个元素bool listDelete_L(LinkList &amp;L, int i, ElemType &amp;e)&#123; LinkList p=L; int j=0; //寻找第i个结点，并令p指向其前驱 while(p-&gt;next &amp;&amp; j&lt;i-1)&#123; p=p-&gt;next; ++j; &#125; if(!(p-&gt;next) || (j&gt;i-1)) //删除位置不合理 return false; q=p-&gt;next; p-&gt;next=q-&gt;next; e=q-&gt;data; free(q); return true;&#125; 静态链表静态链表：用一维数组描述单链表（线性链表）。平时很少用。静态链表示例：插入删除主要改变cur。这里i=S[i].cur相当于p=p-&gt;next。123456//线性表的静态单链表 存储结构#define MAXSIZE 1000typedef struct&#123; ElemType data; int cur; //cursor游标&#125;component,SLinkList[MAXSIZE]; 123456//初始化一个静态链表void init_SL(SLinkList &amp;space)&#123; for(int i=0; i&lt;MAXSIZE; ++i) space[i].cur=i+1; space[MAXSIZE-1].cur=0;&#125; 12345678//在静态单链表L中查找第一个值为e的元素//找到返回它在L中的位序，否则返回0int locateElem_SL(SLinkList S, ELemType e)&#123; int i=S[0].cur; while(i &amp;&amp; S[i].data!=e) i=S[i].cur; return i;&#125; 循环链表循环链表(circular linked list)和单链表操作基本一致，只是最后一个结点的指针域指向头结点。差别只是循环条件不是p或p-&gt;next是否为空，而是它们是否等于头指针 双向链表双向链表(double linked list)：克服了单链表单项的缺点。双向链表有两个指针域，一个指向直接前驱，一个指向直接后继。123456//线性表的双向链表 存储结构typedef struct DuLNode&#123; ElemType data; struct DuLNode * prior; struct DuLNode * next;&#125;DuLNode, * DuLinkList 123456789101112131415161718192021222324//在带头结点的双链循环线性表L中，第i个位置前插入元素ebool listInsert_DuL(DuLinkList &amp;L, int i, ELemType e)&#123; if(!(DuLinkList p=getElemP_DuL(L,i))) //在p结点前插入 return false; if( !(DuLinkList s=(DuLinkList)malloc(sizeof(DuLNode) )) ) return false; s-&gt;data=e; s-&gt;prior=p-&gt;prior; p-&gt;prior-&gt;next=s; s-&gt;next=p; p-&gt;prior=s; return true;&#125;//由位置i 得到指向该位置之前(i-1)的结点指针DuLinkList getElem_DuL_before(DuLinkList &amp;L, int i)&#123; if(i&lt;1||i&gt;listLength+1) return NULL; DuLinkList p=L; int j=1; while(j&lt;i)&#123; p=p-&gt;next; ++j; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[上海求职总结]]></title>
    <url>%2F2017%2F12%2F04%2F%E4%B8%8A%E6%B5%B7%E6%B1%82%E8%81%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2017年10月18号，我和大鹏来到上海。大鹏找PHP，我找C++软件研发。两周后，大鹏上班了。今天已经12月4号了，过去了47天。不得不承认，自己实力太弱，这么长时间还是没有找到工作。现在要回合肥了，和我之前的计划完全不同。 是我高估了自己，我必须要接受这个结果！ 现在想想我过去的思考，其实并没有错.但是如果我一无所有还在纸上谈兵就大错特错了。 努力去改变现状，现状实在太糟了。最糟的是我自己无法反驳任何人，确实是我自己的问题。 漫无目的只会一天一天地消磨时间, 一步一步走向冢中枯骨. 要想要自由，想摆脱束缚.加油吧. MITRE.]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Practice makes perfect]]></title>
    <url>%2F2017%2F12%2F03%2FPractice-makes-perfect%2F</url>
    <content type="text"><![CDATA[Deliberate practice entails (needs) more than simply repeating a task.Rather,it involves setting specific goals,obtaining immediate feedback and concentrating as much on technique as on outcome.(将注意力集中在技术和结果上)]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>English</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[差距]]></title>
    <url>%2F2017%2F12%2F02%2F%E5%B7%AE%E8%B7%9D%2F</url>
    <content type="text"><![CDATA[①当你在想玩什么，有人在想学什么 –时间 ②当你在做计划，有人已出发 –执行 ③当你为上次的失败沮丧，有人已开始下次尝试 –心态 ④当你决定放弃，有人坚信前进就有希望。 –信念 那些比你走的远的人，并不一定比你聪慧，只是每天多走了一点。 坚持，是最强大的力量。]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux环境变量]]></title>
    <url>%2F2017%2F12%2F01%2Flinux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[1 什么是环境变量bash shell用一个叫做环境变量(environment variable)的特性来存储有关shell会话和工作环境的信息。 在bash shell中，环境变量有两种：全局变量，局部变量。 1.1 全局环境变量全局变量会作用于进程的所有 子shell。12345678910#查看全局变量 env 或 printenvenv#显示变量的值echo $HOME#使用ls $HOME# 定义全局变量用 exportexport hellow=1env | grep hello 1.2 局部环境变量局部变量只能在定义它们的进程中可见。1234567#没有命令可以直接查看局部变量#set 会显示所有环境变量(局部，全局)和用户定义变量set#定义局部变量直接赋值即可whello=2set | grep hello 1.3 小结可以在bash shell终端中直接设置自己的变量。12345678#设置一个局部环境变量my_variable="hello world"#把局部变量变成全局变量export my_variable#也可以直接 export my_variable2="don't panic"#删除my_variableunset my_variable 以上设置的环境变量都是临时的，一旦重启电脑，就会失效。设置永久环境变量需要在 登录shell 中设置。另参见 环境变量的持久化 注意：在子shell中修改全局变量的值，只在子shell中有效，在全局中，全局变量不会被改变。在子shell中删除全局变量，同样只对子shell有效。 2 系统环境变量2.1 PATH当在shell命令行输入一个外部命令时，shell必须搜索系统找到对应的程序。PATH环境变量定义了用于进行命令和程序查找的目录。可以修改PATH，加入新的程序的位置。 对PATH的修改只能持续到退出或重启系统 2.2 定位系统环境变量当你登入linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些文件叫做启动文件。bash 检查启动文件取决于你启动bash shell的方式。启动bash shell的3中方式： 登录时作为默认登录shell 非登录的交互式shell 运行脚本的非交互shell 2.2.1 登录shell 登录Linux系统时，bash shell作为登录shell启动。登录shell会在5个不同的启动文件中读取命令： /etc/profile $HOME/.bash_profile $HOME/.bashrc $HOME/.bash_login $HOME/.profile(红色为我的系统Ubuntu的启动文件) /etc/profile文件是系统默认的bash shell 主启动文件。系统的每个用户登录都会执行这个启动文件。另外四个是针对用户的，可根据个人需求定制。打开/etc/profile可以看到,它用到了/etc/profile.d目录下的所有文件。$HOME目录下的启动文件- $HOME/.bash_profile- $HOME/.bashrc- $HOME/.bash_login- $HOME/.profile 用户可以编辑这些文件，添加自己的环境变量。这些环境变量会在启动bash shell会话时生效。 2.2.2 交互式shell检查HOME目录下 .bashrc 。 2.2.3 非交互式shell系统执行的shell脚本就是这种shell。就是脚本—没有CLI提示符。脚本用到的变量都是从父shell继承来的。 2.3 环境变量持久化 把环境变量放在文件中，虽然可以放在 /etc/profile 中。但是这样不规范。 我们应该在 /etc/profile.d 中建立 .sh 文件，把自己设置的全局环境变量放在里面即可。( /etc/profile 会检查并读取 /etc/profile.d 下的所有文件) 例如，java环境变量的配置：123456789101112# /etc/profile.d/jdk.shexport J2SDKDIR=/usr/lib/jvm/java-8-oracleexport J2REDIR=/usr/lib/jvm/java-8-oracle/jreexport PATH=$PATH:/usr/lib/jvm/java-8-oracle/bin:/usr/lib/jvm/java-8-oracle/db/bin:/usr/lib/jvm/java-8-oracle/jre/binexport JAVA_HOME=/usr/lib/jvm/java-8-oracleexport DERBY_HOME=/usr/lib/jvm/java-8-oracle/db# /etc/profile.d/jdk.cshsetenv J2SDKDIR /usr/lib/jvm/java-8-oraclesetenv J2REDIR /usr/lib/jvm/java-8-oracle/jresetenv PATH $&#123;PATH&#125;:/usr/lib/jvm/java-8-oracle/bin:/usr/lib/jvm/java-8-oracle/db/bin:/usr/lib/jvm/java-8-oracle/jre/binsetenv JAVA_HOME /usr/lib/jvm/java-8-oraclesetenv DERBY_HOME /usr/lib/jvm/java-8-oracle/db 注：setenv 是 c shell 中的命令，作用和 bash 中的 export 一样。 3 数组变量12345#创建数组变量mytest=(one two three four)echo $&#123;mytest[2]&#125;#输出three]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解shell]]></title>
    <url>%2F2017%2F11%2F30%2F%E7%90%86%E8%A7%A3shell%2F</url>
    <content type="text"><![CDATA[1. shell 类型系统启用什么样的shell取决于你个人的配置。在/etc/passwd文件中，第七个字段列出了默认的shell程序。查看一下/bin/bash 可以发现bash是可执行程序(有个星号，参见ls -F)。 再看看系统默认的shell，这是一个symbolic link 文件，指向dash。所以，默认和user交互的shell是bash shell；默认系统shell是dash shell。 2. shell的父子关系在bash shell里打开一个dash shell （子shell）可以看第二次执行ps -f 时，多了一个子shell。 进程列表：(pwd;ls;cd /ctc)，在括号里写命令，分号分隔，就是进程列表。进程列表会在子shell中执行。 3. shell 内建命令內建命令和外部命令执行的时候有很大的不同。 外部命令又称文件系统命令。是存在与于bash shell 之外的程序。外部命令通常位于/bin, /usr/bin, /sbin, /usr/sbin中。可以用which和type找到它们的位置。 当外部命令执行时，会创建出一个子进程。这种操作叫衍生（forKing）。ps的父进程PID是9943。 有的命令有多种实现，比如echo和pwd，可以用type -a 查看。 內建命令，不需要通过衍生出子进程来执行，也不用打开程序文件。所以，执行速度快，效率高。內建命令有很多: cd, fg, bg, history, test, alias…]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再装Ubuntu]]></title>
    <url>%2F2017%2F11%2F30%2F%E5%86%8D%E8%A3%85Ubuntu%2F</url>
    <content type="text"><![CDATA[由于之前遇到的Ubuntu16.04安装fcitx的问题没有解决，而后又遇到scim崩溃–把系统卡死（htop看到4核cpu和12G内存全部变红）。 我重新安装了Ubuntu，现在就做个简单的总结。 修复grub &amp; 再添加引导win10安装了Ubuntu16.04在win10上，没有grup的引导，开机直接进04在win10。解决方法：利用Ubuntu安装U盘try Ubuntu来修复。连上网，打开终端：123456sudo add-apt-repository ppa:yannubuntu/boot-repairsudo apt-get update#安装boot-repair#这个工具可以修好大多数引导问题sudo apt-get install -y boot-repair &amp;&amp; boot-repair 然后出现boot-repair的界面，选择Recommend repair过几分钟就OK了。 重启以后，grub引导选项里发现没有win10 。123#更新一下grub就有win10 了sudo update-grub #sudo update-grub2 #也行 问题已经没有了。如果想排序grub引导os的顺序参考下图：30_os-prober 那个就是win10 。把30改为08或09就能放在前面了。 注： 个人的一些个性化设置，如命令别名、路径等，可以在~/.bashrc中设置。 1locate grub | grep grub 可以看到关于grub的设置在/ect/default和/boot/grub中也有。 grub BASH-like在修复之前我还遇到一个问题：开机显示 Minimal BASH-like line editing is supported.这是修复grub出错的一个正常提示。修复方法在上面已经给出了。下面给一个进入win10 的方法：123456#从硬盘的第一个分区C盘启动grub&gt;root (hd0,0)#指示grub读取分区第一个扇区的引导记录grub&gt;chainloader (hd0,0)+1#启动grubgrub&gt;安装boot 看似这样可以进入grub引导。实际上，会进入win的mbr引导。 搜狗这次安装搜狗输入法就简单的多了。 下载Linux版搜狗输入法 dpkg 命令安装deb软件包 缺少依赖，sudo apt-get install -f 修复依赖问题 再安装，完成。 可以发现这里没有安装fcitx。但是还是装好了搜狗，重点在于install后面的 -f 。 别的安装：1 . Google浏览器翻墙在官网下载Linux安装包。2 . atom 在官网下载安装包。3 . shadowsocks-QT5安装方法：网上的添加源安装行。也可参考这里。安装完成，再在chrome上安装插件SwitchySharp，配置一下即可翻墙。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的bash shell]]></title>
    <url>%2F2017%2F11%2F30%2F%E7%AE%80%E5%8D%95%E7%9A%84bash-shell%2F</url>
    <content type="text"><![CDATA[关于文件pwd : Print name of Working Directory ls :过滤器（通配符）： 问号（？）代表1个字符 星号（*）代表0个或多个字符 元字符通配符[a-z]表示a-z中任一字符 元字符通配符[!a]表示匹配除a以外的字符 和SQL中的通配符类似，通配符和正则匹配的区别在与：通配符匹配所有内容。例如： 通配符匹配：‘my’表示匹配的内容全名就是‘my’ 正则匹配：‘my’表示匹配的内容里有‘my’ 1ls -l my* #ls 列出以my开头的文件信息 文件操作基本命令： 操作 touch cp mv 改名或移动 rm 2.查看 tree file 查看文件类型 cat , head , tail more 显示文本文件 less 是more的升级版，可以查找 链接文件： 硬链接:hard link，硬链接和原始文件是同一个文件–唯一标识文件的inode号是一样的。 符号链接（软链接）:symbolic link，符号链接是一个单独的文件。这个文件指向原始文件（原始文件一定要存在）。ln -s 可以创建符号链接。 用 ls -li 查看文件时，可以看到，软链接文件的大小比原始文件小，此外还有一个指针指向原始文件，inode号不同。硬链接和原始文件一模一样。 硬链接 存在以下几点特性： 文件有相同的 inode 及 data block 只能对已存在的文件进行创建 不能交叉 文件系统 进行硬链接的创建 不能对 目录 进行创建，只可对文件创建 删除一个硬链接文件并不影响其他有相同 inode 号的文件 符号链接 特点： 软链接有自己的文件属性及权限等 可对不存在的文件或目录创建软链接 软链接可交叉 文件系统 软链接可对文件或 目录 创建 创建软链接时，链接计数 i_nlink 不会增加 删除软链接并不影响被指向的文件，但 若被指向的原文件被删除，则相关软连接被称为死链接 (即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接 ) 关于进程ps :process, 查看当前时间点的进程信息。ps有两个版本，但相差不大。给出两个版本最常用的参数。BSD版本：ps -auxUNIX版本：ps -ef top :task of process，top将输出进程叫做任务（task）。top可以实时监测进程的状态。 建议使用htop，top的升级版。 kill :kill杀死指定进程号进程。可以和对应的linux进程信号联用。比如：9无条件终止；1挂起；2中断等等。 killall :killall杀死指定进程名进程。例如：1killall http* #杀死所有以http开头的进程 磁盘存储df : Disk space available on File system，可以查看所有挂载的文件系统，以及磁盘空间的使用情况。一般用法：1df -h du : Disk Usage，磁盘使用情况。一般用于查看文件/目录大小。一般用法：1du -h #当前目录下各个文件所占磁盘空间 mount :mount原意为骑上，增加。这里表示挂载。用法：123456789101112#查看挂载情况，我觉得用df更好mount #把U盘挂载/dev/sdb1挂载到/media/diskmount -t vfat /dev/sdb1 /media/disk#卸载U盘umount /dev/sdb1#下面命令可以修复Linux下的win盘挂载错误ntfsfix /filesystem#如果报错，关闭win快速启动 处理数据文件sort :排序数据。options: -b –ignore-leading-blank忽略起始空白 -n –numeric-sort -g –general-number-sort把值当成浮点数 -r –revers 一个例子：12#当前目录下文件占用空间情况，逆序输出du -sh * | sort -nr grep :搜索数据–非常流行的命令。synopsis： grep [options] pattern [file] 在名为 file 的文件中查找 含有pattern关键字的行。 options: -v 相反匹配 -c 匹配到的总行数 [] 正则匹配指定字符，如[tf]匹配t或f . *等等 tar : gzip-&gt;.gzGNU压缩工具1234#压缩：tar –zcvf filename.tar.gz filename(dirname)#解压：tar –zxvf filename.tar.gz filename(dirname) bzip2-&gt;.bz2采用1234#压缩：tar –jcvf filename.tar.bz2 filename(dirname)#解压：tar –jxvf filename.tar.bz2 filename(dirname)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无为的一个下午]]></title>
    <url>%2F2017%2F11%2F28%2F%E6%97%A0%E4%B8%BA%E7%9A%84%E4%B8%80%E4%B8%AA%E4%B8%8B%E5%8D%88%2F</url>
    <content type="text"><![CDATA[你应该庆幸自己遇到了问题因此，没有蒙在鼓里 今天我装fcitx装了一个下午，其实我前两天就开始装了。一直没装好。 看遍了网上的教程也没有解决问题 fcitx-github fcitx 官网 一般安装方法 我安装了fcitx，没有报错，我还安装了 fcitx- 一系列的包，可是，打开fcitx提示， 正确的打开方式应该如下： 正常打开fcitx输入法会有几个fcitx的进程。我的没有。 关于输入法IM 环境变量 (我把自己的也相同设置了) 此外 1locate fcitx | grep "fcitx$" 查看了关于fcitx一些文件，还有~/.config目录下的配置文件，未果Q_Q 为啥会有错误呢？可能是之前update , install -f 有问题，删除了某些文件，也可能是我出了错误，安装了XIM , SCIM (后来apt remove了还是不行)更改了某些输入法配置文件。现在先用着SCIM的智能拼音，有时间再把这个坑添上= = 大二的时候安装sogou，按照教程走一遍，ok了，多简单。虽然成功了，却没有理解其中的原理，也没有注意程序输出的内容。 现在遇到问题，不如以前遇到问题，以后遇到问题，不如今天遇到问题。 总之，多积累。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux后台程序]]></title>
    <url>%2F2017%2F11%2F27%2Flinux%E5%90%8E%E5%8F%B0%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[在终端输入htop 然后Ctrl+Z, 把进程放在后台执行。再在本终端输入bmon（bandwide monitor）然后Ctrl+Z, 把进程放在后台执行。 那么，Ctrl+Z 是什么呢？ 在终端输入top &amp;，程序直接在后台执行。 结论 ：Ctrl+Z 执行的操作是，在当前命令的结尾加一个 &amp;，然后当前程序就放在本终端的后台执行了。 在本终端输入jobs, 可以看到本终端的后台程序。 把后台程序调入前台：fg + &lt;序号&gt; bg显示最后一个加入后台的程序(序号最大) fg 默认把序号最大的后台程序调入前台 在别的终端输入jobs,看不到。但是用ps可以查到。 最后：如果不kill后台进程，而是把当前终端关闭，当前终端的后台程序会自动kill掉。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github遇到的坑]]></title>
    <url>%2F2017%2F11%2F27%2Fgithub%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[部署博客时（hexo d） 遇到错误 Error: EACCES: permission denied, unlink ‘/home/mitrecx/blog/.deploy_git/about/index.html’ 遇到这样的权限问题，理所当然的想到1chmod -R 777 . 简单粗暴，解决问题。 但是，我没有这么做！ 我直接1sudo hexo d 新问题来了 ssh: connect to host my.github.com port 22: Connection timed out fatal: Could not read from remote repository. Please make sure you have the correct access rightsand the repository exists. FATAL Something’s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html 为什么会ssh github 会有问题？ 我试了一下：1ssh -T git@github.com 两个帐号都可以连接到github 但是 用sudo就不行sudo ssh连接github提示publickey不行 原因很明显了：我用的 sshkey 是 mitrecx 用户生成的。sudo执行 命令时，用的是 root 用户的 sshkey，所以github会拒绝接受git请求。sshkey在 ~./ssh 目录下，root 可以复制，查看 mitrecx 的 sshkey, 感觉有点不安全.但是, root 用户 连 mitrecx 的 登录密码 都能改, 还说啥安全不安全的….. github权限的坑踩完了。 为什么最初我在 hexo d 会出出错呢？原因是我在 hexo d 执行前，执行的是 sudo hexo g ，而不是 hexo g 。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git简单教程]]></title>
    <url>%2F2017%2F11%2F26%2Fgit%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[从零开始－－简单使用首先, 强烈推荐这个网站. 12345678910111213141516171819202122232425262728293031git init #初始化(新建)一个 本地 git 仓库#第一次把本地仓库提交到 github#添加到 暂存区，不添加的话 filename是 untracked ,untracked files不能 commitgit add &lt;filename&gt; #把暂存区的内容提交到 HEAD, 仍然在 本地git仓库git commit -m "关于本次提交的说明信息"#本地仓库连接远程仓库 ，连接名为 origingit remote add origin git@github.com:username/repository.git#把 HEAD 里的内容提交到 github 上的 master 分支git push origin master#再次操作#现在有本地仓库，也和github连接过（有连接名origin），#只要三步就能push到githubgit add &lt;filename&gt;git commit -m "commit info"git push origin &lt;branch-name&gt;##分支git branch #查看分支， -a查看所有分支git branch -d branchname #有些时候可能会删除失败,比如如果branchname分支的代码还没有合并到master, -D 可以强制删除git branch new-branch #创建名为new-branch的分支git checkout new-branch #切换到new-branch分支#git checkout -b new-branch #简化：创建并切换##频繁使用的一个命令－－查看状态git status 如果git add一个不想要的提交的file，可以用以下命令清除1234git rm --cached &lt;filename&gt; #只是删除 暂存区 中的文件# 不想 追踪 track 的文件 要 添加到 .gitignore 文件中呀 git rm -f &lt;filename&gt; #删除 暂存区 中的文件 同时 删除 磁盘上本地文件, 不可恢复 从一开始工作流你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 工作目录，它持有实际文件；第二个是 暂存区（Index)，它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。 创建新仓库创建新文件夹，打开，然后执行1git init 创建新的 git 仓库 添加和提交提出更改（把它们添加到暂存区），使用如下命令：1git add &lt;filename&gt; 举一个例子， 如果想把当前目录下的所有文件添加到 暂存区INDEX ,执行： 1git add . 如果想把当前目录下的某几个文件添加到 暂存区INDEX ,执行： 1git add &lt;filename1,2,3&gt; 还有个方法，在当前目录下建立一个名为 .gitignore 的文件。然后把想要忽略的文件名添加在.gitignore中, 这样这些文件就不会 出现在未跟踪文件列表. .gitignore 用 glob 模式匹配 (git 命令 也可以使用 glob 模式).所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。使用两个星号（*) 表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z , a/b/z 或 a/b/c/z 等。 .gitignore 示例: 1234567891011121314151617# no .a files*.a# but do track lib.a, even though you&apos;re ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in the build/ directorybuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directorydoc/**/*.pdf 撤消对文件的修改:如果 修改 了 已追踪文件 README (未提交), 但是 后来又想 撤回 修改(撤回到暂存区的状态):1git checkout -- README 如果 暂存区 的想 撤回 到 已提交的本地git库:1234# 先 移除 暂存区. 也可以使用: git rm --cached READMEgit reset README# 再 checkout 检查撤回git checkout -- README 放弃 本地git仓库 提交:12git fetch --allgit reset --hard origin/master 注意:12345# 远程仓库中抓取 数据, 它并不会自动合并或修改你当前的工作git fetch [remote-name]# 自动的抓取然后合并远程分支到当前分支git pull [remote-name] [branch-name] git add是 git 基本工作流程的第一步；使用如下命令以实际提交改动 到本地仓库：1git commit -m "代码提交信息" 现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库 推送改动你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：1git push origin master 可以把 master 换成你想要推送的任何分支。 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：1git remote add origin &lt;server&gt; 如此你就能够将你的改动推送到所添加的服务器上去了 分支分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。12git branch hexo //新建hexo分支git checkout hexo //切换到hexo分支上 12345git checkout -b feature_x #创建一个叫做“feature_x”的分支，并切换过去：git checkout master #切换回主分支git branch -d feature_x #再把新建的分支删掉git push origin &lt;branch&gt; #将分支推送到远端仓库 更新与合并A同学在a分支代码写的不亦乐乎,终于他的功能完工了,并且测试也都ok了,准备要上线了,这个时候就需要把他的代码合并到主分支master上来,然后发布。git merge 就是合并分支用到的命令,针对这个情况,需要先做两步,第一步是切换到 master 分支,如果你已经在了就不用切换了,第二步执行 git merge a ,意思就是把a分支的代码合并过来,不出意外,这个时候a分支的代码就顺利合并到 master 分支来了。git pull命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并 git clone12345678#1.最简单直接的命令git clone xxx.git#2.如果想clone到指定目录git clone xxx.git "指定目录"#3.clone时创建新的分支替代默认Origin HEAD（master）git clone -b [new_branch_name] xxx.git git clone 命令默认的只会建立master分支. 1 查看所有分支(包括隐藏的) git branch -a 显示所有分支，如： 1234* master remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/master 2 在本地新建同名的(“dev”)分支，并切换到该分支123git checkout -t origin/dev#等同于：git checkout -b dev origin/dev 执行完2，发现dev分支的内容已经存在于本地仓库了。 其他常用 git命令远程跟踪分支 是 远程分支 状态 的 引用, 远程跟踪分支 也叫 上游分支( upstream ) .它们是 不能移动的本地引用，当 你做任何网络通信操作时，它们会自动移动.它们以 (remote)/(branch) 形式命名.例如，如果你想要看你最后一次与远程仓库 origin 通信时 master 分支的状态，你可以查看 远程跟踪分支 origin/master 。 (从一个 远程跟踪分支 检出一个 本地分支 叫 “跟踪分支” , 简单 理解为 本地分支 就好了.) 假设 远程分支如下:123456789101112131415161718192021222324$ git remote show origin* remote origin Fetch URL: https://github.com/mitrecx/design-pattern.git Push URL: https://github.com/mitrecx/design-pattern.git HEAD branch: master Remote branches: develop tracked master tracked test-old new (next fetch will store in remotes/origin) testing tracked Local branches configured for &apos;git pull&apos;: develop merges with remote develop master merges with remote master testing merges with remote testing Local refs configured for &apos;git push&apos;: develop pushes to develop (up to date) master pushes to master (up to date) testing pushes to testing (fast-forwardable)$ git branch -vv develop 68615f5 [origin/develop] x iss2 6bf377a none-iss2 master ffa65b3 [origin/master] no licence - master* testing 92042b6 [origin/testing: ahead 18] 义之所至 生死相随 远程仓库名: origin.远程分支 有 4 个: master, develop, testing, test-old.本地分支 有 3 个: master, develop, testing.三个远程分支, 都被追踪了(tracked) . 同时 git pull 自动合并:develop–&gt; origin/develop;master–&gt; origin/master.所以, 要想合并 origin/testing 分支 到 testing, 要手动 merge.但也可以用命令 git branch -u origin/testing 设置 跟踪分支 (即, 设置本地 testing 分支和 远程分支对应关系). 12345678910111213141516171819# 获得远程分支信息git remote show (remote)# 抓取 远程仓库origin 的数据 到本地git fetch orign# 把抓取到的 远程仓库 master 分支数据 和 本地仓库的 master分支合并git checkout mastergit merge origin/master# 上述 抓取合并 操作 一般等价于 git pull origin master# 查看设置的所有跟踪分支git branch -vv# 查看 分叉历史git log --oneline --graph --all# 删除远程 分支 testinggit push origin --delete testing]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客常用字颜色查询]]></title>
    <url>%2F2017%2F10%2F17%2F%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E5%AD%97%E9%A2%9C%E8%89%B2%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[查询颜色名列表绿色-green1**&lt;font color=&apos;#2eb82e&apos;&gt; &lt;/font&gt;** 橙色–orange1**&lt;font color=&apos;#ff9900&apos;&gt; &lt;/font&gt;** 蓝色-blue1**&lt;font color=&apos;#1a75ff&apos;&gt; &lt;/font&gt;** 紫色-purple1**&lt;font color=&apos;#8a00e6&apos;&gt; &lt;/font&gt;**]]></content>
      <categories>
        <category>编程工具</category>
      </categories>
      <tags>
        <tag>编程工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016-开始]]></title>
    <url>%2F2016%2F12%2F31%2F2016-%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[“夫, 以铜为镜, 可以正衣冠, 以史为镜, 可以知兴替, 以人为镜, 可以明得失” 写一篇总结, 告诫自己, 以此为镜, 希望可以在以后困惑的日子里有所启发. 思想年轻人的思想很容易受到社会的或身边事物的影响, 如果是积极健康的思想影响这我们, 那么我们会进步, 腐败错误的思想, 我们会迷茫. 在我现在的角度来看, 如果不读书, 不读几本好书, 我是接触不到好的思想的. 我的经验就是最好的说明. 以前还没读过李嘉诚《成功没有偶然》（大一看的）的时候, 我以为读书没有多少用处. 当时目光狭隘, 读书少, 经历少, 看不到现在看来很平常的事实.用短浅的目光去看这个世界, 去规划自己的一生, 去尝试去取得一点点的进步. 最终以思想封闭（自己不知道）而告以失败. 我在2016年里读了两本书, 受益匪浅. Paul Graham的《黑客与画家》和朱光潜的《谈修养》. 这两本书是我在2016最大的收获了.还有一本哈佛学生写的study less learn more , 关于高效学习的书, 其学习方法我不完全认同, 但也颇有收获. 《谈修养》基本谈完了一个人的方方面面, 谈立志, 谈学问, 谈读书, 谈价值意识这几篇尤为深刻. 书中“朝着抵抗力最大的路径走”这一观点我很受启发.他说到, 贪懒取巧都不会有大成就, 要有大成就, 必定朝抵抗力最大的路径走. 1986年过世的先辈, 见识还能那么辽阔, 这使我赞叹伟人的修养之高.关于读书, 好书不厌百回读, 熟读深思子自知. 《黑客与画家》中提到一个预言,互联网软件将代替桌面软件. Paul为自己的预言做了分析. 有远见精通技术的黑客, 无愧于硅谷创业之父的称号. 我总结了 Paul 分析的创业者的 主要特征：1, 生命毕竟只有一次, 你可能想用它做一些伟大的事情.2, 不随大流：不能把别人灌输的观点作为自己的观点, 自己的观点应该是独立思考得到的.3, 能思考：智力越高的人, 越愿意去思考那些惊世骇俗的观念. 不仅仅是聪明人本身很积极地寻找传统观念的漏洞, 还因为传统观念对他们的束缚力很小. 只要你能 看到别人看不到或不敢看的东西, 你就有很大的优势.4, 创作者：坚持一丝不苟, 自己设计和开发, 更努力地工作（未来５０年的工作压缩到３年完成）5, 良好的坏习惯：不服从管教, 并非故作姿态.6, 创业初期的白天工作：为了生计, 找一份白天工作. 其余时间开发优美的软件. 因为工作心理周期, 有兴趣时, 一天１６小时工作, 疲倦就做一些比较容易的事.7, 创业公司：先做出原型, 关注客户, 目标客户. 经历买家具：能说会道的 merchant, 不能相信, 我们应该学会自己分析市场. 父母回到家乡：记得我很小的时候, 父母就在海门那边的窑厂上干活了. 今年我都21岁了, 父母和窑厂, 工地, 砖头打了20几年的交道. 其中的血泪辛酸不言自知. 而在今年六月份, 父母去孙台子种草了. 二十几年了, 从这里离开又回到这里. 他们为了我经历了太多. 我了解我们家一路的不容易.明年, 以后, 我不会让父母再为我的未来操心了. 德国之旅：辗转几回, 才办好签证, 去一次莱比锡很不容易（6.29下午到达法兰克福, 7.5下午离开法兰克福）.感谢王凡老师的信任, 让我代表 学校的 3D队伍 去参赛.在德国我见识到了异国风情, 这是我目前去过最远的地方, 第一次, 一些经历可能永生难忘. 第一次做飞机飞十个小时, 心里既忐忑又激动.在莱比锡感慨这座城市的自由, 空气清新, 蓝天白云, 感慨人们在轻轨上言论的文明（听不懂, 但人们说话声音都很小）, 感慨城市地上不见一个塑料袋…郭院长, 王老师, zkp, 我们一行人去参加robocup2016年的仿真3D的赛事. 我和zkp还在和 UT大神 交流上有一些分歧, 导致比赛过程中我有些难受.我暗下决心, 要努力学好英语, 掌握一个领域的技术, 不能太菜了. 小组招新：一个人面对一群同龄人, 宣讲, 培训…我在这方面处理的不好, 有很大的欠缺. 不够从容, 这与我才学疏浅有关罢.在一个人面前说话, 和在一群人面前说话感受是不一样的. 英语四级考试：这是我第四次考了. 我曾扬言必过.(第四次也没过, 2017年上半年第五次才考过4级, 2017年下半年6级一次考了429分, 不论以前多差, 努力是可以改变的) —后来补充. 人物zkp:我曾意气风发说读书要超过你. 你就像老师一样指引着我. “人生其实宽广的很”, 人什么时候才能理解的透. 合工大学姐:还记得在莱比锡的会展中心里, 你对我说的话. 我很敬畏你们学问能力出色的人. 你们在我心中都是大神. 我听了你的想法, 我决定考研, 希望将来能和你们站在一个高度上.还记得当时在轻轨上你和德国小伙交流, 我只能说 I can’t speak English. UT大神 Patrick MacAlpine 和德国牛逼的教授及大学生:我在他们身上看到了做学术的气息, 人家那才是专心搞研究, 宠辱不惊, 一门心思做一件事. 在比赛之余, 还有闲情雅致去欣赏别的展览. 计科班长 wzh 和物联网学长 zl:他们的努力和智慧. 最后思想的转变, 是我用一年的时光换来的, 时间太长了, 不过现在领悟到也不算晚.我这一年做的最大的决定就是考研了. 我会尽全力考上我的研究生, 不论风霜雨露, 这将是我2017的坚持.现在, 已经是2017年了. 勿忘初心, 坚持可贵!!!]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
</search>
