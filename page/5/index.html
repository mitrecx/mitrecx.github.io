<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/woAiLuo.jpg?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Goals determine what you are going to be">
<meta property="og:type" content="website">
<meta property="og:title" content="MITRE">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="MITRE">
<meta property="og:description" content="Goals determine what you are going to be">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MITRE">
<meta name="twitter:description" content="Goals determine what you are going to be">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/">





  <title>MITRE</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MITRE</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Goals determine what you are going to be</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/14/Linux系统程序设计1-文件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/14/Linux系统程序设计1-文件/" itemprop="url">Linux系统程序设计1--文件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-14T19:48:53+08:00">
                2018-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-linux系统程序设计—文件"><a href="#1-linux系统程序设计—文件" class="headerlink" title="1.  linux系统程序设计—文件"></a>1.  linux系统程序设计—文件</h1><p>系统调用是一种例程。<br>系统调用用于执行文件I/O、分配内存、创建进程等。<br>标准ANSI C库函数，如fopen和printf可以作为对象模块捆绑到一个档案中。系统调用与之不同，它们内置在内核中，一般由汇编语言编写。但是，提供了接口，可以像调用函数一样调用接口。  </p>
<p><font color="orange">库函数通常不包含系统调用提供的精细控制功能</font> 。例如：<br>fopen不能设置文件权限，而open可以设置。<br>只有利用stat系统调用才能知道文件的大小。<br>只有fork系统调用才能创建进程。  </p>
<p><strong>系统调用</strong>要比调用<strong>库函数</strong> 的的开销大.  </p>
<h1 id="2-errno-和-perror：处理错误"><a href="#2-errno-和-perror：处理错误" class="headerlink" title="2.  errno 和 perror：处理错误"></a>2.  errno 和 perror：处理错误</h1><p><strong>系统调用在错误时返回-1</strong><br>错误的发生可能会有多种原因——资源不可用、接收到一个信号、I/O操作失败、调用参数无效。  </p>
<p>当系统调用返回-1时，内核将静态（全局）变量errno设定为一个正整数。这个<strong>用符号常量表示的整数</strong>与<strong>错误消息</strong>相关联。  </p>
<p>仅当系统调用返回错误时才使用perror。<br>perror函数语法：<br>void perror(const char *s)  ;<br>函数的以一个字符串s为参数。函数输出：打印该字符串s、一个冒号、一个空格，然后是与errno相关联的消息。  </p>
<table>
<thead>
<tr>
<th>符号常量</th>
<th>errno</th>
<th>消息</th>
</tr>
</thead>
<tbody>
<tr>
<td>E PERM</td>
<td>1</td>
<td>Operation not permitted</td>
</tr>
<tr>
<td>E NOENT</td>
<td>2</td>
<td>No such file or directory</td>
</tr>
<tr>
<td>E SRCH</td>
<td>3</td>
<td>No such process</td>
</tr>
<tr>
<td>E INTR</td>
<td>4</td>
<td>Interrupted system call</td>
</tr>
<tr>
<td>E IO</td>
<td>5</td>
<td>I/O error</td>
</tr>
<tr>
<td>E ACCES</td>
<td>13</td>
<td>Permission denied</td>
</tr>
<tr>
<td>E EXIT</td>
<td>17</td>
<td>File exits</td>
</tr>
<tr>
<td>E NOTDIR</td>
<td>20</td>
<td>Not a directory</td>
</tr>
<tr>
<td>EISDIR</td>
<td>21</td>
<td>Is a directory</td>
</tr>
</tbody>
</table>
<p>以下程序show_errors.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  //获取open中的O_RDONLY</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  //获取fprintf中的stderr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; //获取exit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/error.h&gt;  //获取errno</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">  <span class="comment">//以只读模式打开</span></span><br><span class="line">  <span class="keyword">if</span>(open(argv[<span class="number">1</span>],O_RDONLY)==<span class="number">-1</span>) <span class="comment">//O表示open，RD表示read。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"errno=%d\n"</span>, errno);</span><br><span class="line">    perror(<span class="string">"open"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行时，如：<br>$ ./a.out foofoo<br>errno = 2<br>open: No such file or directory</p>
<h1 id="3-open-打开和创建文件"><a href="#3-open-打开和创建文件" class="headerlink" title="3. open: 打开和创建文件"></a>3. open: 打开和创建文件</h1><p>一些与文件Ｉ/O相关的系统调用：　　</p>
<ul>
<li>open , close</li>
<li>read , write</li>
<li>lseek</li>
<li>truncate , ftruncate</li>
</ul>
<p><strong>在读写一个文件之前，必须要用open打开它。</strong><br>open语法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> open（<span class="keyword">const</span> <span class="keyword">char</span> \*path, <span class="keyword">int</span> oflag, ...)  ;</span><br></pre></td></tr></table></figure></p>
<p><strong>open以int形式返回一个文件说明符 (<font color="orange"> file description</font> ) 。当发生错误时，open返回 -1 。</strong><br>第一个参数(path)是一个指针，指向一个表示文件路径名的字符串(绝对路径或相对路径)，<br>第二个参数(oflag)用于<strong>设置打开模式</strong>(读、写或读-写)。这一模式用三个符号常量表示：<br><strong>O_RDONLY</strong> 打开文件供读取<br><strong>O_WRONLY</strong>  打开文件供写入<br><strong>O_RDWR</strong>    打开文件供读和写<br>这些常量在/usr/include下的文件 fcnlt.h 中定义。<br>用法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="comment">//以只读方式打开passwd文件，如果打开出错，就打印错误</span></span><br><span class="line"><span class="keyword">if</span>( (fd=open(<span class="string">"/etc/passwd"</span>,O_RDONLY)) == <span class="number">-1</span>)&#123;</span><br><span class="line">  perror(<span class="string">"open"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此外，open还有更多打开模式 ( 也在fcntl.h中定义 ):<br><strong>O_APPEND</strong>  追加模式打开文件(仅当打开模式为O_WRONLY或O_RDWR)<br><strong>O_TRUNC</strong>  将文件截短为0(条件同上)，其实就是覆盖文件(注:truncate  截短、缩短)<br><strong>O_CREAT</strong>  若文件不存在，则创建文件<br><strong>O_EXCL</strong>   若指定O_CREAT，且该文件存在，则生成一条错误<br><strong>O_SYNC</strong>  同步读写操作。确保在将数据写到磁盘之前，write不会返回<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似shell中的&gt;&gt;</span></span><br><span class="line">fd=open(<span class="string">"foo.txt"</span>, O_WRONLY | O_APPEND )</span><br><span class="line"><span class="comment">//类似shell中的&gt;</span></span><br><span class="line">fd=open(<span class="string">"../foo.txt"</span>, O_WRONLY | O_TRUNC )</span><br></pre></td></tr></table></figure></p>
<p>如果文件不存在，就要用O_CREAT（有时会用到O_EXCL）创建它，并在第三参数指定其权限。<br><strong>Linux/Unix在sys/stat.h中提供了符号常量以设置权限</strong><br>但是也可以，用八进制(octal)数设置权限，必须添加前缀0。（例如0644而不是644）<br>0644等同于：<br>S_IRUSR|S_IWUSR | S_IRGRP | S_IROTH<br>表示用户可读写，组可读，其他可写<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开foo.txt，以截断方式写入，如果foo.txt不存在，就创建该文件</span></span><br><span class="line">fd = open(<span class="string">"foo.txt"</span>, O_WRONLY|O_CREAT|OTRUNC, <span class="number">0644</span>);</span><br></pre></td></tr></table></figure></p>
<h1 id="4-close-关闭文件"><a href="#4-close-关闭文件" class="headerlink" title="4. close: 关闭文件"></a>4. close: 关闭文件</h1><p><strong>程序在终止之前会关闭所有已打开文件，但不在需要文件时主动关闭是一种好习惯。</strong><br>close系统调用可以关闭一个文件:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>close用文件描述符( file description )作为参数，实际上是释放<strong>对该进程的文件说明符</strong>。<br>close成功返回0，失败返回-1.  </p>
<h1 id="5-read-读取文件"><a href="#5-read-读取文件" class="headerlink" title="5. read:  读取文件"></a>5. read:  读取文件</h1><p>两个系统调用——read和write——负责对常规文件(REG,regular)以及管道和套接字进行读写操作。<br><strong>这两个调用的语法类似，都利用了用户定义的缓冲区。</strong><br>read利用open返回的文件说明符来读取文件：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fildes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbyte);</span><br></pre></td></tr></table></figure></p>
<p>read尝试从文件说明符fildes向缓冲区buf中读取nbyte个字符。<br><strong>文件说明符</strong>就是要<strong>读取的对象</strong>，<strong>缓冲区</strong>是读取后<strong>内容存放的地方</strong>，<strong>nbyte</strong>是一次<strong>读取n个字节</strong><br>注：nbyte通常是缓冲区本身的大小<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 4096</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line"><span class="keyword">while</span>( (n=read(fd, buf, BUFSIZE))&gt;<span class="number">0</span> ) <span class="comment">//由open获得的fd</span></span><br></pre></td></tr></table></figure></p>
<p>每次read调用，读取4096个字节。<strong>在遇到EOF之前，read返回所读字符数，<del>而遇到EOF时，返回0</del>( 准确地说，是文件的大小是缓冲区的整数倍，最后一次遇到EOF返回0 )</strong>。但最后一次迭代可能例外，最后一次迭代中，返回的是尚未读取的字符数（因为文件的大小可能不是缓冲区大小的整数倍）。read错误返回-1。<br>例如：如上程序，fd描述的文件有4100个字节，第一次迭代read返回4096，第二次迭代read返回4个字节，第三次返回0。  </p>
<p>如果要处理所读取的每个字符，可将buf声明为一个char变量，然后将其地址传给read：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> buf;</span><br><span class="line"><span class="keyword">while</span>( (n=read(fd, &amp;buf, <span class="number">1</span>))&gt;<span class="number">0</span> )</span><br></pre></td></tr></table></figure></p>
<p>用单字符缓冲区读取100个字符需要100次系统调用，这个代价高昂。在这种情况下，诸如fgetc之类的<strong>库函数</strong>是比较好的选择。  </p>
<h1 id="6-write：-写文件"><a href="#6-write：-写文件" class="headerlink" title="6. write： 写文件"></a>6. write： 写文件</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fildes, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbyte) ;</span><br></pre></td></tr></table></figure>
<p>write把<strong>缓冲区</strong>的内容写入到fildes说明的<strong>文件</strong>中。<br>write返回所写字符个数。如果write运行期间磁盘已满或文件大小超出系统限制，则write返回-1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 8192</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">n = write(fd, buf, BUFSIZE);</span><br></pre></td></tr></table></figure></p>
<p>和read一样，write可以一次写一个字符：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf;</span><br><span class="line">write(fd, &amp;buf, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<hr>
<p>一个利用系统调用复制文件的程序：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//quit.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//quit.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"quit.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">char</span> *message, <span class="keyword">int</span> exit_status)</span></span>&#123;</span><br><span class="line">        perror(message);</span><br><span class="line">        <span class="built_in">exit</span>(exit_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ccp.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"quit.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd1,fd2;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((fd1=open(argv[<span class="number">1</span>],O_RDONLY))==<span class="number">-1</span>)</span><br><span class="line">                quit(<span class="string">"open"</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>((fd2=open(<span class="string">"passwd.bak"</span>,O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0664</span>))==<span class="number">-1</span>)</span><br><span class="line">                quit(<span class="string">"open2"</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( (n=read(fd1,buf,BUFSIZE))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(n!=write(fd2,buf,n))</span><br><span class="line">                        quit(<span class="string">"write"</span>,<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd1);</span><br><span class="line">        close(fd2);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译、运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译quit.c 生成quit.o目标文件</span></span><br><span class="line">$ gcc -c quit.c</span><br><span class="line"></span><br><span class="line"><span class="comment">#用ccp.c和quit.o编译出a.out(默认的可执行文件名，可用-o指定别的名)</span></span><br><span class="line">$ gcc ccp.c quit.o</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行程序，复制passwd的内容到当前目录下的passwd.bak文件中</span></span><br><span class="line">$ ./a.out /etc/passwd</span><br></pre></td></tr></table></figure></p>
<p>write不一定写入磁盘，如果把ccp.c中的第二个open和close删除，把fd2改为1 ( 或改为STDOUT_FILENO，需要包含头文件unistd.h )，就可以写到标准输出了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"quit.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd1,fd2;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((fd1=open(argv[<span class="number">1</span>],O_RDONLY))==<span class="number">-1</span>)</span><br><span class="line">                quit(<span class="string">"open"</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//      if((fd2=open("passwd.bak",O_WRONLY|O_CREAT|O_TRUNC, 0664))==-1)</span></span><br><span class="line"><span class="comment">//              quit("open2",2);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( (n=read(fd1,buf,BUFSIZE))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(n!=write(STDOUT_FILENO,buf,n))</span><br><span class="line">                        quit(<span class="string">"write"</span>,<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd1);</span><br><span class="line"><span class="comment">//      close(fd2);</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：<br>读写标准流时，应当使用符号常量STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO作为文件说明符，而不是他们所表示的整数0、1、2。这些符号常量在unistd.h中定义。  </p>
<hr>
<h2 id="缓冲IO和无缓冲IO"><a href="#缓冲IO和无缓冲IO" class="headerlink" title="缓冲IO和无缓冲IO"></a>缓冲IO和无缓冲IO</h2><p><a href="https://www.cnblogs.com/cavehubiao/p/3981482.html" target="_blank" rel="noopener">带不带缓存是相对层来说的</a>。<br>如果你要写入数据到文件上时（就是写入磁盘上），内核先将数据写入到内核中所设的缓冲储存器。<br>假如这个缓冲储存器的长度是100个字节，你调用系统函：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> write (<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> * buf,<span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure></p>
<p>写操作时，设每次写入长度count=10个字节，那么你几要调用10次这个函数才能把这个缓冲区写满，<strong>此时数据还是在缓冲区，并没有写入到磁盘。</strong><br>缓冲区满时才进行实际上的IO操作，把数据写入到磁盘上，所以上面说的“不带缓存””不是没有缓存而是没有直写进磁盘。</p>
<p>那么，既然<strong>不带缓存的操作实际在内核是有缓存器的</strong>，那<strong>带缓存的IO操作</strong>又是怎么回事呢？</p>
<p>带缓存IO也叫标准IO，符合ANSI C 的标准IO处理，不依赖系统内核，所以移植性强，我们使用标准IO操作很多时候是为了减少对read()和write()的系统调用次数，带缓存IO其实就是在用户层再建立一个缓存区，这个缓存区的分配和优化长度等细节都是标准IO库代你处理好了，不用去操心.<br>还是用上面那个例子说明这个操作过程：<br>内核缓存（注意这个不是用户层缓存区）区长度是100字节，<br>我们调用不带缓存的IO函数write()就要调用10次，这样系统效率低，<br>现在我们在用户层建立另一个缓存区（用户层缓存区或者叫流缓存），假设流缓存的长度是50字节，<br>我们用标准C库函数的fwrite()将数据写入到这个流缓存区里面，流缓存区满50字节后在进入内核缓存区，此时再调用系统函数write()将数据写入到文件（实质是磁盘）上，<br>标准IO操作fwrite()最后还是要掉用无缓存IO操作write,这里进行了两次调用fwrite()写100字节也就是进行两次系统调用write()。  </p>
<h1 id="lseek-定位偏移指针"><a href="#lseek-定位偏移指针" class="headerlink" title="lseek: 定位偏移指针"></a>lseek: 定位偏移指针</h1><h1 id="truncate和ftruncate：截短文件"><a href="#truncate和ftruncate：截短文件" class="headerlink" title="truncate和ftruncate：截短文件"></a>truncate和ftruncate：截短文件</h1><h1 id="umask：-在创建期间修改文件权限"><a href="#umask：-在创建期间修改文件权限" class="headerlink" title="umask： 在创建期间修改文件权限"></a>umask： 在创建期间修改文件权限</h1><h1 id="目录导航–getcwd"><a href="#目录导航–getcwd" class="headerlink" title="目录导航–getcwd"></a>目录导航–getcwd</h1><h1 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开目录</span></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dirname)</span></span>;</span><br><span class="line"><span class="comment">//读打开的目录，这个结构体至少有目录的inode和dirName两个成员</span></span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="comment">//关闭打开的目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span></span><br></pre></td></tr></table></figure>
<h1 id="修改目录中的项目"><a href="#修改目录中的项目" class="headerlink" title="修改目录中的项目"></a>修改目录中的项目</h1><ol>
<li>mkdir和rmdir——这些调用的意义与同名命令相同</li>
<li>link和symlink——link创建一个硬链接，symlink创建一个符号链接</li>
<li>unlink——和rm差不多，删除一个普通文件或符号链接，它不会删除目录</li>
<li>rename——和mv一样</li>
</ol>
<h1 id="读取Inode：struct-stat-和-stat"><a href="#读取Inode：struct-stat-和-stat" class="headerlink" title="读取Inode：struct stat 和 stat"></a>读取Inode：struct stat 和 stat</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span>&#123;</span></span><br><span class="line">  <span class="keyword">ino_t</span> st_ino ; <span class="comment">//Inode 编号</span></span><br><span class="line">  <span class="keyword">mode_t</span> st_mode; <span class="comment">//模式(类型和权限)</span></span><br><span class="line">  <span class="keyword">nlink_t</span> st_nlink; <span class="comment">//硬链接数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uid_t</span> st_uid; <span class="comment">//UID(所有者)</span></span><br><span class="line">  <span class="keyword">gid_t</span> st_gid; <span class="comment">//GID(用户组所有者)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">dev_t</span> st_rdev; <span class="comment">//设备ID(用于设备文件)</span></span><br><span class="line">  <span class="keyword">off_t</span> st_size; <span class="comment">//文件大小(字节)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">time_t</span> st_atime; <span class="comment">//最后访问时间</span></span><br><span class="line">  <span class="keyword">time_t</span> st_mtime; <span class="comment">//最后修改时间</span></span><br><span class="line">  <span class="keyword">time_t</span> st_ctime; <span class="comment">//inode 最后修改时间</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">blksize_t</span> st_blksize ; <span class="comment">//IO的优选块大小</span></span><br><span class="line">  <span class="keyword">blkcnt_t</span> st_blocks; <span class="comment">//分配的块数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>stat系统调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fildes, struct stat *buf)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>stat和lstat的第一参数需要路径名，第二参数是一个stat结构的地址（把第一参数下的文件信息以stat结构存放在第二参数中）。stat和lstat的区别是，对于符号链接，stat会沿着符号链接前进：如果，文件foo是链接到bar的(foo-&gt;bar)，那么对foo进行stat操作，<strong>stat会用bar的属性填充stat结构</strong>, 而 <strong>lstat会提取foo的属性</strong>。其他方面，stat和lstat没有区别。lstat更常用。<br>fstat的第一参数是文件说明符，第二参数同样是stat结构地址。  </p>
<h1 id="access：检查实际用户的权限"><a href="#access：检查实际用户的权限" class="headerlink" title="access：检查实际用户的权限"></a>access：检查实际用户的权限</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> amode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一参数是 <strong>路径名</strong>, 第二参数指定了 <strong>要测试的访问权限</strong> 。<br>amode可以取以下4个值：<br>R_OK ——读取权限正常<br>W_OK ——写权限OK<br>X_OK ——执行权限OK<br>F_OK ——文件存在</p>
<h1 id="修改文件属性"><a href="#修改文件属性" class="headerlink" title="修改文件属性"></a>修改文件属性</h1><h2 id="chmod和fchmod：改变文件权限"><a href="#chmod和fchmod：改变文件权限" class="headerlink" title="chmod和fchmod：改变文件权限"></a>chmod和fchmod：改变文件权限</h2><h2 id="chown：改变所有权"><a href="#chown：改变所有权" class="headerlink" title="chown：改变所有权"></a>chown：改变所有权</h2><h2 id="utime：改变时间戳"><a href="#utime：改变时间戳" class="headerlink" title="utime：改变时间戳"></a>utime：改变时间戳</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/22/vim-tutor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/22/vim-tutor/" itemprop="url">vim tutor</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-22T19:14:18+08:00">
                2018-01-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程工具/" itemprop="url" rel="index">
                    <span itemprop="name">编程工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="vim-tutor"><a href="#vim-tutor" class="headerlink" title="vim tutor"></a>vim tutor</h1><p>今天man vim 把vim使用手册祥读了一番，有一些新的发现。<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic5/man-vim.png" alt><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man vimtutor</span><br></pre></td></tr></table></figure></p>
<p><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic5/man-vimtutor.png" alt><br>发现一个tutor文件  </p>
<p>用vim打开这个文件<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic5/vim-vimtutor.png" alt>  </p>
<p>这个tutor概括了一些vim使用方法，概括的简洁明了，很好。  </p>
<p><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic5/vim-tutor-lesson2.png" alt><br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic5/vim-tutor-lesson4.png" alt><br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic5/vim-tutor-lesson5.png" alt><br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic5/vim-tutor-lesson6.png" alt>  </p>
<h1 id="tutor-之外"><a href="#tutor-之外" class="headerlink" title="tutor 之外"></a>tutor 之外</h1><p>“ . “是一个重复命令。<br>“ . “用于重复<font color="orange">输入模式</font>或<font color="orange">命令模式</font>中的命令。<br>例如：<br>4dd删除4行，然后按” . “会继续删除4行；<br>/(查找) , n(查找下一个) , .(重复上一个编辑命令)这三个命令构成了奇妙的三重唱，如：/int(查找int)，用cw替换int输入double，然后按n(查找下一个),再按. ，下一个int直接变成double，不用再用键盘输入double了。</p>
<hr>
<p>ps.<br>vim里有3个操作符(operator)： c(change)，d(delete)，y(yank,copy)<br>操作符常与其他命令(motion)组合使用，常用的motions：<br>$(行末)<br>G(文件末) – d30G删除光标到第30行的内容<br>w(操作一个词)<br>e(end of word,和w差不多)<br>/(操作到第一次匹配到的内容那一行（不包括）) – ?反向  </p>
<p>一个操作符自身重复时（cc，dd，yy），仅对当前行起作用。可prepend数字，以操作多行。  </p>
<hr>
<p>:e FILENAME – （需要保存当前文件，）自动退出文件，打开名为FILENAME的文件  </p>
<p>：r FILENAME – retrieving and mering，可以配合!(ex模式下的exclamation point)，如： “:r !ls -al”  </p>
<p><strong>配置vimrc</strong>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.vimrc</span><br></pre></td></tr></table></figure></p>
<p>添加以下内容：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示行号</span></span><br><span class="line"><span class="built_in">set</span> nu</span><br><span class="line"><span class="comment">#自动语法高亮</span></span><br><span class="line">syntax on</span><br><span class="line"><span class="comment"># 缩进</span></span><br><span class="line"><span class="built_in">set</span> autoindent</span><br><span class="line"><span class="built_in">set</span> smartindent</span><br><span class="line"></span><br><span class="line"><span class="comment">#匹配高亮</span></span><br><span class="line"><span class="built_in">set</span> hlsearch</span><br><span class="line"><span class="comment"># 默认缩进4个空格</span></span><br><span class="line"><span class="built_in">set</span> shiftwidth=4</span><br><span class="line"><span class="comment">#使用tab时 tab空格数</span></span><br><span class="line"><span class="built_in">set</span> softtabstop=4</span><br><span class="line"><span class="comment">#tab 代表4个空格</span></span><br><span class="line"><span class="built_in">set</span> tabstop=4</span><br><span class="line"><span class="comment">#使用空格替换tab</span></span><br><span class="line"><span class="built_in">set</span> expandtab</span><br><span class="line"><span class="comment"># 根据 /usr/share/vim/vim74/colors，更改配色方案，例如：</span></span><br><span class="line">color murphy</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/31/2017-成长/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/31/2017-成长/" itemprop="url">2017-成长</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-31T20:23:23+08:00">
                2017-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/总结/" itemprop="url" rel="index">
                    <span itemprop="name">总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <font color="orange">以中有足乐者, 不知口体之奉不若人也, 盖余之勤切艰若此.       –宋濂</font>  

<p>刚刚我看了 17 年的计划. <strong>不忘初心, 坚持可贵</strong>.<br>最终还是两者都放弃了, 不放弃不一定能有好结果, 但放弃的确 使我很狼狈. 2017 年最终还是走错了一大步.  </p>
<hr>
<p>2017年快要过完了, 90后全部都成年了. 属于90后的青少年的时代已经过去了.<br>不得不承认时间过得太快. 我 18岁 的时候是2013年, 当时上高二. 当时的生活无忧无虑, 喜欢足球, 地下城与勇士, 没有别的想法.   </p>
<p>今年大四, 22岁, 2018 年 7 月份就要毕业了.<br>人生已经到了这个尴尬的年纪, 胸怀理想, 一无所有.  </p>
<hr>
<p>2017年我做了哪些事：<br>1, 写了2017年robocup的TDP, 虽然是生搬硬套的, 虽然很蹩脚, 但是通过了TC的认证, 还是挺开心的.    </p>
<p>2, 准备了6个多月考研, 在8月23号决定放弃了. 这件错误的决定, 从开始就是错误的. 在我准备考研的这段时间, 大鹏拿了物联网大赛的一等奖, 邓勇拿了Robocup 2D技术挑战赛的冠军. 现在大鹏和肖忘生在上海工作, 邓勇在北京. 只有我还在学校.   </p>
<p>3, 谈了一场不靠谱的恋爱.   </p>
<p>4, 在上海找了一个多月的工作. 那些笔试题我应该可以过的.   </p>
<p>5, 毕业设计的题目选了 RoboCup 3D 方向.   </p>
<p>6, 把《c++ primer》(5), 《effective c++》看了一遍, 用 Python 写了两个爬虫.   </p>
<p>一些没有实现的目标：<br>一天一篇博客, 太难实现了. 一个星期一篇或许比较合理.<br>每天两个小时的英语…</p>
<p>找工作失败总结：<br>1, 不知道自己能做什么<br>2, 会的东西太少, 而且不精通<br>3, 不知道 c++ 能做什么<br>4, 基础太菜–只是略懂 c++ , 代码量太少<br>5, <strong><font color="red">归根结底, 实践少, 理论差</font>.</strong>  </p>
<hr>
<p>首先,  现在我在人生的低谷中, 我必须相信一件事, 现在对我个人没有什么可怕的, 所有的不好的结果我都接受了.   </p>
<p>不论生活是多么的糟糕, 还是要为 2018 做一个计划.<br>1, Java<br>2, MySQL<br>3, 掌握网络编程<br>4, 每周至少一篇博客, 每天至少1小时英语<br>5, 找一份工作, 赚点钱, 还mi pro借的钱  </p>
<font color="orange">勿以往之不谏, 知来者之可追. </font>   

<p>既然不喜欢, 那就努力改变.<br>多一点客观, 少点主观.<br>人生短暂, 认准目标, 坚定的走下去就好了.<br>三年, 一个梦想, 别的都不想.   </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/17/No-such-file-or-directory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/17/No-such-file-or-directory/" itemprop="url">No such file or directory</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-17T12:19:28+08:00">
                2017-12-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我已经下载了jdk8(Java SE Development Kit 8u151)，并配置好了环境变量，可是运行java时却提示，找不到文件。<strong>文件确实是存在的，而且不是无效的符号链接文件。用file命令查看文件是可执行的。</strong><font color="orange">这报了一个不该报的错误啊？</font><br><a href="https://stackoverflow.com/questions/9081962/java-is-installed-in-listing-but-execution-produces-java-no-such-file-or-d/9082947#9082947" target="_blank" rel="noopener">网上解决方法： </a><br>说我的Ubuntu运行环境是64位，没有所需要的32位运行环境。没错，是我下载错了，我下载的是x86（<a href="http://download.oracle.com/otn-pub/java/jdk/8u151-b12/e758a0de34e24606bca991d704f6dcbf/jdk-8u151-linux-i586.tar.gz" target="_blank" rel="noopener">32位的jdk</a>），而不是<a href="http://download.oracle.com/otn-pub/java/jdk/8u151-b12/e758a0de34e24606bca991d704f6dcbf/jdk-8u151-linux-x64.tar.gz" target="_blank" rel="noopener">x64</a>。<strong>如果我想在64位Ubuntu上安装32位jdk必须要有32位的环境。</strong>  </p>
<p><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic4/%E6%89%BE%E4%B8%8D%E5%88%B0%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.png" alt><br>但是这样并不能很好的解决问题，在64位Linux系统上安装32位的软件确实是不妥当的。<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic4/%E6%B2%BB%E6%A0%87%E4%B8%8D%E6%B2%BB%E6%9C%AC%E5%95%8A.png" alt><br>可以看出问题换了一种方式存在。  </p>
<p>还是下载x64解压，配置环境变量靠谱。  </p>
<p>还有一种更简单的 源<a href="https://www.cnblogs.com/a2211009/p/4265225.html" target="_blank" rel="noopener">安装</a> 的方式：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install oracle-java8-installer</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/12/面试题8-二叉树的下一个结点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/12/面试题8-二叉树的下一个结点/" itemprop="url">面试题8:二叉树的下一个结点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-12T14:43:58+08:00">
                2017-12-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/剑指offer/" itemprop="url" rel="index">
                    <span itemprop="name">剑指offer</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>题目:</strong><br>给定一颗二叉树和其中一个结点，找出中序遍历序列的下一个结点。<br>二叉树的存储结构为三叉链表，即每个结点除了有指向左右孩子的指针还有指向父结点的指针。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> m_cValue;</span><br><span class="line">  BinaryTreeNode* m_pLeft, * m_pLeft;</span><br><span class="line">  BinaryTreeNode* m_pParent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>分析：</strong><br>如下简图，二叉树的中序遍历序列为<strong>{d, b, h, e, i, a, f, c, g}</strong> 。<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_%E5%89%91%E6%8C%87offer_pic/mianshiti-8-1.png" alt>  </p>
<ol>
<li>如果一个结点有右子树，那么这个结点的下一个结点为其右子树的最左子节点。  </li>
<li>如果一个结点没有右子树，且这个结点是父节点的左孩子结点，那么这个结点的下一个结点是其父结点。  </li>
<li>如果一个结点没有右子树，且这个结点是父节点的右孩子结点。从当前结点出发，找它的父结点，一直找到它的祖宗结点B是祖宗结点A的左孩子，那么祖宗结点A便是下一个结点。（如果有下一个结点的话）<br>假如找 i 的下一个结点，如下图。<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_%E5%89%91%E6%8C%87offer_pic/mianshiti-8-2.png" alt><br>我们可以直接看出 i 的下一个结点是 a ，那么这么找呢？<br>设两个指针即可解决问题。只要pCurrent是pParent的左孩子结点，那么pParent就是下一个结点。<br>如果一直到pParent为空了，还没找到，说明此结点是最后一个结点，不存在下一个结点。  </li>
</ol>
<p><strong>代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">getNext</span><span class="params">(BinaryTreeNode* pNode)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(pNode==<span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  BinaryTreeNode* pNext=<span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span>(pNode-&gt;m_pRight!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    pNext=pNode-&gt;m_pRight;</span><br><span class="line">    <span class="keyword">while</span>(pNext-&gt;m_pLeft!=<span class="literal">nullptr</span>)</span><br><span class="line">      pNext=pNext-&gt;m_pLeft;</span><br><span class="line">    <span class="keyword">return</span> pNext;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;m_pParent!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    BinaryTreeNode* pCurrent=pNode;</span><br><span class="line">    BinaryTreeNode* pParent=pCurrent-&gt;m_pParent;</span><br><span class="line">    <span class="comment">//这个循环条件，退出循环时，要么pParent为空，要么pCurrent是pParent的左孩子</span></span><br><span class="line">    <span class="keyword">while</span>(pParent!=<span class="literal">nullptr</span> &amp;&amp; pParent-&gt;m_pLeft!=pCurrent)&#123;</span><br><span class="line">      pCurrent=pParent;</span><br><span class="line">      pParent=pParent-&gt;m_pParent;</span><br><span class="line">    &#125;</span><br><span class="line">    pNext=pParent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>下面复习一下非递归<strong>中序遍历</strong>（二叉链表存储结构）。<br>再用此图..<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_%E5%89%91%E6%8C%87offer_pic/mianshiti-8-4.png" alt><br><strong>思想:</strong><br>算法从根结点开始：  </p>
<ol>
<li>如果结点不空，循环将结点的左孩子入栈，一直到<strong>最左孩子</strong>的”左空结点”入栈为止；如果结点空，空结点入栈；  </li>
<li>“空结点”出栈；  </li>
<li>如果栈不空，就出栈一个栈顶结点(出栈的结点就是遍历的结点)，同时入栈该结点的右孩子；  </li>
<li>从1开始</li>
</ol>
<p><strong>代码:</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void InOrderTraverse(BinaryTreeNode* T, bool (*visit)(BinaryTreeNode* e))&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;BinaryTreeNode* &gt; sc;</span><br><span class="line">  BinaryTreeNode* p = T;</span><br><span class="line">  sc.push(p);  <span class="comment">//p先入栈--根先入栈</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!sc.empty())&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">      sc.push(p-&gt;m_pLeft);</span><br><span class="line">      p=sc.getTop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sc.pop(); <span class="comment">//空结点出栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!sc.empty())&#123;</span><br><span class="line">      p=sc.getTop();</span><br><span class="line">      visit(p);  <span class="comment">//遍历结点</span></span><br><span class="line">      sc.pop();</span><br><span class="line">      sc.push(p-&gt;m_pRight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/11/面试题7-重建二叉树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/11/面试题7-重建二叉树/" itemprop="url">面试题7:重建二叉树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-11T11:45:44+08:00">
                2017-12-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/剑指offer/" itemprop="url" rel="index">
                    <span itemprop="name">剑指offer</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>题目：</strong><br>输入二叉树的前序遍历和中序遍历的结果，重新构建该二叉树。输入的先序遍历和中序遍历的结果都不含有重复的数字。<br>例如：<br>先序遍历 {1, 2, 4, 7, 3, 5, 6, 8 }<br>中序遍历 {4, 7, 2, 1, 5, 3, 8, 6 }<br>重建后如下图：<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic3/mianshiti-7-1.png" alt><br>二叉树的结点定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> m_nValue;</span><br><span class="line">  BinaryTreeNode* m_pLeft;</span><br><span class="line">  BinaryTreeNode* m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>构建思路：</strong><br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic3/mianshiti-7-3.png" alt><br>淡绿色的结点表示root结点。<br>两个序列都有三个指针。绿色的指针只要有序列首地址和序列的长度得到。<strong>中序遍历</strong> 中的黄色<font color="orange">rootInorder</font>是从startInorder顺序遍历得到的根节点。<br>由rootInorder-startInorder可以得到左子树的长度，由startPreorder和左子树长度可以得到<font color="orange">leftPreorderEnd</font>，<font color="orange">leftPreorderEnd</font>就是<strong>先序遍历</strong>左子树的最后一个结点，在先序遍历序列中有分割左右子树的效果。   </p>
<p>下图是完成第一个结点的构建（根结点，蓝色），开始构建左子树（如果有左子树，这里是浅绿色2），用递归实现。本示例的根结点左孩子，只有左子树没有右子树。递归完成构建左子树，再递归构建右子树（如果有右子树，这里是浅绿色3）。<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic3/mianshiti-7-4.png" alt>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">contruct</span><span class="params">(<span class="keyword">int</span>* preorder, <span class="keyword">int</span>* inorder, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(preorder==<span class="literal">nullptr</span> || inorder==<span class="literal">nullptr</span> || length&lt;=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> contructCore(preorder, preorder+length<span class="number">-1</span>, inorder, inorder+length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">contructCore</span><span class="params">(<span class="keyword">int</span>* startPreorder, <span class="keyword">int</span>* endPreorder, <span class="keyword">int</span>* startInorder, <span class="keyword">int</span>* endInorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//构建根结点</span></span><br><span class="line">  <span class="keyword">int</span> rootValue=startPreorder[<span class="number">0</span>];  <span class="comment">//startPreorder[0]是首地址元素</span></span><br><span class="line">  BinaryTreeNode* root = <span class="keyword">new</span> BinaryTreeNode();</span><br><span class="line">  root-&gt;m_nValue=rootValue;</span><br><span class="line">  root-&gt;m_pLeft=root-&gt;m_pRight=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果这是最后一个结点</span></span><br><span class="line">  <span class="keyword">if</span>(startPreorder==endPreorder)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//先序和中序序列都要检查，而且还要判断这个唯一的结点的值是否相等</span></span><br><span class="line">    <span class="keyword">if</span>(startInorder==endInorder &amp;&amp; *startPreorder==*startInorder)</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">std</span>::exception(<span class="string">"Invalid input"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在中序遍历序列中找rootInorder</span></span><br><span class="line">  <span class="keyword">int</span>* rootInorder=startInorder;</span><br><span class="line">  <span class="keyword">while</span>(rootInorder&lt;endInorder &amp;&amp; *rootInorder!=rootValue)  <span class="comment">//书上是&lt;=</span></span><br><span class="line">    ++rootInorder;</span><br><span class="line">  <span class="keyword">if</span>(rootInorder==endInorder &amp;&amp; *rootInorder!=rootValue)</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::exception(<span class="string">"Invalid input"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在先序遍历序列中找leftPreorderEnd</span></span><br><span class="line">  <span class="keyword">int</span> leftLength = rootInorder - startInorder;</span><br><span class="line">  <span class="keyword">int</span>* leftPreorderEnd = startPreorder + leftLength;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果有左子树，就递归构建左子树</span></span><br><span class="line">  <span class="keyword">if</span>(leftLength&gt;<span class="number">0</span>)</span><br><span class="line">    root-&gt;m_pLeft=contructCore(startPreorder+<span class="number">1</span>,leftPreorderEnd, startInorder,rootInorder<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果有右子树, 左子树长度 一定小于 子树个数</span></span><br><span class="line">  <span class="keyword">if</span>(leftLength&lt;endPreorder-startPreorder)</span><br><span class="line">    root-&gt;m_pRight=contructCore(leftPreorderEnd+<span class="number">1</span>,endPreorder, rootInorder+<span class="number">1</span>,endInorder);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/10/面试题6-从尾到头打印单链表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/10/面试题6-从尾到头打印单链表/" itemprop="url">面试题6:从尾到头打印单链表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-10T15:38:19+08:00">
                2017-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/剑指offer/" itemprop="url" rel="index">
                    <span itemprop="name">剑指offer</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>题目:</strong><br>输入一个单链表的第一个结点(非头结点)，从尾到头打印单链表的每个结点。<br>单链表的结点结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> m_nValue;  <span class="comment">//n表示整型</span></span><br><span class="line">  ListNode * m_pNext;  <span class="comment">//p表示指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>分析:</strong><br>改变顺序，第一个应该想到栈。<br>其次，如果可以改变链表，把链表的指针反向也行。   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printListRevers</span><span class="params">(ListNode* pHead)</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;ListNode* &gt; stack_node;</span><br><span class="line">  ListNode* pNode=pHead;</span><br><span class="line">  <span class="keyword">while</span>(pNode!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    stack_node.push(pNode);</span><br><span class="line">    pNode=pnode-&gt;m_pNext;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!stack_node.empty())&#123;</span><br><span class="line">    pNode=stack_node.top();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;pNode-&gt;m_nValue&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    stack_node.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>递归本质上是一个栈结构</strong>，这题也可以用递归实现。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printListRevers_Recursive</span><span class="params">(ListNode* pHead)</span></span>&#123;</span><br><span class="line">  <span class="comment">//ListNode* pNode=pHead-&gt;m_pNext;</span></span><br><span class="line">  <span class="comment">//if(pNode)&#123;</span></span><br><span class="line">  <span class="comment">//  printListRevers_Recursive(pNode);</span></span><br><span class="line">  <span class="comment">//  std::cout&lt;&lt;pNode-&gt;m_nValue&lt;&lt;std::endl;</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line">  <span class="comment">//以上代码没有考虑递归结束条件pHead==nullptr</span></span><br><span class="line">  <span class="keyword">if</span>(pHead)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead-&gt;m_pNext)&#123;</span><br><span class="line">      printListRevers_Recursive(pHead-&gt;m_m_pNext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;pHead-&gt;m_nValue&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法对比:</strong><br>虽然递归看起来简洁，但是如果链表非常长，就会导致函数调用的层数很深，<strong>可能导致调用函数栈溢出</strong>。显然，用栈循环的代码的鲁棒性更好。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/09/awk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/09/awk/" itemprop="url">awk</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-09T20:37:25+08:00">
                2017-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shell/" itemprop="url" rel="index">
                    <span itemprop="name">shell</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://owencxc.github.io/2016/09/25/awk/" target="_blank" rel="noopener">awk入门</a><br>awk进阶： 在终端tap ‘man awk’  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/09/面试题5-替换空格/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/09/面试题5-替换空格/" itemprop="url">面试题5:替换空格</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-09T18:30:19+08:00">
                2017-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/剑指offer/" itemprop="url" rel="index">
                    <span itemprop="name">剑指offer</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>c风格字符串都是以’\0’结尾的。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[]=<span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">char</span> str2[]=<span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> * str3=<span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">char</span> * str4=<span class="string">"hello world"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(str1)&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="keyword">sizeof</span>(str3)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(str1==str2)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"str1 == str2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"str1 != str2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(str3==str4)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"str3 == str4"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"str3 != str4"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong><br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic3/mianshiti5-string.png" alt><br><strong>结果分析：</strong>  </p>
<ol>
<li>c风格字符串的结尾有一个’\0’，所以str1占<strong>12</strong>个字节，而不是11个。  </li>
<li>str3是指针，所以占8个字节（我是64位Ubuntu）。  </li>
<li>str1和str2数组的首地址不相同，所以 <strong>str1 != str2</strong> 。  </li>
<li>str3和str4<del>地址相同，指向同一个字符串常量，所以 <strong>str3 == str4</strong></del> 。<br>第4点需要纠正一下：<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic3/mianshiti-5-addtion.png" alt><br><font color="orange">看str3和str4的值，str3和str4不是地址！而是字符串！</font>我们的char型指针怎么变成了字符串？而且和c++中的string一样，还可以当成数组处理。<strong>str3和str4里存放的是指针指向的内容–字符串，不是字符串的地址。</strong></li>
</ol>
<p>实际上，数组和指针的存储机制不同。<br> <font color="purple">数组</font>，分配内存，把字符串复制进去<br> <font color="purple">指针</font>，不分配内存，把字符串常量的递增复制为指针值。  </p>
<hr>
<p><strong>题目：</strong><br>实现一个函数，把字符串中的每个空格替换成”%20”。例如，输入“we are happy.”，则输出“we%20are%20happy.”  </p>
<p><strong>分析：</strong><br>这题的思想很简单，一般都能想到。先检查有多少个空格，转换后的字符串会变长（空格本来占一个字节，转换后变成3个字节）。算出转换后的长度，从后往前，把转换前的字符复制到转换后的空间中。<br>把这题写在日志里的原因是，平时在c++中用字符串都是string对象，这里用的是数组。  </p>
<p><strong>代码实现：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceBlank</span><span class="params">(<span class="keyword">char</span> <span class="built_in">string</span>[], <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">string</span>==<span class="literal">nullptr</span> || length&lt;=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> originLength=<span class="number">0</span>; <span class="comment">//字符串原始长度</span></span><br><span class="line">  <span class="keyword">int</span> numberOfBlank=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">string</span>[i]!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">    ++originLength;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">string</span>[i]==<span class="string">' '</span>)</span><br><span class="line">      ++numberOfBlank;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> newLength = originLength + numberOfBlank*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> indexOfOrigin=originLength;</span><br><span class="line">  <span class="keyword">int</span> indexOfNew=newLength;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(indexOfOrigin&gt;indexOfNew &amp;&amp; indexOfOrigin&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">string</span>[indexOfOrigin]==<span class="string">' '</span>)&#123;</span><br><span class="line">      <span class="built_in">string</span>[indexOfNew--]=<span class="string">'0'</span>;</span><br><span class="line">      <span class="built_in">string</span>[indexOfNew--]=<span class="string">'2'</span>;</span><br><span class="line">      <span class="built_in">string</span>[indexOfNew--]=<span class="string">'%'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">string</span>[indexOfNew--]=<span class="built_in">string</span>[indexOfOrigin];</span><br><span class="line">  &#125;</span><br><span class="line">  --indexOfOrigin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/07/栈和队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/07/栈和队列/" itemprop="url">栈和队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-07T11:48:41+08:00">
                2017-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>栈和队列是操作受限的线性表。</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="栈的定义及基本操作"><a href="#栈的定义及基本操作" class="headerlink" title="栈的定义及基本操作"></a>栈的定义及基本操作</h2><p>栈(stack) 是限定仅在表尾进行插入和删除的线性表。<br>对栈来说，表尾称为栈顶(top)，表头称为栈底(bottom)。<br>栈的操作是按后进先出的原则进行的。因此，栈又称为<strong>后进先出</strong>(last in first out)的线性表。（简称LIFO结构）  </p>
<p>插入元素操作称为<strong>入栈</strong>, 删除栈顶元素称为<strong>出栈</strong>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个空栈S</span></span><br><span class="line">initStack(&amp;S)</span><br><span class="line"><span class="comment">//销毁栈S</span></span><br><span class="line">destoryStack(&amp;S)</span><br><span class="line"><span class="comment">//将S清为空栈</span></span><br><span class="line">clearStack(&amp;S)</span><br><span class="line"></span><br><span class="line">stackEmpty(S)</span><br><span class="line">stackLength(S)</span><br><span class="line">getTop(S,&amp;e)</span><br><span class="line"></span><br><span class="line">push(&amp;S,e)</span><br><span class="line">pop(&amp;S,&amp;e)</span><br><span class="line"></span><br><span class="line"><span class="comment">//从栈底到栈顶依次对S的每个数据元素调用visit()函数</span></span><br><span class="line">stackTraverse(S,visit())</span><br></pre></td></tr></table></figure>
<h2 id="栈的表示和实现"><a href="#栈的表示和实现" class="headerlink" title="栈的表示和实现"></a>栈的表示和实现</h2><p>和线性表类似，栈也有两种存储方式：顺序栈和链栈。  </p>
<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><p>顺序栈，用 <strong><em>一组地址连续的存储单元</em></strong> 依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。top=0表示空栈。<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic2/stack-pic.png" alt><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈的顺序存储表示</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  elemType * base, * top;</span><br><span class="line">  <span class="keyword">int</span> stackSize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">  elemType S.base=(elemType * )<span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="keyword">sizeof</span>(elemType));</span><br><span class="line">  <span class="comment">//存储空间分配失败</span></span><br><span class="line">  <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">  S.top=S.base;</span><br><span class="line">  S.stackSize=STACK_INIT_SIZE;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTop</span><span class="params">(SqStack S, elemType &amp;e)</span></span>&#123;</span><br><span class="line">  <span class="comment">//栈是否为空</span></span><br><span class="line">  <span class="keyword">if</span>(S.top==S.base)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  e=* (--S.top);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*和顺序表, 链表类似*/</span></span><br><span class="line"><span class="comment">//入栈出栈，和链栈不同，顺序栈分配到的存储空间是连续的，</span></span><br><span class="line"><span class="comment">//顺序栈都是批量分配内存，初始化100，增量10</span></span><br><span class="line"><span class="comment">//删除也不会(不能)删除一个元素空间</span></span><br><span class="line"><span class="comment">//而链栈的每个结点都要独立分配和回收</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(SqStack &amp;S, elemType e)</span></span>&#123;</span><br><span class="line">  <span class="comment">//栈满,top和base指针的差是 栈的元素个数</span></span><br><span class="line">  <span class="keyword">if</span>(S.top-S.base&gt;=S.stackSize)&#123;</span><br><span class="line">    S.base=(elemType * )ralloc(S.base,(S.stackSize+STACK_INCREMENT)* <span class="keyword">sizeof</span>(elemType));</span><br><span class="line">    <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    S.top=S.base+S.stackSize;  <span class="comment">//top可能变了</span></span><br><span class="line">    S.stackSize+=STACK_INCREMENT;</span><br><span class="line">  &#125;</span><br><span class="line">  * S.top++=e;  <span class="comment">//* S.top=e; S.top++;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(SqStack &amp;S, elemType &amp;e)</span></span>&#123;</span><br><span class="line">  <span class="comment">//栈空</span></span><br><span class="line">  <span class="keyword">if</span>(S.top==S.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  e=* --S.top;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">destoryStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">  S.top=S.base;</span><br><span class="line">  <span class="built_in">free</span>(S.base);</span><br><span class="line">  S.stackSize=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><p><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic2/link-stack-pic.png" alt><br>链栈操作是单链表的操作的特例，可以参考<a href="https://mitrecx.github.io/2017/12/05/%E7%BA%BF%E6%80%A7%E8%A1%A8/#%E5%8D%95%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">单链表</a>，这里不在详述。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">  elemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;Node, * <span class="built_in">stack</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="数制转换"><a href="#数制转换" class="headerlink" title="数制转换"></a>数制转换</h3><p>十进制数转换成d进制数，有一个通用的算法。<br>例如转换成二进制：<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/IMG_20171207_124610.jpg" alt><br>十进制转八进制代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里输出到标准输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">conversion</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">  SqStack S;</span><br><span class="line">  initStack(S);</span><br><span class="line">  <span class="keyword">while</span>(N)&#123;</span><br><span class="line">    push(S,N%<span class="number">8</span>);</span><br><span class="line">    N/=<span class="number">8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> e;</span><br><span class="line">  <span class="keyword">while</span>(!stackEmpty(S))&#123;</span><br><span class="line">    pop(S,e);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="括号匹配的检验"><a href="#括号匹配的检验" class="headerlink" title="括号匹配的检验"></a>括号匹配的检验</h3><p>如果是( [ {就入栈，遇到右括号就出栈相匹配的左括号，如果不匹配退出程序返回false；如果都匹配最后栈为空，返回true。   </p>
<h3 id="行编辑程序"><a href="#行编辑程序" class="headerlink" title="行编辑程序"></a>行编辑程序</h3><p>用’#’表示退格符，表示前一个字符无效；用’@’表示退行符，表示当前行无效。<br>例如：<br><strong>wh</strong>li##<strong>il</strong>r#<strong>e(</strong>s#<strong> * s)</strong><br>outcha@<strong>putchar(* s</strong>=# <strong>++)</strong><br>实际效果如下：<br>while(<em> s)<br>putchar(</em> s++)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lineEdit</span><span class="params">()</span></span>&#123;</span><br><span class="line">  SqStack S;</span><br><span class="line">  initStack(S);</span><br><span class="line">  <span class="keyword">char</span> ch,cPop;</span><br><span class="line">  ch=getchar();</span><br><span class="line">  <span class="keyword">while</span>(ch!=EOF)&#123; <span class="comment">//EOF为文件结束符，Linux里是Ctrl+D</span></span><br><span class="line">    <span class="keyword">while</span>(ch!=EOF &amp;&amp; ch!=<span class="string">'\n'</span>)&#123;</span><br><span class="line">      <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'#'</span>: pop(S,cPop);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'@'</span>: clearStack(S);<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: push(S,ch);<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*******</span></span><br><span class="line"><span class="comment">    对栈中的元素进行处理</span></span><br><span class="line"><span class="comment">    *******/</span></span><br><span class="line">    clearStack(S);</span><br><span class="line">    <span class="keyword">if</span>(ch!=EOF)</span><br><span class="line">      ch=getchar();</span><br><span class="line">  &#125;</span><br><span class="line">  destoryStack(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="栈的其他应用"><a href="#栈的其他应用" class="headerlink" title="栈的其他应用"></a>栈的其他应用</h3><p>迷宫求解<br>表达式求值<br><a href="http://www.cnblogs.com/hapjin/p/5758083.html" target="_blank" rel="noopener">出栈顺序和卡特兰数</a>  </p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列(queue) 是一种先进先出(First In First Out)的线性表。<br>队头(front)只允许出队操作；<br>队尾(rear)只允许入队操作。  </p>
<h2 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h2><p>用链表表示队列<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic2/link-queue-pic.png" alt><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">  elemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;QNode, * QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  QueuePtr front,rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">  QueuePtr front,rear;</span><br><span class="line">  front=rear=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">  <span class="keyword">if</span>(!front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  Q.front-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">destoryQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">  <span class="comment">//从头结点开始，然后队头到队尾逐一删除</span></span><br><span class="line">  <span class="keyword">while</span>(Q.front)&#123;</span><br><span class="line">    Q.rear=Q.front-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(Q.front);</span><br><span class="line">    Q.front=Q.rear;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(LinkQueue &amp;Q, elemType e)</span></span>&#123;</span><br><span class="line">  QueuePtr p;</span><br><span class="line">  p=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">  p-&gt;data=e;</span><br><span class="line">  p-&gt;next=<span class="literal">nullptr</span>; Q.rear-&gt;next=p;</span><br><span class="line">  Q.rear=p <span class="comment">//不要忘了</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">(LinkQueue &amp;Q, elemType &amp;e)</span></span>&#123;</span><br><span class="line">  <span class="comment">//if(!Q.front-&gt;next)  return false;</span></span><br><span class="line">  <span class="comment">/*应该这样判断*/</span></span><br><span class="line">  <span class="keyword">if</span>(Q.front==Q.rear)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  QueuePtr p=Q.front-&gt;next;</span><br><span class="line">  e=p-&gt;data;</span><br><span class="line">  Q.front-&gt;next=p-&gt;next;</span><br><span class="line">  <span class="comment">//free(p); 要先判断出队的元素是否是队尾元素</span></span><br><span class="line">  <span class="comment">//如果是队尾元素，需要重新设置队尾指针</span></span><br><span class="line">  <span class="keyword">if</span>(p==Q.rear) Q.rear=Q.front;</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>循环队列便是队列的顺序存储方式。这种方式必须是循环的。如果不循环，前面队头出队的空间就无法再利用了，队列的空间很快会被“用完”，实际上队列可能很空。<br>下图是未满的循环队列：<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic2/sq-queue-pic.png" alt><br>下图是满的顺序队列<br> 队列满的条件为 (Q.rear+1)%MAXSIZE==Q.front<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic2/sq-queue-pic-full-2.png" alt><br>注： <strong>这里少用一个元素的空间</strong>，用队头指针在队尾指针的下一个位置表示队列满。  </p>
<hr>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------循环队列 --队列的顺序存储结构----</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">elemType * base;  <span class="comment">//初始化的冬天存储空间</span></span><br><span class="line"><span class="keyword">int</span> front;  <span class="comment">//头指针，队列不空，指向队列头元素</span></span><br><span class="line"><span class="keyword">int</span> rear;  <span class="comment">//尾指针，队列不空，指向队列尾元素的下一个位置</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line"><span class="comment">//Q.base=(elemType * )malloc(MAXSIZE * sizeof(SqQueue));</span></span><br><span class="line">  Q.base=(elemType * )<span class="built_in">malloc</span>(MAXSIZE * <span class="keyword">sizeof</span>(elemType));</span><br><span class="line">  <span class="keyword">if</span>(Q.base) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">  Q.front=Q.rear=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queueLength</span><span class="params">(<span class="keyword">const</span> SqQueue * Q)</span></span>&#123;</span><br><span class="line">  <span class="comment">//return abs(Q.rear-Q.front); 这样可以的</span></span><br><span class="line">  <span class="keyword">return</span> (Q.rear-Q.front+MAXSIZE)%MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(SqQueue &amp;Q,elemType e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MAXSIZE==Q.front) <span class="comment">//队满</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Q.base[Q.rear++]=e;</span></span><br><span class="line">  Q.base[Q.rear]=e;</span><br><span class="line">  Q.rear=(Q.rear+<span class="number">1</span>)%MAXSIZE;  <span class="comment">//注意循环！</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">(SqQueue &amp;Q,elemType &amp;e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(Q.front==Q.rear) <span class="comment">//队空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  e=Q.base[Q.front];</span><br><span class="line"><span class="comment">//Q.front=(Q.front-1)%MAXSIZE;</span></span><br><span class="line">  Q.front=(Q.front+<span class="number">1</span>)%MAXSIZE;  <span class="comment">//不会减一的！见最后一张图</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对deQueue代码的理解<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic2/sq-queue-understand.png" alt></p>
<h1 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h1><p>双端队列(deque)只允许在线性表的两端进行插入和删除，双端队列看似比栈和队列灵活，但实际运用远不及栈和队列。  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/06/面试题3：数组中重复的数字/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/06/面试题3：数组中重复的数字/" itemprop="url">面试题3：数组中重复的数字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-06T18:23:30+08:00">
                2017-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/剑指offer/" itemprop="url" rel="index">
                    <span itemprop="name">剑指offer</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目1-找出数组中重复的数字"><a href="#题目1-找出数组中重复的数字" class="headerlink" title="题目1: 找出数组中重复的数字"></a>题目1: 找出数组中重复的数字</h1><p>在一个长度为n的数组中，数组中的数字都在0～n-1之间。数组中可能有重复的数字，也可能没有，如果有的话，找出数组中任意一个数字。  </p>
<p>例如：{2,1,3,0,5,2,3}，找出2或3即可。  </p>
<hr>
<p>我的想法：先用快排排序，然后找重，这样可以找出所有的重复的数字。<br>时间复杂度为O(nlogn)。  </p>
<hr>
<p>书上给出一个巧妙的解法，他的思想是：数组中的数字的范围是在数组的长度之内的。那么我们可以调整数组，把数组的元素值和位置对应起来。如果值和位置一一对应，则无重复元素；如果位置有多个值，则这个位置就是一个重复的数。  </p>
<p>例如：{2,1,3,0,5,2,3}，假设数组a[7]<br>a[0]==2, a[2]!=2, 可交换，把a[0]换到a[2]上：{3,1,<font color="orange">2</font>,0,5,2,3}<br>a[0]==3, a[3]!=3, 可交换，把a[0]换到a[3]上： {0,1,<font color="orange">2</font>,<font color="orange">3</font>,5,2,3}<br>a[0]==0, ok: {<font color="orange">0</font>,1,<font color="orange">2</font>,<font color="orange">3</font>,5,2,3}<br>a[1]==1, ok: {<font color="orange">0</font>,<font color="orange">1</font>,<font color="orange">2</font>,<font color="orange">3</font>,5,2,3}<br>a[2]==2, ok:<br>a[3]==3, ok:<br>a[4]==5, a[5]!=5, 可交换，把a[4]和a[5]交换：{<font color="orange">0</font>,<font color="orange">1</font>,<font color="orange">2</font>,<font color="orange">3</font>,2,<font color="orange">5</font>,3}<br>a[4]==2, a[2]==2, <strong><em>不可交换</em></strong>，2重复了</p>
<p>代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findOneDuplication</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span></span>&#123;</span><br><span class="line">  <span class="comment">//数组为空，或数组长度不合法</span></span><br><span class="line">  <span class="keyword">if</span>(numbers==<span class="literal">nullptr</span> || length&lt;=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//检查数组的元素是否合要求</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers[i]&lt;<span class="number">0</span> || numbers[i]&gt;=length)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; ++i)&#123;</span><br><span class="line">    <span class="comment">//当此位置和值不相等，判断是否可交换。</span></span><br><span class="line">    <span class="comment">//不可交换，即找到重复元素。可交换，执行交换操作。</span></span><br><span class="line">    <span class="keyword">while</span>(numbers[i]!=i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(numbers[i]==numbers[numbers[i]])&#123;</span><br><span class="line">        * duplication=numbers[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> temp=numbers[i];</span><br><span class="line">      numbers[i]=numbers[temp];</span><br><span class="line">      numbers[temp]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//刚好位置和值一一对应，没有找到重复的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此算法的时间复杂度为O(n);<br>虽然有一个二重循环，但是这个二重循环的内层循环是交换操作，如果不需要交换，那么内层循环不执行；如果交换，那么后来需要执行的内层循环就少一次。总的时间复杂度为O(n)。</p>
<hr>
<h1 id="题目2：找出数组中重复的数字-不修改数组"><a href="#题目2：找出数组中重复的数字-不修改数组" class="headerlink" title="题目2：找出数组中重复的数字(不修改数组)"></a>题目2：找出数组中重复的数字(不修改数组)</h1><p>注：与题目1不同，此题必有重复元素！<br>在一个长度为n+1的整型数组中，数组元素值都在1～n之间。<strong><em>所以至少有一个数字是重复的</em></strong>，找出数组中任意一个重复的数字。</p>
<p>例如：{1, 2, 2, 3, 4, 5, 6, 7}   设为数组a[8]，算法实现找出2</p>
<hr>
<p>这题当然也可以用快排排序，然后找出所有重复的数字。但是不能修改数组，这会使得不仅时间复杂度为O(nlogn)，还多出空间复杂度S(n)。</p>
<hr>
<p>书上解法利用了必有一个重复的数字这一特点。<br>例如：{5, 3, 1, 2, 2, 4, 7, 6 }   设为数组a[8]<br>思路：<br>这个长度为8的数组，所有数字都在<strong>数字区间</strong>1～7之间。中间的数字4把1~7分两段，一段1~4，一段5~7。接下来统计1~4这一段中出现数字的个数为5，<strong>说明有重复的</strong>。再把1~4分两段，1~2和3~4。1~2数字个数为3，说明有重复的。再把1~2分两段，1~1和2~2。1~1数字个数为1，无重复；2~2数字个数为2，2重复了。<br>这种思想和 <strong><em>二分查找</em></strong> 有些类似。  </p>
<p>代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getOneDuplication</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* numbers, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">  <span class="comment">//如果数组不合法，返回-1</span></span><br><span class="line">  <span class="keyword">if</span>(numbers==<span class="literal">nullptr</span> || length &lt;=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">//数字区间为start~end</span></span><br><span class="line">  <span class="keyword">int</span> start=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> end=length<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(end&gt;=start)&#123;</span><br><span class="line">    <span class="keyword">int</span> middle=((end-start)&gt;&gt;<span class="number">1</span>)+start; <span class="comment">//有符号负数右移位要注意，这里是正数不用担心。</span></span><br><span class="line">    <span class="keyword">int</span> count=countRange(numbers, length, start, middle);</span><br><span class="line">    <span class="keyword">if</span>(end==start)&#123;</span><br><span class="line">      <span class="keyword">if</span>(count&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count&gt;(middle-start+<span class="number">1</span>))</span><br><span class="line">      end=middle;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      start=middle+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">  <span class="comment">//这里可以不用判断数组为空，长度不合法</span></span><br><span class="line">  <span class="comment">//if(numbers==nullptr || length&lt;0)</span></span><br><span class="line">  <span class="comment">//  exit(1);</span></span><br><span class="line">  <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers[i]&gt;=start &amp;&amp; numbers[i]&lt;=end)</span><br><span class="line">      count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此算法能找到重复的，但是不能找到所有的重复的数字。<br>时间复杂度为O(nlogn)。<br>countRange被调用了O(logn)次，每次需要O(n)的时间。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/05/线性表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/05/线性表/" itemprop="url">线性表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-05T18:30:32+08:00">
                2017-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>写在前面：<br>数据结构（data structure）是相互之间存在一种或多种特定关系的数据<strong>元素的集合</strong>。<br>元素之间的关系称为结构。<br>4类基本结构：  </p>
<ol>
<li>集合，数据元素除了“同属一个集合”之外，别无其他关系。  </li>
<li>线性结构，数据元素之间存在一个对一个的关系。</li>
<li>树形结构，一对多。</li>
<li>图状结构，多对多。  </li>
</ol>
<p>内容为看书总结《数据结构（严蔚敏）》。  </p>
<h1 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a>线性表的类型定义</h1><p>线性表，栈和队列，串，均为线性结构。<br>线性结构特点：  </p>
<ol>
<li>存在第一个数据元素</li>
<li>存在最后一个数据元素</li>
<li>除了第一个数据元素外，每个数据元素只有一个前驱</li>
<li>除了最后一个，每个数据元素只有一个后继  </li>
</ol>
<p>线性表的基本操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个空的线性表L</span></span><br><span class="line">InitList(&amp;L)</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁线性表L</span></span><br><span class="line">DestroyList(&amp;L)</span><br><span class="line"></span><br><span class="line"><span class="comment">//重置L为空表</span></span><br><span class="line">ClearList(&amp;L)</span><br><span class="line"></span><br><span class="line">ListEmpty(L)</span><br><span class="line">ListLength(L)</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回第一个与e满足compare的数据元素的位序，不存在返回0</span></span><br><span class="line">LocateElem(L,e,compare())</span><br><span class="line"></span><br><span class="line"><span class="comment">//用e返回L中第i个数据元素的值</span></span><br><span class="line">GetElem(L,i,&amp;e)</span><br><span class="line"></span><br><span class="line">ListInsert(&amp;L,i,e)</span><br><span class="line">ListDelete(&amp;L,i,&amp;e)</span><br><span class="line"></span><br><span class="line"><span class="comment">//依次对L的每个数据元素调用visit()，一旦visit()失败，则操作失败</span></span><br><span class="line">ListTraverse(L,visit())</span><br></pre></td></tr></table></figure></p>
<p><strong><em> 实现A=AUB：</em></strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(List &amp;La,List &amp;Lb)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> La_len=ListLength(La);</span><br><span class="line">  <span class="keyword">int</span> Lb_len=ListLength(Lb);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=Lb_len; ++i)&#123;</span><br><span class="line">    GetElem(Lb,i,e);</span><br><span class="line">    <span class="keyword">if</span>(!LocateElem(La,e,equal))</span><br><span class="line">      ListInsert(La, ++La_len, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em> 合并两个非递减的线性表La, Lb: </em></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(List La, <span class="built_in">list</span> Lb, List &amp;Lc)</span></span>&#123;</span><br><span class="line">  InitList(Lc);</span><br><span class="line">  <span class="keyword">int</span> i=j=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> La_len=ListLength(La), Lb_len=ListLength(Lb);</span><br><span class="line">  <span class="keyword">while</span>((i&lt;=La_len)&amp;&amp;(j&lt;=Lb_len))&#123;</span><br><span class="line">    <span class="keyword">int</span> ai, bj;</span><br><span class="line">    GetElem(La, i, ai);</span><br><span class="line">    GetElem(Lb, j, bj);</span><br><span class="line">    <span class="keyword">if</span>(ai&lt;=bj)&#123;</span><br><span class="line">      ListInsert(Lc, ++k, ai);</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      ListInsert(Lc, ++k, bj);</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i&lt;=La_len) &#123;</span><br><span class="line">    <span class="keyword">int</span> ai;</span><br><span class="line">    GetElem(La, i++, ai);</span><br><span class="line">    ListInsert(Lc, ++k, ai);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (j&lt;=Lb_len) &#123;</span><br><span class="line">    <span class="keyword">int</span> bj;</span><br><span class="line">    GetElem(Lb, j++, bj);</span><br><span class="line">    ListInsert(Lc, ++k, bj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h1><p>线性表的顺序表示：用一组地址连续的存储单元依次存储线性表的数据元素。<br>假设线性表的每个元素占l个存储单元：<br>LOC( a<sub>i+1</sub> )=LOC( a<sub>i</sub> )+l  </p>
<p>LOC( a<sub>i</sub> )=LOC( a<sub>1</sub> )+(i-1)* l      </p>
<p>下面给出的存储结构是一个c语音中的结构体。在出c++中，这就是一个类，初始化函数就是类的构造函数。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线性表的的动态分配 顺序存储结构</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT 10  <span class="comment">//存储空间分配增量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ELemType * elem;   <span class="comment">//存储空间基址</span></span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">  <span class="keyword">int</span> listSize;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个空的线性表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList_Sq</span><span class="params">(SqList &amp;l)</span></span>&#123;</span><br><span class="line">  L.elem=(ElemType * )<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line"><span class="keyword">if</span>(!L.elem) <span class="built_in">exit</span>(OVERFLOW);  <span class="comment">//存储空间分配失败</span></span><br><span class="line">L.length=<span class="number">0</span>;</span><br><span class="line">L.listSize=LIST_INIT_SIZE;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在顺序线性表L的第i个位置之前插入新的元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ELemType e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>)  <span class="comment">//插入位置i不合法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(L.length&gt;=L.listSize)&#123;  <span class="comment">//当前存储空间已满</span></span><br><span class="line">    ELemType * newBase=(ElemType * )<span class="built_in">realloc</span>(L.elem, (L.listSize+LISTINCREMENT)* <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span>(!newBase) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L.elem=newBase;</span><br><span class="line">    L.listSize += LISTINCREMENT;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> * q=&amp;(L.elem[i<span class="number">-1</span>]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> *p=&amp;(L.elem[L.length<span class="number">-1</span>]); p&gt;=q; --p)</span><br><span class="line">    * (p+<span class="number">1</span>) = * p ;</span><br><span class="line">  * q = e;</span><br><span class="line">  ++L.length; <span class="comment">//表长增1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>realloc(void * __ptr , size_t __size)</strong> ： 更改已经配置的内存空间，即更改由malloc()函数分配的内存空间的大小。<br>如果是将分配的内存扩大，则有以下情况：<br>1）如果当前内存段后面有需要的内存空间，则直接扩展这段内存空间，realloc()将返回原指针。<br>2）如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，<strong>将目前的数据复制到新的位置</strong>，并将原来的数据块释放掉，返回新的内存块位置。<br>3）如果申请失败，将返回NULL，此时，原来的指针仍然有效。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在顺序线性表中删除第i个元素，并用e返回其值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>((i&lt;<span class="number">1</span>)||(i&gt;L.ListLength))  <span class="comment">//删除位置i不合法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">int</span> * p = &amp;(L.elem[i<span class="number">-1</span>]);</span><br><span class="line">  e = * p;</span><br><span class="line">  q = L.elem+L.length<span class="number">-1</span>; <span class="comment">//表尾元素的位置</span></span><br><span class="line">  <span class="keyword">for</span>(++p; p&lt;=q; ++p)</span><br><span class="line">    * (p<span class="number">-1</span>) = * p;</span><br><span class="line">  --L.length;  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h1><p>线性表的顺序存储结构的特点是：逻辑上相邻的两个元素在物理位置上也相邻。优点是可以随机存取元素(按位序)；缺点是插入删除需要移动大量元素。<br>链式存储结构的特点是用一组<strong>任意的</strong>存储单元存储数据元素(不要求连续)。  </p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>单链表(线性链表):一个结点(node)包括一个数据域和一个指针域。<br>下图为带头结点的单链表：<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic2/liner-table2.png" alt><br>L是LinkList型的变量，是单链表的头指针。若单链表为空表，则头结点的指针域为空（L-&gt;next==NULL），<strong><em>头结点的指针域存储指向第一个结点的指针</em></strong>。<br>下图为带头结点的空表：<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic2/linklist3.png" alt>  </p>
<p>如果不带头结点，L==NULL表示空表。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线性表的单链表存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, * LinkList;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逆序输入n个元素值，建立带头结点的单链表L</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creatList_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="comment">//生成新结点</span></span><br><span class="line">                LinkList p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; data;</span><br><span class="line">                p-&gt;data = data;</span><br><span class="line">                p-&gt;next = L-&gt;next;</span><br><span class="line">                L-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从带头结点的单链表L中，取第i个元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getElem_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">  LinkList p=L-&gt;next; <span class="comment">//p指向第一个结点</span></span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">1</span>;  <span class="comment">//j为计数器</span></span><br><span class="line">  <span class="keyword">while</span>(p &amp;&amp; j&lt;i)&#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">    ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!p || j&gt;i)  <span class="comment">//第i个元素不存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  e=p-&gt;data;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个简单的插入元素操作，却是单链表的<strong><em>重点</em></strong>。一个是寻找第i-1个结点，一个是插入操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在带头结点的单链表L中第i个位置之前插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">listInsert_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">  LinkList p=L;  <span class="comment">//p表示第i-1位置的结点</span></span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">0</span>;  <span class="comment">//j表示第i之前的那个位置，j=i-1</span></span><br><span class="line">  <span class="keyword">while</span>(p &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">    ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!p || j&gt;i<span class="number">-1</span>)  <span class="comment">//i&lt;1或i大于表长+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  s=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">  s-&gt;data=e;  s-&gt;next=p-&gt;next;</span><br><span class="line">  p-&gt;next=s;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们一般的想法是先检查插入位置是否合法,再找第i-1个位置</span></span><br><span class="line"><span class="comment">//本算法很巧妙</span></span><br></pre></td></tr></table></figure></p>
<p>删除依然巧妙，应该掌握这种方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除带头结点单链表中的第i个元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">listDelete_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">  LinkList p=L;</span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">//寻找第i个结点，并令p指向其前驱</span></span><br><span class="line">  <span class="keyword">while</span>(p-&gt;next &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">    ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!(p-&gt;next) || (j&gt;i<span class="number">-1</span>))  <span class="comment">//删除位置不合理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  q=p-&gt;next;  p-&gt;next=q-&gt;next;</span><br><span class="line">  e=q-&gt;data;</span><br><span class="line">  <span class="built_in">free</span>(q);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p>静态链表：用一维数组描述单链表（线性链表）。<br>平时很少用。<br>静态链表示例：<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic2/static-link-list.png" alt><br>插入删除主要改变cur。这里i=S[i].cur相当于p=p-&gt;next。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线性表的静态单链表 存储结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="keyword">int</span> cur;  <span class="comment">//cursor游标</span></span><br><span class="line">&#125;component,SLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个静态链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_SL</span><span class="params">(SLinkList &amp;space)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXSIZE; ++i)</span><br><span class="line">    space[i].cur=i+<span class="number">1</span>;</span><br><span class="line">  space[MAXSIZE<span class="number">-1</span>].cur=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在静态单链表L中查找第一个值为e的元素</span></span><br><span class="line"><span class="comment">//找到返回它在L中的位序，否则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">locateElem_SL</span><span class="params">(SLinkList S, ELemType e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=S[<span class="number">0</span>].cur;</span><br><span class="line">  <span class="keyword">while</span>(i &amp;&amp; S[i].data!=e)</span><br><span class="line">    i=S[i].cur;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表(circular linked list)和单链表操作基本一致，只是最后一个结点的指针域指向头结点。差别只是<strong><em>循环条件不是p或p-&gt;next是否为空，而是它们是否等于头指针</em></strong></p>
<p><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic2/circular-linked-list.png" alt></p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表(double linked list)：克服了单链表单项的缺点。双向链表有两个指针域，一个指向直接前驱，一个指向直接后继。<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic2/dulinklist.png" alt><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线性表的双向链表 存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> * <span class="title">prior</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;DuLNode, * DuLinkList</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在带头结点的双链循环线性表L中，第i个位置前插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">listInsert_DuL</span><span class="params">(DuLinkList &amp;L, <span class="keyword">int</span> i, ELemType e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!(DuLinkList p=getElemP_DuL(L,i)))  <span class="comment">//在p结点前插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>( !(DuLinkList s=(DuLinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuLNode) )) )</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  s-&gt;data=e;</span><br><span class="line">  s-&gt;prior=p-&gt;prior;  p-&gt;prior-&gt;next=s;</span><br><span class="line">  s-&gt;next=p;  p-&gt;prior=s;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由位置i 得到指向该位置之前(i-1)的结点指针</span></span><br><span class="line"><span class="function">DuLinkList <span class="title">getElem_DuL_before</span><span class="params">(DuLinkList &amp;L, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;listLength+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  DuLinkList p=L;</span><br><span class="line">  <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(j&lt;i)&#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">    ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/04/上海求职总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/04/上海求职总结/" itemprop="url">上海求职总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-04T11:36:26+08:00">
                2017-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/总结/" itemprop="url" rel="index">
                    <span itemprop="name">总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2017年10月18号，我和大鹏来到上海。大鹏找PHP，我找C++软件研发。<br>两周后，大鹏上班了。<br>今天已经12月4号了，过去了47天。不得不承认，自己实力太弱，这么长时间还是没有找到工作。<br>现在要回合肥了，和我之前的计划完全不同。  </p>
<p>是我高估了自己，我必须要接受这个结果！</p>
<p>现在想想我过去的思考，其实并没有错.<br>但是如果我一无所有还在纸上谈兵就大错特错了。  </p>
<p>努力去改变现状，现状实在太糟了。<br>最糟的是我自己无法反驳任何人，确实是我自己的问题。</p>
<hr>
<p>漫无目的只会一天一天地消磨时间, 一步一步走向冢中枯骨.  </p>
<p>要想要自由，想摆脱束缚.<br>加油吧. MITRE.  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/03/Practice-makes-perfect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/03/Practice-makes-perfect/" itemprop="url">Practice makes perfect</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-03T18:15:33+08:00">
                2017-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/总结/" itemprop="url" rel="index">
                    <span itemprop="name">总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Deliberate practice entails (needs) more than simply repeating a task.<br>Rather,<br>it involves setting specific goals,<br>obtaining immediate feedback and concentrating as much on technique as on outcome.<br>(将注意力集中在技术和结果上)  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/02/差距/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/02/差距/" itemprop="url">差距</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-02T17:49:48+08:00">
                2017-12-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/总结/" itemprop="url" rel="index">
                    <span itemprop="name">总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>①当你在想玩什么，有人在想学什么  –时间</li>
<li>②当你在做计划，有人已出发  –执行</li>
<li>③当你为上次的失败沮丧，有人已开始下次尝试  –心态</li>
<li>④当你决定放弃，有人坚信前进就有希望。  –信念</li>
</ul>
<p>那些比你走的远的人，并不一定比你聪慧，只是每天多走了一点。  </p>
<hr>
<p>坚持，是最强大的力量。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/01/linux环境变量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/01/linux环境变量/" itemprop="url">Linux环境变量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-01T16:07:55+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-什么是环境变量"><a href="#1-什么是环境变量" class="headerlink" title="1 什么是环境变量"></a>1 什么是环境变量</h1><p>bash shell用一个叫做<font color="green">环境变量(environment variable)</font>的特性来存储有关shell会话和工作环境的信息。</p>
<p>在bash shell中，环境变量有两种：全局变量，局部变量。</p>
<h2 id="1-1-全局环境变量"><a href="#1-1-全局环境变量" class="headerlink" title="1.1 全局环境变量"></a>1.1 全局环境变量</h2><p>全局变量会作用于进程的所有 子shell。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看全局变量 env 或 printenv</span></span><br><span class="line">env</span><br><span class="line"><span class="comment">#显示变量的值</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$HOME</span></span><br><span class="line"><span class="comment">#使用</span></span><br><span class="line">ls <span class="variable">$HOME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义全局变量用 export</span></span><br><span class="line"><span class="built_in">export</span> hellow=1</span><br><span class="line">env | grep hello</span><br></pre></td></tr></table></figure></p>
<h2 id="1-2-局部环境变量"><a href="#1-2-局部环境变量" class="headerlink" title="1.2 局部环境变量"></a>1.2 局部环境变量</h2><p>局部变量只能在定义它们的进程中可见。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#没有命令可以直接查看局部变量</span></span><br><span class="line"><span class="comment">#set 会显示所有环境变量(局部，全局)和用户定义变量</span></span><br><span class="line"><span class="built_in">set</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义局部变量直接赋值即可</span></span><br><span class="line">whello=2</span><br><span class="line"><span class="built_in">set</span> | grep hello</span><br></pre></td></tr></table></figure></p>
<h2 id="1-3-小结"><a href="#1-3-小结" class="headerlink" title="1.3 小结"></a>1.3 小结</h2><p>可以在bash shell终端中直接设置自己的变量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置一个局部环境变量</span></span><br><span class="line">my_variable=<span class="string">"hello world"</span></span><br><span class="line"><span class="comment">#把局部变量变成全局变量</span></span><br><span class="line"><span class="built_in">export</span> my_variable</span><br><span class="line"><span class="comment">#也可以直接 export my_variable2="don't panic"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除my_variable</span></span><br><span class="line"><span class="built_in">unset</span> my_variable</span><br></pre></td></tr></table></figure></p>
<p><strong><font color="red">以上设置的环境变量都是临时的，一旦重启电脑，就会失效。</font></strong><br><strong>设置永久环境变量需要在 <a href="#title2-2-1">登录shell</a> 中设置。另参见 <a href="#title2-3">环境变量的持久化</a></strong>  </p>
<p>注意：<br>在子shell中修改全局变量的值，只在子shell中有效，在全局中，全局变量不会被改变。<br>在子shell中删除全局变量，同样只对子shell有效。</p>
<h1 id="2-系统环境变量"><a href="#2-系统环境变量" class="headerlink" title="2 系统环境变量"></a>2 系统环境变量</h1><h2 id="2-1-PATH"><a href="#2-1-PATH" class="headerlink" title="2.1 PATH"></a>2.1 PATH</h2><p>当在shell命令行输入一个外部命令时，shell必须搜索系统找到对应的程序。PATH环境变量<strong>定义了用于进行命令和程序查找的目录</strong>。<br>可以修改PATH，加入新的程序的位置。<br><strong> 对PATH的修改只能持续到退出或重启系统</strong></p>
<h2 id="2-2-定位系统环境变量"><a href="#2-2-定位系统环境变量" class="headerlink" title="2.2 定位系统环境变量"></a>2.2 定位系统环境变量</h2><p>当你登入linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些文件叫做<font color="green">启动文件</font>。<br>bash 检查启动文件取决于你启动bash shell的方式。启动bash shell的3中方式：  </p>
<ul>
<li>登录时作为默认登录shell</li>
<li>非登录的交互式shell</li>
<li>运行脚本的非交互shell   </li>
</ul>
<h3 id="title2-2-1"> 2.2.1 登录shell</h3>

<p>登录Linux系统时，bash shell作为登录shell启动。登录shell会在5个不同的启动文件中读取命令：</p>
<ul>
<li><strong><font color="red">/etc/profile</font></strong></li>
<li>$HOME/.bash_profile</li>
<li><font color="red">$HOME/.bashrc</font></li>
<li>$HOME/.bash_login</li>
<li><font color="red">$HOME/.profile</font><br>(红色为我的系统Ubuntu的启动文件)  </li>
</ul>
  <font color="red">/etc/profile</font>文件是系统默认的bash shell 主启动文件。系统的每个用户登录都会执行这个启动文件。另外四个是针对用户的，可根据个人需求定制。<br>打开<font color="red">/etc/profile</font>可以看到,它用到了<strong>/etc/profile.d</strong>目录下的所有文件。<br><br><br>$HOME目录下的启动文件<br>- $HOME/.bash_profile<br>- <font color="red">$HOME/.bashrc</font><br>- $HOME/.bash_login<br>- <font color="red">$HOME/.profile</font>  

<p>用户可以编辑这些文件，添加自己的环境变量。这些环境变量会在启动bash shell会话时生效。  </p>
<h3 id="2-2-2-交互式shell"><a href="#2-2-2-交互式shell" class="headerlink" title="2.2.2 交互式shell"></a>2.2.2 交互式shell</h3><p>检查HOME目录下 .bashrc 。</p>
<h3 id="2-2-3-非交互式shell"><a href="#2-2-3-非交互式shell" class="headerlink" title="2.2.3 非交互式shell"></a>2.2.3 非交互式shell</h3><p>系统执行的shell脚本就是这种shell。就是脚本—没有CLI提示符。脚本用到的变量都是从父shell继承来的。  </p>
<h2 id="title2-3"> 2.3 环境变量持久化 </h2>

<p>把环境变量放在文件中，虽然可以放在 <strong><font color="red">/etc/profile</font></strong> 中。但是这样不规范。  </p>
<p>我们应该在 <strong>/etc/profile.d</strong> 中建立 <strong>.sh</strong> 文件，把自己设置的全局环境变量放在里面即可。<br>( <strong><font color="red">/etc/profile</font></strong> 会检查并读取 <strong>/etc/profile.d</strong> 下的所有文件)   </p>
<p>例如，java环境变量的配置：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/profile.d/jdk.sh</span></span><br><span class="line"><span class="built_in">export</span> J2SDKDIR=/usr/lib/jvm/java-8-oracle</span><br><span class="line"><span class="built_in">export</span> J2REDIR=/usr/lib/jvm/java-8-oracle/jre</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/lib/jvm/java-8-oracle/bin:/usr/lib/jvm/java-8-oracle/db/bin:/usr/lib/jvm/java-8-oracle/jre/binexport JAVA_HOME=/usr/lib/jvm/java-8-oracle</span><br><span class="line"><span class="built_in">export</span> DERBY_HOME=/usr/lib/jvm/java-8-oracle/db</span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/profile.d/jdk.csh</span></span><br><span class="line">setenv J2SDKDIR /usr/lib/jvm/java-8-oracle</span><br><span class="line">setenv J2REDIR /usr/lib/jvm/java-8-oracle/jre</span><br><span class="line">setenv PATH <span class="variable">$&#123;PATH&#125;</span>:/usr/lib/jvm/java-8-oracle/bin:/usr/lib/jvm/java-8-oracle/db/bin:/usr/lib/jvm/java-8-oracle/jre/bin</span><br><span class="line">setenv JAVA_HOME /usr/lib/jvm/java-8-oracle</span><br><span class="line">setenv DERBY_HOME /usr/lib/jvm/java-8-oracle/db</span><br></pre></td></tr></table></figure></p>
<p>注：<code>setenv</code> 是 <strong>c shell</strong> 中的命令，作用和 <strong>bash</strong> 中的 export 一样。</p>
<h1 id="3-数组变量"><a href="#3-数组变量" class="headerlink" title="3 数组变量"></a>3 数组变量</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建数组变量</span></span><br><span class="line">mytest=(one two three four)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;mytest[2]&#125;</span></span><br><span class="line"><span class="comment">#输出three</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/30/理解shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/30/理解shell/" itemprop="url">理解shell</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-30T18:06:57+08:00">
                2017-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-shell-类型"><a href="#1-shell-类型" class="headerlink" title="1. shell 类型"></a>1. shell 类型</h1><p>系统启用什么样的shell取决于你个人的配置。在/etc/passwd文件中，第七个字段列出了默认的shell程序。<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic/shell-lijie.png" alt><br>查看一下/bin/bash 可以发现bash是可执行程序(有个星号，参见ls -F)。<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic/ls-bashshell.png" alt></p>
<p>再看看系统默认的shell，这是一个symbolic link 文件，指向dash。所以，默认和user交互的shell是bash shell；默认系统shell是dash shell。<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic/bin-sh-ls.png" alt></p>
<h1 id="2-shell的父子关系"><a href="#2-shell的父子关系" class="headerlink" title="2. shell的父子关系"></a>2. shell的父子关系</h1><p>在bash shell里打开一个dash shell （子shell）<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/chile-shell.png" alt><br>可以看第二次执行ps -f 时，多了一个子shell。<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/child-shell2.png" alt></p>
<p>进程列表：(pwd;ls;cd /ctc)，在括号里写命令，分号分隔，就是进程列表。进程列表会在子shell中执行。</p>
<h1 id="3-shell-内建命令"><a href="#3-shell-内建命令" class="headerlink" title="3. shell 内建命令"></a>3. shell 内建命令</h1><p>內建命令和外部命令执行的时候有很大的不同。</p>
<p>外部命令又称文件系统命令。是存在与于bash shell 之外的程序。外部命令通常位于/bin, /usr/bin, /sbin, /usr/sbin中。可以用which和type找到它们的位置。<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic2/bultin-cmd.png" alt></p>
<p><font color="orange"> 当外部命令执行时，会创建出一个子进程。这种操作叫衍生（forKing）。</font><br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic2/shell-forking.png" alt><br>ps的父进程PID是9943。  </p>
<p>有的命令有多种实现，比如echo和pwd，可以用type -a 查看。<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic2/bultin-cmd-pwd.png" alt>    </p>
<p>內建命令，不需要通过衍生出子进程来执行，也不用打开程序文件。所以，执行速度快，效率高。內建命令有很多: cd, fg, bg, history, test, alias…<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic2/bultin-cmd-alias.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/30/再装Ubuntu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/30/再装Ubuntu/" itemprop="url">再装Ubuntu</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-30T14:33:37+08:00">
                2017-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于之前遇到的Ubuntu16.04安装fcitx的问题没有解决，而后又遇到scim崩溃–把系统卡死（htop看到4核cpu和12G内存全部变红）。</p>
<p>我重新安装了Ubuntu，现在就做个简单的总结。</p>
<h1 id="修复grub-amp-再添加引导win10"><a href="#修复grub-amp-再添加引导win10" class="headerlink" title="修复grub &amp; 再添加引导win10"></a>修复grub &amp; 再添加引导win10</h1><p>安装了Ubuntu16.04在win10上，没有grup的引导，开机直接进04在win10。<br>解决方法：<br>利用Ubuntu安装U盘try Ubuntu来修复。连上网，打开终端：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:yannubuntu/boot-repair</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装boot-repair</span></span><br><span class="line"><span class="meta">#</span><span class="bash">这个工具可以修好大多数引导问题</span></span><br><span class="line">sudo apt-get install -y boot-repair &amp;&amp; boot-repair</span><br></pre></td></tr></table></figure></p>
<p>然后出现boot-repair的界面，选择Recommend repair过几分钟就OK了。</p>
<p>重启以后，grub引导选项里发现没有win10 。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">更新一下grub就有win10 了</span></span><br><span class="line">sudo update-grub  </span><br><span class="line"><span class="meta">#</span><span class="bash">sudo update-grub2 <span class="comment">#也行</span></span></span><br></pre></td></tr></table></figure></p>
<p>问题已经没有了。<br>如果想排序grub引导os的顺序参考下图：<br><img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic/grub-sort.png" alt><br>30_os-prober 那个就是win10 。把30改为08或09就能放在前面了。</p>
<p>注：  </p>
<ol>
<li>个人的一些个性化设置，如命令别名、路径等，可以在~/.bashrc中设置。</li>
<li></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate grub | grep grub</span><br></pre></td></tr></table></figure>
<p>可以看到关于grub的设置在/ect/default和/boot/grub中也有。</p>
<hr>
<h1 id="grub-BASH-like"><a href="#grub-BASH-like" class="headerlink" title="grub BASH-like"></a>grub BASH-like</h1><p>在修复之前我还遇到一个问题：开机显示  </p>
<p><font color="orange">Minimal BASH-like line editing is supported.</font><br>这是修复grub出错的一个正常提示。修复方法在上面已经给出了。<br>下面给一个进入win10 的方法：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">从硬盘的第一个分区C盘启动</span></span><br><span class="line"><span class="meta">grub&gt;</span><span class="bash">root (hd0,0)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">指示grub读取分区第一个扇区的引导记录</span></span><br><span class="line"><span class="meta">grub&gt;</span><span class="bash">chainloader (hd0,0)+1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">启动grub</span></span><br><span class="line"><span class="meta">grub&gt;</span><span class="bash">安装boot</span></span><br></pre></td></tr></table></figure></p>
<p>看似这样可以进入grub引导。实际上，会进入win的mbr引导。</p>
<hr>
<h1 id="搜狗"><a href="#搜狗" class="headerlink" title="搜狗"></a>搜狗</h1><p>这次安装搜狗输入法就简单的多了。</p>
<ol>
<li>下载Linux版搜狗输入法</li>
<li>dpkg 命令安装deb软件包</li>
<li>缺少依赖，sudo apt-get install -f 修复依赖问题</li>
<li>再安装，完成。  </li>
</ol>
<p>可以发现这里没有安装fcitx。但是还是装好了搜狗，重点在于install后面的 <strong><font color="red"> -f </font></strong>  。</p>
<hr>
<h1 id="别的安装："><a href="#别的安装：" class="headerlink" title="别的安装："></a>别的安装：</h1><p>1 . Google浏览器翻墙在官网下载Linux安装包。<br>2 . atom 在官网下载安装包。<br>3 . shadowsocks-QT5安装方法：<br>网上的添加源安装行。也可<a href="https://github.com/shadowsocks/shadowsocks/tree/master" target="_blank" rel="noopener">参考这里</a>。安装完成，再在chrome上安装插件SwitchySharp，配置一下即可翻墙。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/30/简单的bash-shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/30/简单的bash-shell/" itemprop="url">简单的bash shell</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-30T13:47:36+08:00">
                2017-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于文件"><a href="#关于文件" class="headerlink" title="关于文件"></a>关于文件</h1><p><font color="green">pwd </font>: <font color="green">P</font>rint name of <font color="green">W</font>orking <font color="green">D</font>irectory</p>
<p><font color="green">ls </font>:<br>过滤器（通配符）：</p>
<ul>
<li>问号（？）代表1个字符</li>
<li>星号（*）代表0个或多个字符</li>
<li>元字符通配符[a-z]表示a-z中任一字符</li>
<li>元字符通配符[!a]表示匹配除a以外的字符</li>
</ul>
<p>和SQL中的通配符类似，通配符和正则匹配的区别在与：通配符匹配所有内容。<br>例如：</p>
<ul>
<li>通配符匹配：‘my’表示匹配的内容全名就是‘my’</li>
<li>正则匹配：‘my’表示匹配的内容里有‘my’</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l my*  #ls 列出以my开头的文件信息</span><br></pre></td></tr></table></figure>
<h2 id="文件操作基本命令："><a href="#文件操作基本命令：" class="headerlink" title="文件操作基本命令："></a>文件操作基本命令：</h2><ol>
<li>操作</li>
</ol>
<ul>
<li>touch</li>
<li>cp</li>
<li>mv 改名或移动</li>
<li>rm</li>
</ul>
<p>2.查看</p>
<ul>
<li>tree</li>
<li>file 查看文件类型</li>
<li>cat , head , tail</li>
<li>more 显示文本文件</li>
<li>less 是more的升级版，可以查找</li>
</ul>
<h2 id="链接文件："><a href="#链接文件：" class="headerlink" title="链接文件："></a>链接文件：</h2><ol>
<li><p><font color="orange">硬链接</font>:<br>hard link，硬链接和原始文件是同一个文件–唯一标识文件的inode号是一样的。</p>
</li>
<li><p><font color="orange">符号链接</font>（软链接）:<br>symbolic link，符号链接是一个单独的文件。这个文件指向原始文件（原始文件一定要存在）。ln -s 可以创建符号链接。</p>
</li>
</ol>
<p>用 <strong>ls -li</strong> 查看文件时，可以看到，软链接文件的大小比原始文件小，此外还有一个指针指向原始文件，inode号不同。硬链接和原始文件一模一样。  </p>
<p><strong>硬链接</strong> 存在以下几点特性：  </p>
<ul>
<li>文件有相同的 inode 及 data block  </li>
<li>只能对已存在的文件进行创建</li>
<li>不能交叉 <strong>文件系统</strong> 进行硬链接的创建</li>
<li>不能对 <strong>目录</strong> 进行创建，只可对文件创建</li>
<li>删除一个硬链接文件并不影响其他有相同 inode 号的文件</li>
</ul>
<p><strong>符号链接</strong> 特点：   </p>
<ul>
<li>软链接有自己的文件属性及权限等</li>
<li>可对不存在的文件或目录创建软链接</li>
<li>软链接可交叉 <strong>文件系统</strong></li>
<li>软链接可对文件或 <strong>目录</strong> 创建</li>
<li>创建软链接时，链接计数 i_nlink 不会增加</li>
<li>删除软链接并不影响被指向的文件，但 <strong>若被指向的原文件被删除，则相关软连接被称为死链接</strong> (即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接 )</li>
</ul>
<h1 id="关于进程"><a href="#关于进程" class="headerlink" title="关于进程"></a>关于进程</h1><p><font color="green">ps  </font>:<br>process, 查看当前时间点的进程信息。<br>ps有两个版本，但相差不大。给出两个版本最常用的参数。<br>BSD版本：ps -aux<br>UNIX版本：ps -ef</p>
<p><font color="green">top  </font>:<br>task of process，top将输出进程叫做任务（task）。top可以<font color="red">实时监测</font>进程的状态。  </p>
<p><font color="orange">建议使用htop</font>，top的升级版。</p>
<p><font color="green">kill  </font>:<br>kill杀死指定进程号进程。可以和对应的linux进程信号联用。比如：9无条件终止；1挂起；2中断等等。  </p>
<p><font color="green">killall  </font>:<br>killall杀死指定进程名进程。例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall http*  <span class="comment">#杀死所有以http开头的进程</span></span><br></pre></td></tr></table></figure></p>
<h1 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h1><p><font color="green">df  </font>:  </p>
<p><font color="red">D</font>isk space available on <font color="red">F</font>ile system，可以查看所有挂载的文件系统，以及磁盘空间的使用情况。<br>一般用法：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure></p>
<p><font color="green">du  </font>:  </p>
<p><font color="red">D</font>isk <font color="red">U</font>sage，磁盘使用情况。一般用于查看文件/目录大小。<br>一般用法：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h  <span class="comment">#当前目录下各个文件所占磁盘空间</span></span><br></pre></td></tr></table></figure></p>
<p><font color="green">mount  </font>:<br>mount原意为骑上，增加。这里表示挂载。<br>用法：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看挂载情况，我觉得用df更好</span></span><br><span class="line">mount  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">把U盘挂载/dev/sdb1挂载到/media/disk</span></span><br><span class="line">mount -t vfat /dev/sdb1 /media/disk</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">卸载U盘</span></span><br><span class="line">umount /dev/sdb1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">下面命令可以修复Linux下的win盘挂载错误</span></span><br><span class="line">ntfsfix /filesystem</span><br><span class="line"><span class="meta">#</span><span class="bash">如果报错，关闭win快速启动</span></span><br></pre></td></tr></table></figure></p>
<h1 id="处理数据文件"><a href="#处理数据文件" class="headerlink" title="处理数据文件"></a>处理数据文件</h1><p><font color="green">sort  </font>:<br>排序数据。<br>options:</p>
<ul>
<li>-b  –ignore-leading-blank忽略起始空白</li>
<li>-n  –numeric-sort</li>
<li>-g  –general-number-sort把值当成浮点数</li>
<li>-r  –revers</li>
</ul>
<p>一个例子：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">当前目录下文件占用空间情况，逆序输出</span></span><br><span class="line">du -sh * | sort -nr</span><br></pre></td></tr></table></figure></p>
<p><font color="green">grep  </font>:<br>搜索数据–非常流行的命令。<br>synopsis：<br>  grep [options] pattern [file]<br>  在名为 file 的文件中查找 含有pattern关键字的行。</p>
<p>options:</p>
<ul>
<li>-v 相反匹配</li>
<li>-c 匹配到的总行数</li>
<li>[] 正则匹配指定字符，如[tf]匹配t或f</li>
<li>.</li>
<li>*<br>等等</li>
</ul>
<p><font color="green">tar  </font>:  </p>
<p>gzip-&gt;.gz<br>GNU压缩工具<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">压缩：</span></span><br><span class="line">tar –zcvf filename.tar.gz filename(dirname)</span><br><span class="line"><span class="meta">#</span><span class="bash">解压：</span></span><br><span class="line">tar –zxvf filename.tar.gz filename(dirname)</span><br></pre></td></tr></table></figure></p>
<p>bzip2-&gt;.bz2<br>采用<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">压缩：</span></span><br><span class="line">tar –jcvf filename.tar.bz2 filename(dirname)</span><br><span class="line"><span class="meta">#</span><span class="bash">解压：</span></span><br><span class="line">tar –jxvf filename.tar.bz2 filename(dirname)</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/28/无为的一个下午/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mitre">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MITRE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/28/无为的一个下午/" itemprop="url">无为的一个下午</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-28T16:54:32+08:00">
                2017-11-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong><font color="orange">你应该庆幸自己遇到了问题</font></strong><br><strong><font color="orange">因此，没有蒙在鼓里</font></strong></p>
<hr>
<p>今天我装fcitx装了一个下午，其实我前两天就开始装了。一直没装好。</p>
<p>看遍了网上的教程也没有解决问题  </p>
<ul>
<li><a href="https://github.com/fcitx" target="_blank" rel="noopener">fcitx-github</a>  </li>
<li><a href="https://fcitx-im.org/wiki/Fcitx" target="_blank" rel="noopener">fcitx 官网</a></li>
<li><a href="http://blog.csdn.net/striker_v/article/details/51914637" target="_blank" rel="noopener">一般安装方法</a></li>
</ul>
<p>我安装了fcitx，没有报错，我还安装了 fcitx- 一系列的包，可是，打开fcitx提示，<br> <img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic/fcitx-error-cx.png" alt>  </p>
<p> <img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic/apt-cache-depends.png" alt></p>
<p>正确的打开方式应该如下：<br> <img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic/fcitx-dp.png" alt><br>正常打开fcitx输入法会有几个fcitx的进程。我的没有。</p>
<p>关于输入法IM 环境变量 (我把自己的也相同设置了)<br> <img src="http://mitre.oss-cn-hangzhou.aliyuncs.com/blog_pic/2017.png" alt></p>
<p> 此外<br> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate fcitx | grep <span class="string">"fcitx$"</span></span><br></pre></td></tr></table></figure></p>
<p> 查看了关于fcitx一些文件，还有~/.config目录下的配置文件，未果Q_Q</p>
<p>为啥会有错误呢？<br>可能是之前update , install -f  有问题，删除了某些文件，也可能是我出了错误，安装了XIM , SCIM (后来apt remove了还是不行)更改了某些输入法配置文件。<br>现在先用着SCIM的智能拼音，有时间再把这个坑添上= =</p>
<hr>
<p>大二的时候安装sogou，按照教程走一遍，ok了，多简单。虽然成功了，却没有理解其中的原理，也没有注意程序输出的内容。</p>
<p><strong><font color="orange">现在遇到问题，不如以前遇到问题，以后遇到问题，不如今天遇到问题。</font></strong></p>
<p>总之，多积累。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://mitre.oss-cn-hangzhou.aliyuncs.com/img/vlcsnap-2018-02-22-21h01m56s237.png" alt="mitre">
            
              <p class="site-author-name" itemprop="name">mitre</p>
              <p class="site-description motion-element" itemprop="description">Goals determine what you are going to be</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">105</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-globe"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.yanmin99.com/" title="yanmin" target="_blank">yanmin</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://whark.cn" title="大鹏" target="_blank">大鹏</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.notall.cn/" title="zkp" target="_blank">zkp</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://qiracle.cn/" title="强强" target="_blank">强强</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mitre</span>

  
</div>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">totle: <span id="busuanzi_value_site_pv"></span> times</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">Visitors: <span id="busuanzi_value_site_uv"></span></span>
    <span class="post-meta-divider">|</span>



  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>






        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
